
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4826      	ldr	r0, [pc, #152]	; (800025c <endfiniloop+0x6>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	4825      	ldr	r0, [pc, #148]	; (8000260 <endfiniloop+0xa>)
 80001ca:	f64e 5108 	movw	r1, #60680	; 0xed08
 80001ce:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001d2:	6008      	str	r0, [r1, #0]
 80001d4:	2002      	movs	r0, #2
 80001d6:	f380 8814 	msr	CONTROL, r0
 80001da:	f3bf 8f6f 	isb	sy
 80001de:	f001 fd2f 	bl	8001c40 <__core_init>
 80001e2:	f009 fb0d 	bl	8009800 <__early_init>
 80001e6:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 80001ea:	491e      	ldr	r1, [pc, #120]	; (8000264 <endfiniloop+0xe>)
 80001ec:	4a1e      	ldr	r2, [pc, #120]	; (8000268 <endfiniloop+0x12>)

080001ee <msloop>:
 80001ee:	4291      	cmp	r1, r2
 80001f0:	bf3c      	itt	cc
 80001f2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f6:	e7fa      	bcc.n	80001ee <msloop>
 80001f8:	491c      	ldr	r1, [pc, #112]	; (800026c <endfiniloop+0x16>)
 80001fa:	4a18      	ldr	r2, [pc, #96]	; (800025c <endfiniloop+0x6>)

080001fc <psloop>:
 80001fc:	4291      	cmp	r1, r2
 80001fe:	bf3c      	itt	cc
 8000200:	f841 0b04 	strcc.w	r0, [r1], #4
 8000204:	e7fa      	bcc.n	80001fc <psloop>
 8000206:	491a      	ldr	r1, [pc, #104]	; (8000270 <endfiniloop+0x1a>)
 8000208:	4a1a      	ldr	r2, [pc, #104]	; (8000274 <endfiniloop+0x1e>)
 800020a:	4b1b      	ldr	r3, [pc, #108]	; (8000278 <endfiniloop+0x22>)

0800020c <dloop>:
 800020c:	429a      	cmp	r2, r3
 800020e:	bf3e      	ittt	cc
 8000210:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000214:	f842 0b04 	strcc.w	r0, [r2], #4
 8000218:	e7f8      	bcc.n	800020c <dloop>
 800021a:	2000      	movs	r0, #0
 800021c:	4917      	ldr	r1, [pc, #92]	; (800027c <endfiniloop+0x26>)
 800021e:	4a18      	ldr	r2, [pc, #96]	; (8000280 <endfiniloop+0x2a>)

08000220 <bloop>:
 8000220:	4291      	cmp	r1, r2
 8000222:	bf3c      	itt	cc
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
 8000228:	e7fa      	bcc.n	8000220 <bloop>
 800022a:	f001 fcc9 	bl	8001bc0 <__init_ram_areas>
 800022e:	f001 fcff 	bl	8001c30 <__late_init>
 8000232:	4c14      	ldr	r4, [pc, #80]	; (8000284 <endfiniloop+0x2e>)
 8000234:	4d14      	ldr	r5, [pc, #80]	; (8000288 <endfiniloop+0x32>)

08000236 <initloop>:
 8000236:	42ac      	cmp	r4, r5
 8000238:	da03      	bge.n	8000242 <endinitloop>
 800023a:	f854 1b04 	ldr.w	r1, [r4], #4
 800023e:	4788      	blx	r1
 8000240:	e7f9      	b.n	8000236 <initloop>

08000242 <endinitloop>:
 8000242:	f001 ff5d 	bl	8002100 <main>
 8000246:	4c11      	ldr	r4, [pc, #68]	; (800028c <endfiniloop+0x36>)
 8000248:	4d11      	ldr	r5, [pc, #68]	; (8000290 <endfiniloop+0x3a>)

0800024a <finiloop>:
 800024a:	42ac      	cmp	r4, r5
 800024c:	da03      	bge.n	8000256 <endfiniloop>
 800024e:	f854 1b04 	ldr.w	r1, [r4], #4
 8000252:	4788      	blx	r1
 8000254:	e7f9      	b.n	800024a <finiloop>

08000256 <endfiniloop>:
 8000256:	f001 bce3 	b.w	8001c20 <__default_exit>
 800025a:	0000      	.short	0x0000
 800025c:	20000800 	.word	0x20000800
 8000260:	08000000 	.word	0x08000000
 8000264:	20000000 	.word	0x20000000
 8000268:	20000400 	.word	0x20000400
 800026c:	20000400 	.word	0x20000400
 8000270:	0800c5b4 	.word	0x0800c5b4
 8000274:	20000800 	.word	0x20000800
 8000278:	20000c88 	.word	0x20000c88
 800027c:	20000c88 	.word	0x20000c88
 8000280:	20002738 	.word	0x20002738
 8000284:	080001c0 	.word	0x080001c0
 8000288:	080001c0 	.word	0x080001c0
 800028c:	080001c0 	.word	0x080001c0
 8000290:	080001c0 	.word	0x080001c0

08000294 <_port_switch>:
 8000294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000298:	f8c1 d00c 	str.w	sp, [r1, #12]
 800029c:	68c3      	ldr	r3, [r0, #12]
 800029e:	469d      	mov	sp, r3
 80002a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002a4 <_port_thread_start>:
 80002a4:	f000 ffb4 	bl	8001210 <_dbg_check_unlock>
 80002a8:	2300      	movs	r3, #0
 80002aa:	f383 8811 	msr	BASEPRI, r3
 80002ae:	4628      	mov	r0, r5
 80002b0:	47a0      	blx	r4
 80002b2:	2000      	movs	r0, #0
 80002b4:	f001 fb0c 	bl	80018d0 <chThdExit>

080002b8 <_port_switch_from_isr>:
 80002b8:	f000 ffd2 	bl	8001260 <_dbg_check_lock>
 80002bc:	f000 fb70 	bl	80009a0 <chSchDoReschedule>
 80002c0:	f000 ffa6 	bl	8001210 <_dbg_check_unlock>

080002c4 <_port_exit_from_isr>:
 80002c4:	df00      	svc	0
 80002c6:	e7fe      	b.n	80002c6 <_port_exit_from_isr+0x2>

080002c8 <memcpy>:
 80002c8:	4684      	mov	ip, r0
 80002ca:	ea41 0300 	orr.w	r3, r1, r0
 80002ce:	f013 0303 	ands.w	r3, r3, #3
 80002d2:	d16d      	bne.n	80003b0 <memcpy+0xe8>
 80002d4:	3a40      	subs	r2, #64	; 0x40
 80002d6:	d341      	bcc.n	800035c <memcpy+0x94>
 80002d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002dc:	f840 3b04 	str.w	r3, [r0], #4
 80002e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002e4:	f840 3b04 	str.w	r3, [r0], #4
 80002e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002ec:	f840 3b04 	str.w	r3, [r0], #4
 80002f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f4:	f840 3b04 	str.w	r3, [r0], #4
 80002f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002fc:	f840 3b04 	str.w	r3, [r0], #4
 8000300:	f851 3b04 	ldr.w	r3, [r1], #4
 8000304:	f840 3b04 	str.w	r3, [r0], #4
 8000308:	f851 3b04 	ldr.w	r3, [r1], #4
 800030c:	f840 3b04 	str.w	r3, [r0], #4
 8000310:	f851 3b04 	ldr.w	r3, [r1], #4
 8000314:	f840 3b04 	str.w	r3, [r0], #4
 8000318:	f851 3b04 	ldr.w	r3, [r1], #4
 800031c:	f840 3b04 	str.w	r3, [r0], #4
 8000320:	f851 3b04 	ldr.w	r3, [r1], #4
 8000324:	f840 3b04 	str.w	r3, [r0], #4
 8000328:	f851 3b04 	ldr.w	r3, [r1], #4
 800032c:	f840 3b04 	str.w	r3, [r0], #4
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	3a40      	subs	r2, #64	; 0x40
 800035a:	d2bd      	bcs.n	80002d8 <memcpy+0x10>
 800035c:	3230      	adds	r2, #48	; 0x30
 800035e:	d311      	bcc.n	8000384 <memcpy+0xbc>
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	3a10      	subs	r2, #16
 8000382:	d2ed      	bcs.n	8000360 <memcpy+0x98>
 8000384:	320c      	adds	r2, #12
 8000386:	d305      	bcc.n	8000394 <memcpy+0xcc>
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	3a04      	subs	r2, #4
 8000392:	d2f9      	bcs.n	8000388 <memcpy+0xc0>
 8000394:	3204      	adds	r2, #4
 8000396:	d008      	beq.n	80003aa <memcpy+0xe2>
 8000398:	07d2      	lsls	r2, r2, #31
 800039a:	bf1c      	itt	ne
 800039c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003a0:	f800 3b01 	strbne.w	r3, [r0], #1
 80003a4:	d301      	bcc.n	80003aa <memcpy+0xe2>
 80003a6:	880b      	ldrh	r3, [r1, #0]
 80003a8:	8003      	strh	r3, [r0, #0]
 80003aa:	4660      	mov	r0, ip
 80003ac:	4770      	bx	lr
 80003ae:	bf00      	nop
 80003b0:	2a08      	cmp	r2, #8
 80003b2:	d313      	bcc.n	80003dc <memcpy+0x114>
 80003b4:	078b      	lsls	r3, r1, #30
 80003b6:	d08d      	beq.n	80002d4 <memcpy+0xc>
 80003b8:	f010 0303 	ands.w	r3, r0, #3
 80003bc:	d08a      	beq.n	80002d4 <memcpy+0xc>
 80003be:	f1c3 0304 	rsb	r3, r3, #4
 80003c2:	1ad2      	subs	r2, r2, r3
 80003c4:	07db      	lsls	r3, r3, #31
 80003c6:	bf1c      	itt	ne
 80003c8:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003cc:	f800 3b01 	strbne.w	r3, [r0], #1
 80003d0:	d380      	bcc.n	80002d4 <memcpy+0xc>
 80003d2:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003d6:	f820 3b02 	strh.w	r3, [r0], #2
 80003da:	e77b      	b.n	80002d4 <memcpy+0xc>
 80003dc:	3a04      	subs	r2, #4
 80003de:	d3d9      	bcc.n	8000394 <memcpy+0xcc>
 80003e0:	3a01      	subs	r2, #1
 80003e2:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003e6:	f800 3b01 	strb.w	r3, [r0], #1
 80003ea:	d2f9      	bcs.n	80003e0 <memcpy+0x118>
 80003ec:	780b      	ldrb	r3, [r1, #0]
 80003ee:	7003      	strb	r3, [r0, #0]
 80003f0:	784b      	ldrb	r3, [r1, #1]
 80003f2:	7043      	strb	r3, [r0, #1]
 80003f4:	788b      	ldrb	r3, [r1, #2]
 80003f6:	7083      	strb	r3, [r0, #2]
 80003f8:	4660      	mov	r0, ip
 80003fa:	4770      	bx	lr
 80003fc:	0000      	movs	r0, r0
 80003fe:	0000      	movs	r0, r0
 8000400:	eba2 0003 	sub.w	r0, r2, r3
 8000404:	4770      	bx	lr
 8000406:	bf00      	nop

08000408 <strcmp>:
 8000408:	7802      	ldrb	r2, [r0, #0]
 800040a:	780b      	ldrb	r3, [r1, #0]
 800040c:	2a01      	cmp	r2, #1
 800040e:	bf28      	it	cs
 8000410:	429a      	cmpcs	r2, r3
 8000412:	d1f5      	bne.n	8000400 <memcpy+0x138>
 8000414:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000418:	ea40 0401 	orr.w	r4, r0, r1
 800041c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000420:	f06f 0c00 	mvn.w	ip, #0
 8000424:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000428:	b312      	cbz	r2, 8000470 <strcmp+0x68>
 800042a:	ea80 0401 	eor.w	r4, r0, r1
 800042e:	f014 0f07 	tst.w	r4, #7
 8000432:	d16a      	bne.n	800050a <strcmp+0x102>
 8000434:	f000 0407 	and.w	r4, r0, #7
 8000438:	f020 0007 	bic.w	r0, r0, #7
 800043c:	f004 0503 	and.w	r5, r4, #3
 8000440:	f021 0107 	bic.w	r1, r1, #7
 8000444:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000448:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800044c:	f014 0f04 	tst.w	r4, #4
 8000450:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000454:	fa0c f405 	lsl.w	r4, ip, r5
 8000458:	ea62 0204 	orn	r2, r2, r4
 800045c:	ea66 0604 	orn	r6, r6, r4
 8000460:	d00a      	beq.n	8000478 <strcmp+0x70>
 8000462:	ea63 0304 	orn	r3, r3, r4
 8000466:	4662      	mov	r2, ip
 8000468:	ea67 0704 	orn	r7, r7, r4
 800046c:	4666      	mov	r6, ip
 800046e:	e003      	b.n	8000478 <strcmp+0x70>
 8000470:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000474:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000478:	fa82 f54c 	uadd8	r5, r2, ip
 800047c:	ea82 0406 	eor.w	r4, r2, r6
 8000480:	faa4 f48c 	sel	r4, r4, ip
 8000484:	bb6c      	cbnz	r4, 80004e2 <strcmp+0xda>
 8000486:	fa83 f54c 	uadd8	r5, r3, ip
 800048a:	ea83 0507 	eor.w	r5, r3, r7
 800048e:	faa5 f58c 	sel	r5, r5, ip
 8000492:	b995      	cbnz	r5, 80004ba <strcmp+0xb2>
 8000494:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 8000498:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 800049c:	fa82 f54c 	uadd8	r5, r2, ip
 80004a0:	ea82 0406 	eor.w	r4, r2, r6
 80004a4:	faa4 f48c 	sel	r4, r4, ip
 80004a8:	fa83 f54c 	uadd8	r5, r3, ip
 80004ac:	ea83 0507 	eor.w	r5, r3, r7
 80004b0:	faa5 f58c 	sel	r5, r5, ip
 80004b4:	4325      	orrs	r5, r4
 80004b6:	d0db      	beq.n	8000470 <strcmp+0x68>
 80004b8:	b99c      	cbnz	r4, 80004e2 <strcmp+0xda>
 80004ba:	ba2d      	rev	r5, r5
 80004bc:	fab5 f485 	clz	r4, r5
 80004c0:	f024 0407 	bic.w	r4, r4, #7
 80004c4:	fa27 f104 	lsr.w	r1, r7, r4
 80004c8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80004cc:	fa23 f304 	lsr.w	r3, r3, r4
 80004d0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 80004d4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80004d8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80004dc:	eba0 0001 	sub.w	r0, r0, r1
 80004e0:	4770      	bx	lr
 80004e2:	ba24      	rev	r4, r4
 80004e4:	fab4 f484 	clz	r4, r4
 80004e8:	f024 0407 	bic.w	r4, r4, #7
 80004ec:	fa26 f104 	lsr.w	r1, r6, r4
 80004f0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 80004f4:	fa22 f204 	lsr.w	r2, r2, r4
 80004f8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 80004fc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000500:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000504:	eba0 0001 	sub.w	r0, r0, r1
 8000508:	4770      	bx	lr
 800050a:	f014 0f03 	tst.w	r4, #3
 800050e:	d13c      	bne.n	800058a <strcmp+0x182>
 8000510:	f010 0403 	ands.w	r4, r0, #3
 8000514:	d128      	bne.n	8000568 <strcmp+0x160>
 8000516:	f850 2b08 	ldr.w	r2, [r0], #8
 800051a:	f851 3b08 	ldr.w	r3, [r1], #8
 800051e:	fa82 f54c 	uadd8	r5, r2, ip
 8000522:	ea82 0503 	eor.w	r5, r2, r3
 8000526:	faa5 f58c 	sel	r5, r5, ip
 800052a:	b95d      	cbnz	r5, 8000544 <strcmp+0x13c>
 800052c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000530:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000534:	fa82 f54c 	uadd8	r5, r2, ip
 8000538:	ea82 0503 	eor.w	r5, r2, r3
 800053c:	faa5 f58c 	sel	r5, r5, ip
 8000540:	2d00      	cmp	r5, #0
 8000542:	d0e8      	beq.n	8000516 <strcmp+0x10e>
 8000544:	ba2d      	rev	r5, r5
 8000546:	fab5 f485 	clz	r4, r5
 800054a:	f024 0407 	bic.w	r4, r4, #7
 800054e:	fa23 f104 	lsr.w	r1, r3, r4
 8000552:	fa22 f204 	lsr.w	r2, r2, r4
 8000556:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800055a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800055e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000562:	eba0 0001 	sub.w	r0, r0, r1
 8000566:	4770      	bx	lr
 8000568:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800056c:	f020 0003 	bic.w	r0, r0, #3
 8000570:	f850 2b08 	ldr.w	r2, [r0], #8
 8000574:	f021 0103 	bic.w	r1, r1, #3
 8000578:	f851 3b08 	ldr.w	r3, [r1], #8
 800057c:	fa0c f404 	lsl.w	r4, ip, r4
 8000580:	ea62 0204 	orn	r2, r2, r4
 8000584:	ea63 0304 	orn	r3, r3, r4
 8000588:	e7c9      	b.n	800051e <strcmp+0x116>
 800058a:	f010 0403 	ands.w	r4, r0, #3
 800058e:	d01a      	beq.n	80005c6 <strcmp+0x1be>
 8000590:	eba1 0104 	sub.w	r1, r1, r4
 8000594:	f020 0003 	bic.w	r0, r0, #3
 8000598:	07e4      	lsls	r4, r4, #31
 800059a:	f850 2b04 	ldr.w	r2, [r0], #4
 800059e:	d006      	beq.n	80005ae <strcmp+0x1a6>
 80005a0:	d20f      	bcs.n	80005c2 <strcmp+0x1ba>
 80005a2:	788b      	ldrb	r3, [r1, #2]
 80005a4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80005a8:	1ae4      	subs	r4, r4, r3
 80005aa:	d106      	bne.n	80005ba <strcmp+0x1b2>
 80005ac:	b12b      	cbz	r3, 80005ba <strcmp+0x1b2>
 80005ae:	78cb      	ldrb	r3, [r1, #3]
 80005b0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80005b4:	1ae4      	subs	r4, r4, r3
 80005b6:	d100      	bne.n	80005ba <strcmp+0x1b2>
 80005b8:	b91b      	cbnz	r3, 80005c2 <strcmp+0x1ba>
 80005ba:	4620      	mov	r0, r4
 80005bc:	f85d 4b10 	ldr.w	r4, [sp], #16
 80005c0:	4770      	bx	lr
 80005c2:	f101 0104 	add.w	r1, r1, #4
 80005c6:	f850 2b04 	ldr.w	r2, [r0], #4
 80005ca:	07cc      	lsls	r4, r1, #31
 80005cc:	f021 0103 	bic.w	r1, r1, #3
 80005d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80005d4:	d848      	bhi.n	8000668 <strcmp+0x260>
 80005d6:	d224      	bcs.n	8000622 <strcmp+0x21a>
 80005d8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 80005dc:	fa82 f54c 	uadd8	r5, r2, ip
 80005e0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 80005e4:	faa5 f58c 	sel	r5, r5, ip
 80005e8:	d10a      	bne.n	8000600 <strcmp+0x1f8>
 80005ea:	b965      	cbnz	r5, 8000606 <strcmp+0x1fe>
 80005ec:	f851 3b04 	ldr.w	r3, [r1], #4
 80005f0:	ea84 0402 	eor.w	r4, r4, r2
 80005f4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 80005f8:	d10e      	bne.n	8000618 <strcmp+0x210>
 80005fa:	f850 2b04 	ldr.w	r2, [r0], #4
 80005fe:	e7eb      	b.n	80005d8 <strcmp+0x1d0>
 8000600:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000604:	e055      	b.n	80006b2 <strcmp+0x2aa>
 8000606:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800060a:	d14d      	bne.n	80006a8 <strcmp+0x2a0>
 800060c:	7808      	ldrb	r0, [r1, #0]
 800060e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000612:	f1c0 0000 	rsb	r0, r0, #0
 8000616:	4770      	bx	lr
 8000618:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800061c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000620:	e047      	b.n	80006b2 <strcmp+0x2aa>
 8000622:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000626:	fa82 f54c 	uadd8	r5, r2, ip
 800062a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800062e:	faa5 f58c 	sel	r5, r5, ip
 8000632:	d10a      	bne.n	800064a <strcmp+0x242>
 8000634:	b965      	cbnz	r5, 8000650 <strcmp+0x248>
 8000636:	f851 3b04 	ldr.w	r3, [r1], #4
 800063a:	ea84 0402 	eor.w	r4, r4, r2
 800063e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000642:	d10c      	bne.n	800065e <strcmp+0x256>
 8000644:	f850 2b04 	ldr.w	r2, [r0], #4
 8000648:	e7eb      	b.n	8000622 <strcmp+0x21a>
 800064a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800064e:	e030      	b.n	80006b2 <strcmp+0x2aa>
 8000650:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000654:	d128      	bne.n	80006a8 <strcmp+0x2a0>
 8000656:	880b      	ldrh	r3, [r1, #0]
 8000658:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800065c:	e029      	b.n	80006b2 <strcmp+0x2aa>
 800065e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000662:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8000666:	e024      	b.n	80006b2 <strcmp+0x2aa>
 8000668:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800066c:	fa82 f54c 	uadd8	r5, r2, ip
 8000670:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8000674:	faa5 f58c 	sel	r5, r5, ip
 8000678:	d10a      	bne.n	8000690 <strcmp+0x288>
 800067a:	b965      	cbnz	r5, 8000696 <strcmp+0x28e>
 800067c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000680:	ea84 0402 	eor.w	r4, r4, r2
 8000684:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 8000688:	d109      	bne.n	800069e <strcmp+0x296>
 800068a:	f850 2b04 	ldr.w	r2, [r0], #4
 800068e:	e7eb      	b.n	8000668 <strcmp+0x260>
 8000690:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8000694:	e00d      	b.n	80006b2 <strcmp+0x2aa>
 8000696:	f015 0fff 	tst.w	r5, #255	; 0xff
 800069a:	d105      	bne.n	80006a8 <strcmp+0x2a0>
 800069c:	680b      	ldr	r3, [r1, #0]
 800069e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80006a2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80006a6:	e004      	b.n	80006b2 <strcmp+0x2aa>
 80006a8:	f04f 0000 	mov.w	r0, #0
 80006ac:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006b0:	4770      	bx	lr
 80006b2:	ba12      	rev	r2, r2
 80006b4:	ba1b      	rev	r3, r3
 80006b6:	fa82 f44c 	uadd8	r4, r2, ip
 80006ba:	ea82 0403 	eor.w	r4, r2, r3
 80006be:	faa4 f58c 	sel	r5, r4, ip
 80006c2:	fab5 f485 	clz	r4, r5
 80006c6:	fa02 f204 	lsl.w	r2, r2, r4
 80006ca:	fa03 f304 	lsl.w	r3, r3, r4
 80006ce:	ea4f 6012 	mov.w	r0, r2, lsr #24
 80006d2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80006d6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 80006da:	4770      	bx	lr
 80006dc:	0000      	movs	r0, r0
	...

080006e0 <_idle_thread.lto_priv.115>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80006e0:	e7fe      	b.n	80006e0 <_idle_thread.lto_priv.115>
 80006e2:	bf00      	nop
	...

080006f0 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80006f0:	4b0e      	ldr	r3, [pc, #56]	; (800072c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80006f2:	4a0f      	ldr	r2, [pc, #60]	; (8000730 <chTMStopMeasurementX+0x40>)
 80006f4:	685b      	ldr	r3, [r3, #4]
  tmp->n++;
 80006f6:	68c1      	ldr	r1, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80006f8:	b4f0      	push	{r4, r5, r6, r7}
  tmp->last = (now - tmp->last) - offset;
 80006fa:	6887      	ldr	r7, [r0, #8]
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80006fc:	f8d2 6884 	ldr.w	r6, [r2, #2180]	; 0x884
  if (tmp->last > tmp->worst) {
 8000700:	6842      	ldr	r2, [r0, #4]
  tmp->cumulative += (rttime_t)tmp->last;
 8000702:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8000706:	1bdb      	subs	r3, r3, r7
 8000708:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
 800070a:	18e4      	adds	r4, r4, r3
 800070c:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8000710:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 8000712:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 8000714:	bf88      	it	hi
 8000716:	6043      	strhi	r3, [r0, #4]
  tmp->n++;
 8000718:	3101      	adds	r1, #1
  if (tmp->last < tmp->best) {
 800071a:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 800071c:	e9c0 4504 	strd	r4, r5, [r0, #16]
  tmp->n++;
 8000720:	60c1      	str	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8000722:	6083      	str	r3, [r0, #8]
    tmp->best = tmp->last;
 8000724:	bf38      	it	cc
 8000726:	6003      	strcc	r3, [r0, #0]
}
 8000728:	bcf0      	pop	{r4, r5, r6, r7}
 800072a:	4770      	bx	lr
 800072c:	e0001000 	.word	0xe0001000
 8000730:	20001e68 	.word	0x20001e68
	...

08000740 <trace_next.lto_priv.92>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 8000740:	b410      	push	{r4}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8000742:	4a0b      	ldr	r2, [pc, #44]	; (8000770 <trace_next.lto_priv.92+0x30>)
 8000744:	480b      	ldr	r0, [pc, #44]	; (8000774 <trace_next.lto_priv.92+0x34>)
 8000746:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000748:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800074c:	6819      	ldr	r1, [r3, #0]
 800074e:	6a64      	ldr	r4, [r4, #36]	; 0x24
  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8000750:	605c      	str	r4, [r3, #4]
 8000752:	6840      	ldr	r0, [r0, #4]
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8000754:	f360 211f 	bfi	r1, r0, #8, #24
 8000758:	f843 1b10 	str.w	r1, [r3], #16
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 800075c:	f502 6104 	add.w	r1, r2, #2112	; 0x840
 8000760:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 8000762:	bf28      	it	cs
 8000764:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
 8000768:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 800076a:	bc10      	pop	{r4}
 800076c:	4770      	bx	lr
 800076e:	bf00      	nop
 8000770:	20001e68 	.word	0x20001e68
 8000774:	e0001000 	.word	0xe0001000
	...

08000780 <_trace_isr_leave>:
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8000780:	4a0b      	ldr	r2, [pc, #44]	; (80007b0 <_trace_isr_leave+0x30>)
 8000782:	8f13      	ldrh	r3, [r2, #56]	; 0x38
void _trace_isr_leave(const char *isr) {
 8000784:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8000786:	f013 0402 	ands.w	r4, r3, #2
 800078a:	d10f      	bne.n	80007ac <_trace_isr_leave+0x2c>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800078c:	2320      	movs	r3, #32
 800078e:	f383 8811 	msr	BASEPRI, r3
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8000792:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8000794:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8000796:	6090      	str	r0, [r2, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8000798:	2103      	movs	r1, #3
 800079a:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800079e:	f364 03c7 	bfi	r3, r4, #3, #5
 80007a2:	7013      	strb	r3, [r2, #0]
    trace_next();
 80007a4:	f7ff ffcc 	bl	8000740 <trace_next.lto_priv.92>
 80007a8:	f384 8811 	msr	BASEPRI, r4
 80007ac:	bd10      	pop	{r4, pc}
 80007ae:	bf00      	nop
 80007b0:	20001e68 	.word	0x20001e68
	...

080007c0 <_trace_isr_enter>:
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80007c0:	4a0b      	ldr	r2, [pc, #44]	; (80007f0 <_trace_isr_enter+0x30>)
 80007c2:	8f13      	ldrh	r3, [r2, #56]	; 0x38
void _trace_isr_enter(const char *isr) {
 80007c4:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80007c6:	f013 0402 	ands.w	r4, r3, #2
 80007ca:	d10f      	bne.n	80007ec <_trace_isr_enter+0x2c>
 80007cc:	2320      	movs	r3, #32
 80007ce:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80007d2:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 80007d4:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80007d6:	6090      	str	r0, [r2, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80007d8:	2102      	movs	r1, #2
 80007da:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 80007de:	f364 03c7 	bfi	r3, r4, #3, #5
 80007e2:	7013      	strb	r3, [r2, #0]
    trace_next();
 80007e4:	f7ff ffac 	bl	8000740 <trace_next.lto_priv.92>
 80007e8:	f384 8811 	msr	BASEPRI, r4
 80007ec:	bd10      	pop	{r4, pc}
 80007ee:	bf00      	nop
 80007f0:	20001e68 	.word	0x20001e68
	...

08000800 <chSysPolledDelayX>:
 8000800:	4a03      	ldr	r2, [pc, #12]	; (8000810 <chSysPolledDelayX+0x10>)
 8000802:	6851      	ldr	r1, [r2, #4]
 8000804:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 8000806:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8000808:	4298      	cmp	r0, r3
 800080a:	d8fb      	bhi.n	8000804 <chSysPolledDelayX+0x4>
  }
}
 800080c:	4770      	bx	lr
 800080e:	bf00      	nop
 8000810:	e0001000 	.word	0xe0001000
	...

08000820 <chSysHalt>:
void chSysHalt(const char *reason) {
 8000820:	b508      	push	{r3, lr}
 8000822:	4605      	mov	r5, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8000824:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8000826:	4c09      	ldr	r4, [pc, #36]	; (800084c <chSysHalt+0x2c>)
 8000828:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800082a:	f013 0204 	ands.w	r2, r3, #4
 800082e:	d001      	beq.n	8000834 <chSysHalt+0x14>
  ch.dbg.panic_msg = reason;
 8000830:	62e5      	str	r5, [r4, #44]	; 0x2c
 8000832:	e7fe      	b.n	8000832 <chSysHalt+0x12>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8000834:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8000836:	780b      	ldrb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 8000838:	6088      	str	r0, [r1, #8]
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 800083a:	2004      	movs	r0, #4
 800083c:	f360 0302 	bfi	r3, r0, #0, #3
    ch.dbg.trace_buffer.ptr->state         = 0;
 8000840:	f362 03c7 	bfi	r3, r2, #3, #5
 8000844:	700b      	strb	r3, [r1, #0]
    trace_next();
 8000846:	f7ff ff7b 	bl	8000740 <trace_next.lto_priv.92>
 800084a:	e7f1      	b.n	8000830 <chSysHalt+0x10>
 800084c:	20001e68 	.word	0x20001e68

08000850 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8000850:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000852:	4b05      	ldr	r3, [pc, #20]	; (8000868 <chDbgCheckClassS+0x18>)
 8000854:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000856:	b91a      	cbnz	r2, 8000860 <chDbgCheckClassS+0x10>
 8000858:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800085a:	2b00      	cmp	r3, #0
 800085c:	dd00      	ble.n	8000860 <chDbgCheckClassS+0x10>
 800085e:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
 8000860:	4802      	ldr	r0, [pc, #8]	; (800086c <chDbgCheckClassS+0x1c>)
 8000862:	f7ff ffdd 	bl	8000820 <chSysHalt>
 8000866:	bf00      	nop
 8000868:	20001e68 	.word	0x20001e68
 800086c:	0800a788 	.word	0x0800a788

08000870 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000870:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8000872:	4c10      	ldr	r4, [pc, #64]	; (80008b4 <chSchGoSleepS+0x44>)
 8000874:	69a5      	ldr	r5, [r4, #24]
void chSchGoSleepS(tstate_t newstate) {
 8000876:	4606      	mov	r6, r0

  chDbgCheckClassS();
 8000878:	f7ff ffea 	bl	8000850 <chDbgCheckClassS>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800087c:	6823      	ldr	r3, [r4, #0]

  /* New state.*/
  otp->state = newstate;
 800087e:	f885 6020 	strb.w	r6, [r5, #32]

  tqp->next             = tp->queue.next;
 8000882:	681a      	ldr	r2, [r3, #0]
 8000884:	6022      	str	r2, [r4, #0]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000886:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8000888:	6054      	str	r4, [r2, #4]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800088a:	4628      	mov	r0, r5
  currp->state = CH_STATE_CURRENT;
 800088c:	f883 1020 	strb.w	r1, [r3, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000890:	61a3      	str	r3, [r4, #24]
  chSysSwitch(currp, otp);
 8000892:	f009 fa35 	bl	8009d00 <_trace_switch.constprop.78>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000896:	f3ef 8309 	mrs	r3, PSP
 800089a:	69ea      	ldr	r2, [r5, #28]
 800089c:	3b24      	subs	r3, #36	; 0x24
 800089e:	429a      	cmp	r2, r3
 80008a0:	d805      	bhi.n	80008ae <chSchGoSleepS+0x3e>
 80008a2:	4629      	mov	r1, r5
 80008a4:	69a0      	ldr	r0, [r4, #24]
}
 80008a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(currp, otp);
 80008aa:	f7ff bcf3 	b.w	8000294 <_port_switch>
 80008ae:	4802      	ldr	r0, [pc, #8]	; (80008b8 <chSchGoSleepS+0x48>)
 80008b0:	f7ff ffb6 	bl	8000820 <chSysHalt>
 80008b4:	20001e68 	.word	0x20001e68
 80008b8:	0800a790 	.word	0x0800a790
 80008bc:	00000000 	.word	0x00000000

080008c0 <chDbgCheckClassI>:
void chDbgCheckClassI(void) {
 80008c0:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80008c2:	4b05      	ldr	r3, [pc, #20]	; (80008d8 <chDbgCheckClassI+0x18>)
 80008c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80008c6:	2a00      	cmp	r2, #0
 80008c8:	db03      	blt.n	80008d2 <chDbgCheckClassI+0x12>
 80008ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80008cc:	2b00      	cmp	r3, #0
 80008ce:	dd00      	ble.n	80008d2 <chDbgCheckClassI+0x12>
 80008d0:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 80008d2:	4802      	ldr	r0, [pc, #8]	; (80008dc <chDbgCheckClassI+0x1c>)
 80008d4:	f7ff ffa4 	bl	8000820 <chSysHalt>
 80008d8:	20001e68 	.word	0x20001e68
 80008dc:	0800a780 	.word	0x0800a780

080008e0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80008e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80008e2:	4604      	mov	r4, r0
  thread_t *tp;

  chDbgCheckClassI();
 80008e4:	f7ff ffec 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 80008e8:	b134      	cbz	r4, 80008f8 <chThdCreateSuspendedI+0x18>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 80008ea:	6861      	ldr	r1, [r4, #4]
 80008ec:	074b      	lsls	r3, r1, #29
 80008ee:	d103      	bne.n	80008f8 <chThdCreateSuspendedI+0x18>
 80008f0:	68a3      	ldr	r3, [r4, #8]
 80008f2:	f013 0507 	ands.w	r5, r3, #7
 80008f6:	d002      	beq.n	80008fe <chThdCreateSuspendedI+0x1e>
  chDbgCheck(tdp != NULL);
 80008f8:	4823      	ldr	r0, [pc, #140]	; (8000988 <chThdCreateSuspendedI+0xa8>)
 80008fa:	f7ff ff91 	bl	8000820 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 80008fe:	4299      	cmp	r1, r3
 8000900:	d2fa      	bcs.n	80008f8 <chThdCreateSuspendedI+0x18>
 8000902:	1a5a      	subs	r2, r3, r1
 8000904:	2ac7      	cmp	r2, #199	; 0xc7
 8000906:	d9f7      	bls.n	80008f8 <chThdCreateSuspendedI+0x18>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8000908:	68e0      	ldr	r0, [r4, #12]
 800090a:	28ff      	cmp	r0, #255	; 0xff
 800090c:	d8f4      	bhi.n	80008f8 <chThdCreateSuspendedI+0x18>
 800090e:	6927      	ldr	r7, [r4, #16]
 8000910:	2f00      	cmp	r7, #0
 8000912:	d0f1      	beq.n	80008f8 <chThdCreateSuspendedI+0x18>
  REG_INSERT(tp);
 8000914:	4a1d      	ldr	r2, [pc, #116]	; (800098c <chThdCreateSuspendedI+0xac>)
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000916:	f843 1c2c 	str.w	r1, [r3, #-44]
  tp->state     = CH_STATE_WTSTART;
 800091a:	f04f 0e02 	mov.w	lr, #2
  tp->refs      = (trefs_t)1;
 800091e:	2601      	movs	r6, #1
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000920:	6961      	ldr	r1, [r4, #20]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8000922:	6824      	ldr	r4, [r4, #0]
  tp->state     = CH_STATE_WTSTART;
 8000924:	f803 ec28 	strb.w	lr, [r3, #-40]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000928:	f803 5c27 	strb.w	r5, [r3, #-39]
  tp->refs      = (trefs_t)1;
 800092c:	f803 6c26 	strb.w	r6, [r3, #-38]
  REG_INSERT(tp);
 8000930:	f843 2c38 	str.w	r2, [r3, #-56]
 8000934:	6956      	ldr	r6, [r2, #20]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000936:	f8df e058 	ldr.w	lr, [pc, #88]	; 8000990 <chThdCreateSuspendedI+0xb0>
 800093a:	f843 7c6c 	str.w	r7, [r3, #-108]
 800093e:	f843 1c68 	str.w	r1, [r3, #-104]
  tp->name      = name;
 8000942:	f843 4c30 	str.w	r4, [r3, #-48]
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8000946:	f1a3 0148 	sub.w	r1, r3, #72	; 0x48
  queue_init(&tp->msgqueue);
 800094a:	f1a3 041c 	sub.w	r4, r3, #28
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800094e:	f1a3 0c6c 	sub.w	ip, r3, #108	; 0x6c
  list_init(&tp->waiting);
 8000952:	f1a3 0720 	sub.w	r7, r3, #32
  tp->prio      = prio;
 8000956:	f843 0c40 	str.w	r0, [r3, #-64]
  tp->realprio  = prio;
 800095a:	f843 0c0c 	str.w	r0, [r3, #-12]
  tp->mtxlist   = NULL;
 800095e:	f843 5c10 	str.w	r5, [r3, #-16]
  tp->epending  = (eventmask_t)0;
 8000962:	f843 5c14 	str.w	r5, [r3, #-20]
  REG_INSERT(tp);
 8000966:	f843 6c34 	str.w	r6, [r3, #-52]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800096a:	f843 cc3c 	str.w	ip, [r3, #-60]
 800096e:	f843 ec4c 	str.w	lr, [r3, #-76]
}
 8000972:	4608      	mov	r0, r1
  REG_INSERT(tp);
 8000974:	6131      	str	r1, [r6, #16]
 8000976:	6151      	str	r1, [r2, #20]
  tlp->next = (thread_t *)tlp;
 8000978:	f843 7c20 	str.w	r7, [r3, #-32]
  tqp->next = (thread_t *)tqp;
 800097c:	f843 4c1c 	str.w	r4, [r3, #-28]
  tqp->prev = (thread_t *)tqp;
 8000980:	f843 4c18 	str.w	r4, [r3, #-24]
}
 8000984:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000986:	bf00      	nop
 8000988:	0800a62c 	.word	0x0800a62c
 800098c:	20001e68 	.word	0x20001e68
 8000990:	080002a5 	.word	0x080002a5
	...

080009a0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80009a0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 80009a2:	4e1a      	ldr	r6, [pc, #104]	; (8000a0c <chSchDoReschedule+0x6c>)
  thread_t *tp = tqp->next;
 80009a4:	6833      	ldr	r3, [r6, #0]
 80009a6:	69b5      	ldr	r5, [r6, #24]
  tqp->next             = tp->queue.next;
 80009a8:	681c      	ldr	r4, [r3, #0]
 80009aa:	6034      	str	r4, [r6, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80009ac:	2201      	movs	r2, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80009ae:	6066      	str	r6, [r4, #4]
 80009b0:	f883 2020 	strb.w	r2, [r3, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
 80009b4:	61b3      	str	r3, [r6, #24]
  chDbgCheckClassI();
 80009b6:	f7ff ff83 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 80009ba:	b30d      	cbz	r5, 8000a00 <chSchDoReschedule+0x60>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80009bc:	f895 3020 	ldrb.w	r3, [r5, #32]
 80009c0:	b1f3      	cbz	r3, 8000a00 <chSchDoReschedule+0x60>
 80009c2:	2b0f      	cmp	r3, #15
 80009c4:	d01c      	beq.n	8000a00 <chSchDoReschedule+0x60>
  tp->state = CH_STATE_READY;
 80009c6:	2300      	movs	r3, #0
 80009c8:	68aa      	ldr	r2, [r5, #8]
 80009ca:	f885 3020 	strb.w	r3, [r5, #32]
 80009ce:	e000      	b.n	80009d2 <chSchDoReschedule+0x32>
 80009d0:	6824      	ldr	r4, [r4, #0]
  } while (cp->prio > tp->prio);
 80009d2:	68a3      	ldr	r3, [r4, #8]
 80009d4:	4293      	cmp	r3, r2
 80009d6:	d8fb      	bhi.n	80009d0 <chSchDoReschedule+0x30>
  tp->queue.prev             = cp->queue.prev;
 80009d8:	6863      	ldr	r3, [r4, #4]
 80009da:	606b      	str	r3, [r5, #4]
  tp->queue.next             = cp;
 80009dc:	602c      	str	r4, [r5, #0]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80009de:	4628      	mov	r0, r5
  tp->queue.prev->queue.next = tp;
 80009e0:	601d      	str	r5, [r3, #0]
  cp->queue.prev             = tp;
 80009e2:	6065      	str	r5, [r4, #4]
  chSysSwitch(currp, otp);
 80009e4:	f009 f98c 	bl	8009d00 <_trace_switch.constprop.78>
 80009e8:	f3ef 8309 	mrs	r3, PSP
 80009ec:	69ea      	ldr	r2, [r5, #28]
 80009ee:	3b24      	subs	r3, #36	; 0x24
 80009f0:	429a      	cmp	r2, r3
 80009f2:	d808      	bhi.n	8000a06 <chSchDoReschedule+0x66>
 80009f4:	4629      	mov	r1, r5
 80009f6:	69b0      	ldr	r0, [r6, #24]
}
 80009f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(currp, otp);
 80009fc:	f7ff bc4a 	b.w	8000294 <_port_switch>
  chDbgCheck(tp != NULL);
 8000a00:	4803      	ldr	r0, [pc, #12]	; (8000a10 <chSchDoReschedule+0x70>)
 8000a02:	f7ff ff0d 	bl	8000820 <chSysHalt>
  chSysSwitch(currp, otp);
 8000a06:	4803      	ldr	r0, [pc, #12]	; (8000a14 <chSchDoReschedule+0x74>)
 8000a08:	f7ff ff0a 	bl	8000820 <chSysHalt>
 8000a0c:	20001e68 	.word	0x20001e68
 8000a10:	0800a618 	.word	0x0800a618
 8000a14:	0800a790 	.word	0x0800a790
	...

08000a20 <chSchRescheduleS>:
void chSchRescheduleS(void) {
 8000a20:	b508      	push	{r3, lr}
  chDbgCheckClassS();
 8000a22:	f7ff ff15 	bl	8000850 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 8000a26:	f7ff ff4b 	bl	80008c0 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8000a2a:	4b06      	ldr	r3, [pc, #24]	; (8000a44 <chSchRescheduleS+0x24>)
 8000a2c:	681a      	ldr	r2, [r3, #0]
 8000a2e:	699b      	ldr	r3, [r3, #24]
  if (chSchIsRescRequiredI()) {
 8000a30:	6892      	ldr	r2, [r2, #8]
 8000a32:	689b      	ldr	r3, [r3, #8]
 8000a34:	429a      	cmp	r2, r3
 8000a36:	d800      	bhi.n	8000a3a <chSchRescheduleS+0x1a>
 8000a38:	bd08      	pop	{r3, pc}
}
 8000a3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    chSchDoRescheduleAhead();
 8000a3e:	f7ff bfaf 	b.w	80009a0 <chSchDoReschedule>
 8000a42:	bf00      	nop
 8000a44:	20001e68 	.word	0x20001e68
	...

08000a50 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 8000a50:	b510      	push	{r4, lr}
 8000a52:	4604      	mov	r4, r0
  chDbgCheckClassI();
 8000a54:	f7ff ff34 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000a58:	b1a4      	cbz	r4, 8000a84 <chSchReadyI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8000a5a:	f894 3020 	ldrb.w	r3, [r4, #32]
 8000a5e:	b18b      	cbz	r3, 8000a84 <chSchReadyI+0x34>
 8000a60:	2b0f      	cmp	r3, #15
 8000a62:	d00f      	beq.n	8000a84 <chSchReadyI+0x34>
  tp->state = CH_STATE_READY;
 8000a64:	2200      	movs	r2, #0
 8000a66:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000a68:	4b08      	ldr	r3, [pc, #32]	; (8000a8c <chSchReadyI+0x3c>)
  tp->state = CH_STATE_READY;
 8000a6a:	f884 2020 	strb.w	r2, [r4, #32]
    cp = cp->queue.next;
 8000a6e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000a70:	689a      	ldr	r2, [r3, #8]
 8000a72:	428a      	cmp	r2, r1
 8000a74:	d2fb      	bcs.n	8000a6e <chSchReadyI+0x1e>
  tp->queue.prev             = cp->queue.prev;
 8000a76:	685a      	ldr	r2, [r3, #4]
 8000a78:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 8000a7a:	6023      	str	r3, [r4, #0]
}
 8000a7c:	4620      	mov	r0, r4
  tp->queue.prev->queue.next = tp;
 8000a7e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8000a80:	605c      	str	r4, [r3, #4]
}
 8000a82:	bd10      	pop	{r4, pc}
  chDbgCheck(tp != NULL);
 8000a84:	4802      	ldr	r0, [pc, #8]	; (8000a90 <chSchReadyI+0x40>)
 8000a86:	f7ff fecb 	bl	8000820 <chSysHalt>
 8000a8a:	bf00      	nop
 8000a8c:	20001e68 	.word	0x20001e68
 8000a90:	0800a5c8 	.word	0x0800a5c8
	...

08000aa0 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8000aa0:	b538      	push	{r3, r4, r5, lr}
 8000aa2:	4604      	mov	r4, r0
 8000aa4:	460d      	mov	r5, r1

  chDbgCheckClassI();
 8000aa6:	f7ff ff0b 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8000aaa:	b1bc      	cbz	r4, 8000adc <chEvtSignalI+0x3c>

  tp->epending |= events;
 8000aac:	6b61      	ldr	r1, [r4, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000aae:	f894 3020 	ldrb.w	r3, [r4, #32]
  tp->epending |= events;
 8000ab2:	4329      	orrs	r1, r5
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000ab4:	2b0a      	cmp	r3, #10
  tp->epending |= events;
 8000ab6:	6361      	str	r1, [r4, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000ab8:	d00c      	beq.n	8000ad4 <chEvtSignalI+0x34>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000aba:	2b0b      	cmp	r3, #11
 8000abc:	d000      	beq.n	8000ac0 <chEvtSignalI+0x20>
 8000abe:	bd38      	pop	{r3, r4, r5, pc}
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8000ac0:	6a63      	ldr	r3, [r4, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8000ac2:	438b      	bics	r3, r1
 8000ac4:	d1fb      	bne.n	8000abe <chEvtSignalI+0x1e>
    tp->u.rdymsg = MSG_OK;
 8000ac6:	2300      	movs	r3, #0
 8000ac8:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000aca:	4620      	mov	r0, r4
  }
}
 8000acc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    (void) chSchReadyI(tp);
 8000ad0:	f7ff bfbe 	b.w	8000a50 <chSchReadyI>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000ad4:	6a63      	ldr	r3, [r4, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000ad6:	4219      	tst	r1, r3
 8000ad8:	d1f5      	bne.n	8000ac6 <chEvtSignalI+0x26>
 8000ada:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheck(tp != NULL);
 8000adc:	4801      	ldr	r0, [pc, #4]	; (8000ae4 <chEvtSignalI+0x44>)
 8000ade:	f7ff fe9f 	bl	8000820 <chSysHalt>
 8000ae2:	bf00      	nop
 8000ae4:	0800a6d4 	.word	0x0800a6d4
	...

08000af0 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000af0:	b570      	push	{r4, r5, r6, lr}
 8000af2:	4606      	mov	r6, r0
 8000af4:	460d      	mov	r5, r1
  chDbgCheckClassI();
 8000af6:	f7ff fee3 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8000afa:	b18e      	cbz	r6, 8000b20 <chEvtBroadcastFlagsI+0x30>
  elp = esp->next;
 8000afc:	6834      	ldr	r4, [r6, #0]
  while (elp != (event_listener_t *)esp) {
 8000afe:	42a6      	cmp	r6, r4
 8000b00:	d00d      	beq.n	8000b1e <chEvtBroadcastFlagsI+0x2e>
    elp->flags |= flags;
 8000b02:	68e3      	ldr	r3, [r4, #12]
 8000b04:	432b      	orrs	r3, r5
 8000b06:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8000b08:	b115      	cbz	r5, 8000b10 <chEvtBroadcastFlagsI+0x20>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 8000b0a:	6922      	ldr	r2, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 8000b0c:	4213      	tst	r3, r2
 8000b0e:	d003      	beq.n	8000b18 <chEvtBroadcastFlagsI+0x28>
      chEvtSignalI(elp->listener, elp->events);
 8000b10:	68a1      	ldr	r1, [r4, #8]
 8000b12:	6860      	ldr	r0, [r4, #4]
 8000b14:	f7ff ffc4 	bl	8000aa0 <chEvtSignalI>
    elp = elp->next;
 8000b18:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8000b1a:	42a6      	cmp	r6, r4
 8000b1c:	d1f1      	bne.n	8000b02 <chEvtBroadcastFlagsI+0x12>
 8000b1e:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(esp != NULL);
 8000b20:	4801      	ldr	r0, [pc, #4]	; (8000b28 <chEvtBroadcastFlagsI+0x38>)
 8000b22:	f7ff fe7d 	bl	8000820 <chSysHalt>
 8000b26:	bf00      	nop
 8000b28:	0800a660 	.word	0x0800a660
 8000b2c:	00000000 	.word	0x00000000

08000b30 <chMtxUnlockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000b30:	4b1e      	ldr	r3, [pc, #120]	; (8000bac <chMtxUnlockS+0x7c>)
void chMtxUnlockS(mutex_t *mp) {
 8000b32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000b36:	4606      	mov	r6, r0
  thread_t *ctp = currp;
 8000b38:	f8d3 8018 	ldr.w	r8, [r3, #24]
  mutex_t *lmp;

  chDbgCheckClassS();
 8000b3c:	f7ff fe88 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8000b40:	b12e      	cbz	r6, 8000b4e <chMtxUnlockS+0x1e>

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8000b42:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
 8000b46:	b113      	cbz	r3, 8000b4e <chMtxUnlockS+0x1e>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8000b48:	689a      	ldr	r2, [r3, #8]
 8000b4a:	4590      	cmp	r8, r2
 8000b4c:	d002      	beq.n	8000b54 <chMtxUnlockS+0x24>
  chDbgCheck(mp != NULL);
 8000b4e:	4818      	ldr	r0, [pc, #96]	; (8000bb0 <chMtxUnlockS+0x80>)
 8000b50:	f7ff fe66 	bl	8000820 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8000b54:	429e      	cmp	r6, r3
 8000b56:	d1fa      	bne.n	8000b4e <chMtxUnlockS+0x1e>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8000b58:	68f4      	ldr	r4, [r6, #12]
 8000b5a:	f8c8 4038 	str.w	r4, [r8, #56]	; 0x38
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 8000b5e:	f7ff fe77 	bl	8000850 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000b62:	6837      	ldr	r7, [r6, #0]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000b64:	42be      	cmp	r6, r7
 8000b66:	d01c      	beq.n	8000ba2 <chMtxUnlockS+0x72>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8000b68:	f8d8 503c 	ldr.w	r5, [r8, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000b6c:	b15c      	cbz	r4, 8000b86 <chMtxUnlockS+0x56>
 8000b6e:	f7ff fe6f 	bl	8000850 <chDbgCheckClassS>
 8000b72:	6823      	ldr	r3, [r4, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000b74:	429c      	cmp	r4, r3
 8000b76:	d003      	beq.n	8000b80 <chMtxUnlockS+0x50>
 8000b78:	689b      	ldr	r3, [r3, #8]
 8000b7a:	429d      	cmp	r5, r3
 8000b7c:	bf38      	it	cc
 8000b7e:	461d      	movcc	r5, r3
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8000b80:	68e4      	ldr	r4, [r4, #12]
      while (lmp != NULL) {
 8000b82:	2c00      	cmp	r4, #0
 8000b84:	d1f3      	bne.n	8000b6e <chMtxUnlockS+0x3e>
  tqp->next             = tp->queue.next;
 8000b86:	683b      	ldr	r3, [r7, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8000b88:	6bba      	ldr	r2, [r7, #56]	; 0x38
      ctp->prio = newprio;
 8000b8a:	f8c8 5008 	str.w	r5, [r8, #8]
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
 8000b8e:	4638      	mov	r0, r7
 8000b90:	6033      	str	r3, [r6, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000b92:	605e      	str	r6, [r3, #4]
      mp->owner = tp;
 8000b94:	60b7      	str	r7, [r6, #8]
      mp->next = tp->mtxlist;
 8000b96:	60f2      	str	r2, [r6, #12]
      tp->mtxlist = mp;
 8000b98:	63be      	str	r6, [r7, #56]	; 0x38
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8000b9a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      (void) chSchReadyI(tp);
 8000b9e:	f7ff bf57 	b.w	8000a50 <chSchReadyI>
      mp->owner = NULL;
 8000ba2:	2300      	movs	r3, #0
 8000ba4:	60b3      	str	r3, [r6, #8]
 8000ba6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000baa:	bf00      	nop
 8000bac:	20001e68 	.word	0x20001e68
 8000bb0:	0800a6c4 	.word	0x0800a6c4
	...

08000bc0 <chMtxLockS>:
  thread_t *ctp = currp;
 8000bc0:	4b37      	ldr	r3, [pc, #220]	; (8000ca0 <chMtxLockS+0xe0>)
void chMtxLockS(mutex_t *mp) {
 8000bc2:	b570      	push	{r4, r5, r6, lr}
 8000bc4:	4605      	mov	r5, r0
  thread_t *ctp = currp;
 8000bc6:	699c      	ldr	r4, [r3, #24]
  chDbgCheckClassS();
 8000bc8:	f7ff fe42 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8000bcc:	b31d      	cbz	r5, 8000c16 <chMtxLockS+0x56>
  if (mp->owner != NULL) {
 8000bce:	68a8      	ldr	r0, [r5, #8]
 8000bd0:	2800      	cmp	r0, #0
 8000bd2:	d05f      	beq.n	8000c94 <chMtxLockS+0xd4>
      while (tp->prio < ctp->prio) {
 8000bd4:	68a2      	ldr	r2, [r4, #8]
 8000bd6:	6883      	ldr	r3, [r0, #8]
 8000bd8:	429a      	cmp	r2, r3
 8000bda:	d907      	bls.n	8000bec <chMtxLockS+0x2c>
        switch (tp->state) {
 8000bdc:	f890 3020 	ldrb.w	r3, [r0, #32]
        tp->prio = ctp->prio;
 8000be0:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 8000be2:	2b06      	cmp	r3, #6
 8000be4:	d03d      	beq.n	8000c62 <chMtxLockS+0xa2>
 8000be6:	2b07      	cmp	r3, #7
 8000be8:	d027      	beq.n	8000c3a <chMtxLockS+0x7a>
 8000bea:	b1db      	cbz	r3, 8000c24 <chMtxLockS+0x64>
      queue_prio_insert(ctp, &mp->queue);
 8000bec:	462b      	mov	r3, r5
 8000bee:	e003      	b.n	8000bf8 <chMtxLockS+0x38>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000bf0:	6899      	ldr	r1, [r3, #8]
 8000bf2:	68a2      	ldr	r2, [r4, #8]
 8000bf4:	4291      	cmp	r1, r2
 8000bf6:	d302      	bcc.n	8000bfe <chMtxLockS+0x3e>
    cp = cp->queue.next;
 8000bf8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000bfa:	429d      	cmp	r5, r3
 8000bfc:	d1f8      	bne.n	8000bf0 <chMtxLockS+0x30>
  tp->queue.prev             = cp->queue.prev;
 8000bfe:	685a      	ldr	r2, [r3, #4]
 8000c00:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 8000c02:	6023      	str	r3, [r4, #0]
      chSchGoSleepS(CH_STATE_WTMTX);
 8000c04:	2006      	movs	r0, #6
  tp->queue.prev->queue.next = tp;
 8000c06:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8000c08:	605c      	str	r4, [r3, #4]
      ctp->u.wtmtxp = mp;
 8000c0a:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8000c0c:	f7ff fe30 	bl	8000870 <chSchGoSleepS>
      chDbgAssert(mp->owner == ctp, "not owner");
 8000c10:	68ab      	ldr	r3, [r5, #8]
 8000c12:	429c      	cmp	r4, r3
 8000c14:	d002      	beq.n	8000c1c <chMtxLockS+0x5c>
  chDbgCheck(mp != NULL);
 8000c16:	4823      	ldr	r0, [pc, #140]	; (8000ca4 <chMtxLockS+0xe4>)
 8000c18:	f7ff fe02 	bl	8000820 <chSysHalt>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8000c1c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000c1e:	429d      	cmp	r5, r3
 8000c20:	d1f9      	bne.n	8000c16 <chMtxLockS+0x56>
 8000c22:	bd70      	pop	{r4, r5, r6, pc}
  tp->queue.prev->queue.next = tp->queue.next;
 8000c24:	e890 000c 	ldmia.w	r0, {r2, r3}
          tp->state = CH_STATE_CURRENT;
 8000c28:	2101      	movs	r1, #1
 8000c2a:	f880 1020 	strb.w	r1, [r0, #32]
 8000c2e:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000c30:	6802      	ldr	r2, [r0, #0]
 8000c32:	6053      	str	r3, [r2, #4]
          (void) chSchReadyI(queue_dequeue(tp));
 8000c34:	f7ff ff0c 	bl	8000a50 <chSchReadyI>
 8000c38:	e7d8      	b.n	8000bec <chMtxLockS+0x2c>
  tp->queue.prev->queue.next = tp->queue.next;
 8000c3a:	e890 000a 	ldmia.w	r0, {r1, r3}
 8000c3e:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000c40:	6801      	ldr	r1, [r0, #0]
 8000c42:	604b      	str	r3, [r1, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000c44:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8000c46:	4633      	mov	r3, r6
 8000c48:	e002      	b.n	8000c50 <chMtxLockS+0x90>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000c4a:	6899      	ldr	r1, [r3, #8]
 8000c4c:	428a      	cmp	r2, r1
 8000c4e:	d802      	bhi.n	8000c56 <chMtxLockS+0x96>
    cp = cp->queue.next;
 8000c50:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000c52:	429e      	cmp	r6, r3
 8000c54:	d1f9      	bne.n	8000c4a <chMtxLockS+0x8a>
  tp->queue.prev             = cp->queue.prev;
 8000c56:	685a      	ldr	r2, [r3, #4]
 8000c58:	6042      	str	r2, [r0, #4]
  tp->queue.next             = cp;
 8000c5a:	6003      	str	r3, [r0, #0]
  tp->queue.prev->queue.next = tp;
 8000c5c:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000c5e:	6058      	str	r0, [r3, #4]
 8000c60:	e7c4      	b.n	8000bec <chMtxLockS+0x2c>
  tp->queue.prev->queue.next = tp->queue.next;
 8000c62:	e890 000a 	ldmia.w	r0, {r1, r3}
 8000c66:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000c68:	6801      	ldr	r1, [r0, #0]
 8000c6a:	604b      	str	r3, [r1, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000c6c:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8000c6e:	4633      	mov	r3, r6
 8000c70:	e002      	b.n	8000c78 <chMtxLockS+0xb8>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000c72:	6899      	ldr	r1, [r3, #8]
 8000c74:	428a      	cmp	r2, r1
 8000c76:	d802      	bhi.n	8000c7e <chMtxLockS+0xbe>
    cp = cp->queue.next;
 8000c78:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000c7a:	429e      	cmp	r6, r3
 8000c7c:	d1f9      	bne.n	8000c72 <chMtxLockS+0xb2>
  tp->queue.prev             = cp->queue.prev;
 8000c7e:	685a      	ldr	r2, [r3, #4]
 8000c80:	6042      	str	r2, [r0, #4]
  tp->queue.next             = cp;
 8000c82:	6003      	str	r3, [r0, #0]
  tp->queue.prev->queue.next = tp;
 8000c84:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000c86:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8000c88:	68b0      	ldr	r0, [r6, #8]
      while (tp->prio < ctp->prio) {
 8000c8a:	68a2      	ldr	r2, [r4, #8]
 8000c8c:	6883      	ldr	r3, [r0, #8]
 8000c8e:	4293      	cmp	r3, r2
 8000c90:	d3a4      	bcc.n	8000bdc <chMtxLockS+0x1c>
 8000c92:	e7ab      	b.n	8000bec <chMtxLockS+0x2c>
    mp->next = ctp->mtxlist;
 8000c94:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000c96:	60eb      	str	r3, [r5, #12]
    mp->owner = ctp;
 8000c98:	60ac      	str	r4, [r5, #8]
    ctp->mtxlist = mp;
 8000c9a:	63a5      	str	r5, [r4, #56]	; 0x38
 8000c9c:	bd70      	pop	{r4, r5, r6, pc}
 8000c9e:	bf00      	nop
 8000ca0:	20001e68 	.word	0x20001e68
 8000ca4:	0800a5e0 	.word	0x0800a5e0
	...

08000cb0 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8000cb0:	b510      	push	{r4, lr}
 8000cb2:	4604      	mov	r4, r0

  chDbgCheckClassI();
 8000cb4:	f7ff fe04 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
 8000cb8:	b12c      	cbz	r4, 8000cc6 <chSemSignalI+0x16>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8000cba:	68a3      	ldr	r3, [r4, #8]
 8000cbc:	6822      	ldr	r2, [r4, #0]
 8000cbe:	2b00      	cmp	r3, #0
 8000cc0:	db04      	blt.n	8000ccc <chSemSignalI+0x1c>
 8000cc2:	4294      	cmp	r4, r2
 8000cc4:	d004      	beq.n	8000cd0 <chSemSignalI+0x20>
  chDbgCheck(sp != NULL);
 8000cc6:	480a      	ldr	r0, [pc, #40]	; (8000cf0 <chSemSignalI+0x40>)
 8000cc8:	f7ff fdaa 	bl	8000820 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8000ccc:	4294      	cmp	r4, r2
 8000cce:	d0fa      	beq.n	8000cc6 <chSemSignalI+0x16>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8000cd0:	3301      	adds	r3, #1
 8000cd2:	2b00      	cmp	r3, #0
 8000cd4:	60a3      	str	r3, [r4, #8]
 8000cd6:	dd00      	ble.n	8000cda <chSemSignalI+0x2a>
 8000cd8:	bd10      	pop	{r4, pc}
  tqp->next             = tp->queue.next;
 8000cda:	6813      	ldr	r3, [r2, #0]
 8000cdc:	6023      	str	r3, [r4, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 8000cde:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8000ce0:	605c      	str	r4, [r3, #4]
 8000ce2:	6251      	str	r1, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000ce4:	4610      	mov	r0, r2
  }
}
 8000ce6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    (void) chSchReadyI(tp);
 8000cea:	f7ff beb1 	b.w	8000a50 <chSchReadyI>
 8000cee:	bf00      	nop
 8000cf0:	0800a6a4 	.word	0x0800a6a4
	...

08000d00 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8000d00:	b508      	push	{r3, lr}
  thread_t *tp = currp;
 8000d02:	4b11      	ldr	r3, [pc, #68]	; (8000d48 <chThdExitS+0x48>)
 8000d04:	699c      	ldr	r4, [r3, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 8000d06:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8000d08:	6260      	str	r0, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8000d0a:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8000d0e:	429d      	cmp	r5, r3
 8000d10:	d007      	beq.n	8000d22 <chThdExitS+0x22>
  tlp->next = tp->queue.next;
 8000d12:	681a      	ldr	r2, [r3, #0]
 8000d14:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8000d16:	4618      	mov	r0, r3
 8000d18:	f7ff fe9a 	bl	8000a50 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8000d1c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8000d1e:	42ab      	cmp	r3, r5
 8000d20:	d1f7      	bne.n	8000d12 <chThdExitS+0x12>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8000d22:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8000d26:	b943      	cbnz	r3, 8000d3a <chThdExitS+0x3a>
 8000d28:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8000d2c:	079b      	lsls	r3, r3, #30
 8000d2e:	d104      	bne.n	8000d3a <chThdExitS+0x3a>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 8000d30:	6963      	ldr	r3, [r4, #20]
 8000d32:	6922      	ldr	r2, [r4, #16]
 8000d34:	611a      	str	r2, [r3, #16]
 8000d36:	6922      	ldr	r2, [r4, #16]
 8000d38:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8000d3a:	200f      	movs	r0, #15
 8000d3c:	f7ff fd98 	bl	8000870 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8000d40:	4802      	ldr	r0, [pc, #8]	; (8000d4c <chThdExitS+0x4c>)
 8000d42:	f7ff fd6d 	bl	8000820 <chSysHalt>
 8000d46:	bf00      	nop
 8000d48:	20001e68 	.word	0x20001e68
 8000d4c:	0800a6f4 	.word	0x0800a6f4

08000d50 <chSchWakeupS>:
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000d50:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8000d52:	4d19      	ldr	r5, [pc, #100]	; (8000db8 <chSchWakeupS+0x68>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000d54:	4604      	mov	r4, r0
 8000d56:	460e      	mov	r6, r1
  chDbgCheckClassS();
 8000d58:	f7ff fd7a 	bl	8000850 <chDbgCheckClassS>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000d5c:	682b      	ldr	r3, [r5, #0]
  thread_t *otp = currp;
 8000d5e:	69a8      	ldr	r0, [r5, #24]
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000d60:	42ab      	cmp	r3, r5
 8000d62:	d027      	beq.n	8000db4 <chSchWakeupS+0x64>
 8000d64:	689a      	ldr	r2, [r3, #8]
 8000d66:	6883      	ldr	r3, [r0, #8]
 8000d68:	4293      	cmp	r3, r2
 8000d6a:	d31d      	bcc.n	8000da8 <chSchWakeupS+0x58>
  if (ntp->prio <= otp->prio) {
 8000d6c:	68a2      	ldr	r2, [r4, #8]
  ntp->u.rdymsg = msg;
 8000d6e:	6266      	str	r6, [r4, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 8000d70:	4293      	cmp	r3, r2
 8000d72:	d214      	bcs.n	8000d9e <chSchWakeupS+0x4e>
    otp = chSchReadyI(otp);
 8000d74:	f7ff fe6c 	bl	8000a50 <chSchReadyI>
    ntp->state = CH_STATE_CURRENT;
 8000d78:	2301      	movs	r3, #1
 8000d7a:	f884 3020 	strb.w	r3, [r4, #32]
    otp = chSchReadyI(otp);
 8000d7e:	4606      	mov	r6, r0
    currp = ntp;
 8000d80:	61ac      	str	r4, [r5, #24]
    chSysSwitch(ntp, otp);
 8000d82:	f008 ffbd 	bl	8009d00 <_trace_switch.constprop.78>
 8000d86:	f3ef 8309 	mrs	r3, PSP
 8000d8a:	69f2      	ldr	r2, [r6, #28]
 8000d8c:	3b24      	subs	r3, #36	; 0x24
 8000d8e:	429a      	cmp	r2, r3
 8000d90:	d80d      	bhi.n	8000dae <chSchWakeupS+0x5e>
 8000d92:	4631      	mov	r1, r6
 8000d94:	4620      	mov	r0, r4
}
 8000d96:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
 8000d9a:	f7ff ba7b 	b.w	8000294 <_port_switch>
    (void) chSchReadyI(ntp);
 8000d9e:	4620      	mov	r0, r4
}
 8000da0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    (void) chSchReadyI(ntp);
 8000da4:	f7ff be54 	b.w	8000a50 <chSchReadyI>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000da8:	4804      	ldr	r0, [pc, #16]	; (8000dbc <chSchWakeupS+0x6c>)
 8000daa:	f7ff fd39 	bl	8000820 <chSysHalt>
    chSysSwitch(ntp, otp);
 8000dae:	4804      	ldr	r0, [pc, #16]	; (8000dc0 <chSchWakeupS+0x70>)
 8000db0:	f7ff fd36 	bl	8000820 <chSysHalt>
 8000db4:	6883      	ldr	r3, [r0, #8]
 8000db6:	e7d9      	b.n	8000d6c <chSchWakeupS+0x1c>
 8000db8:	20001e68 	.word	0x20001e68
 8000dbc:	0800a6b4 	.word	0x0800a6b4
 8000dc0:	0800a790 	.word	0x0800a790
	...

08000dd0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000dd0:	b510      	push	{r4, lr}
 8000dd2:	4604      	mov	r4, r0

  chDbgCheckClassI();
 8000dd4:	f7ff fd74 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8000dd8:	2c00      	cmp	r4, #0
 8000dda:	d033      	beq.n	8000e44 <chVTDoResetI+0x74>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 8000ddc:	68e3      	ldr	r3, [r4, #12]
 8000dde:	2b00      	cmp	r3, #0
 8000de0:	d030      	beq.n	8000e44 <chVTDoResetI+0x74>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000de2:	4b1c      	ldr	r3, [pc, #112]	; (8000e54 <chVTDoResetI+0x84>)
 8000de4:	69da      	ldr	r2, [r3, #28]
 8000de6:	4294      	cmp	r4, r2
 8000de8:	d00f      	beq.n	8000e0a <chVTDoResetI+0x3a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000dea:	6861      	ldr	r1, [r4, #4]
 8000dec:	6822      	ldr	r2, [r4, #0]
 8000dee:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8000df0:	6822      	ldr	r2, [r4, #0]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000df2:	331c      	adds	r3, #28
    vtp->func = NULL;
 8000df4:	2000      	movs	r0, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000df6:	429a      	cmp	r2, r3
    vtp->next->prev = vtp->prev;
 8000df8:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 8000dfa:	60e0      	str	r0, [r4, #12]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000dfc:	d004      	beq.n	8000e08 <chVTDoResetI+0x38>
      vtp->next->delta += vtp->delta;
 8000dfe:	68a1      	ldr	r1, [r4, #8]
 8000e00:	6893      	ldr	r3, [r2, #8]
 8000e02:	440b      	add	r3, r1
 8000e04:	6093      	str	r3, [r2, #8]
 8000e06:	bd10      	pop	{r4, pc}
 8000e08:	bd10      	pop	{r4, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8000e0a:	4619      	mov	r1, r3
 8000e0c:	6822      	ldr	r2, [r4, #0]
 8000e0e:	f841 2f1c 	str.w	r2, [r1, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8000e12:	2000      	movs	r0, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000e14:	428a      	cmp	r2, r1
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000e16:	6051      	str	r1, [r2, #4]
  vtp->func = NULL;
 8000e18:	60e0      	str	r0, [r4, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000e1a:	d016      	beq.n	8000e4a <chVTDoResetI+0x7a>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000e1c:	6890      	ldr	r0, [r2, #8]
 8000e1e:	68a4      	ldr	r4, [r4, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8000e20:	6a99      	ldr	r1, [r3, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8000e22:	4404      	add	r4, r0
 8000e24:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000e28:	6094      	str	r4, [r2, #8]
 8000e2a:	6a40      	ldr	r0, [r0, #36]	; 0x24
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8000e2c:	1a42      	subs	r2, r0, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8000e2e:	4294      	cmp	r4, r2
 8000e30:	d9ea      	bls.n	8000e08 <chVTDoResetI+0x38>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8000e32:	1aa3      	subs	r3, r4, r2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000e34:	2b02      	cmp	r3, #2
 8000e36:	bf2c      	ite	cs
 8000e38:	18c0      	addcs	r0, r0, r3
 8000e3a:	3002      	addcc	r0, #2
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000e3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8000e40:	f003 bc46 	b.w	80046d0 <stSetAlarm>
  chDbgCheck(vtp != NULL);
 8000e44:	4804      	ldr	r0, [pc, #16]	; (8000e58 <chVTDoResetI+0x88>)
 8000e46:	f7ff fceb 	bl	8000820 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000e4a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000e4e:	60d8      	str	r0, [r3, #12]
 8000e50:	bd10      	pop	{r4, pc}
 8000e52:	bf00      	nop
 8000e54:	20001e68 	.word	0x20001e68
 8000e58:	0800a644 	.word	0x0800a644
 8000e5c:	00000000 	.word	0x00000000

08000e60 <chVTDoSetI>:
                vtfunc_t vtfunc, void *par) {
 8000e60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000e64:	4606      	mov	r6, r0
 8000e66:	460c      	mov	r4, r1
 8000e68:	4617      	mov	r7, r2
 8000e6a:	461d      	mov	r5, r3
  chDbgCheckClassI();
 8000e6c:	f7ff fd28 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8000e70:	b37e      	cbz	r6, 8000ed2 <chVTDoSetI+0x72>
 8000e72:	b377      	cbz	r7, 8000ed2 <chVTDoSetI+0x72>
 8000e74:	b36c      	cbz	r4, 8000ed2 <chVTDoSetI+0x72>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000e76:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8000f20 <chVTDoSetI+0xc0>
  vtp->par = par;
 8000e7a:	6135      	str	r5, [r6, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000e7c:	4643      	mov	r3, r8
 8000e7e:	2c02      	cmp	r4, #2
 8000e80:	f853 5f1c 	ldr.w	r5, [r3, #28]!
  vtp->func = vtfunc;
 8000e84:	60f7      	str	r7, [r6, #12]
  return (systime_t)STM32_ST_TIM->CNT;
 8000e86:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000e8a:	4621      	mov	r1, r4
 8000e8c:	bf38      	it	cc
 8000e8e:	2102      	movcc	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000e90:	429d      	cmp	r5, r3
 8000e92:	6a54      	ldr	r4, [r2, #36]	; 0x24
 8000e94:	d029      	beq.n	8000eea <chVTDoSetI+0x8a>
    delta = now - ch.vtlist.lasttime + delay;
 8000e96:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
      delta -= p->delta;
 8000e9a:	68ab      	ldr	r3, [r5, #8]
    delta = now - ch.vtlist.lasttime + delay;
 8000e9c:	1a24      	subs	r4, r4, r0
    if (delta < now - ch.vtlist.lasttime) {
 8000e9e:	1864      	adds	r4, r4, r1
 8000ea0:	d21a      	bcs.n	8000ed8 <chVTDoSetI+0x78>
    else if (delta < p->delta) {
 8000ea2:	429c      	cmp	r4, r3
 8000ea4:	d31c      	bcc.n	8000ee0 <chVTDoSetI+0x80>
  while (p->delta < delta) {
 8000ea6:	429c      	cmp	r4, r3
 8000ea8:	d904      	bls.n	8000eb4 <chVTDoSetI+0x54>
    p = p->next;
 8000eaa:	682d      	ldr	r5, [r5, #0]
    delta -= p->delta;
 8000eac:	1ae4      	subs	r4, r4, r3
  while (p->delta < delta) {
 8000eae:	68ab      	ldr	r3, [r5, #8]
 8000eb0:	42a3      	cmp	r3, r4
 8000eb2:	d3fa      	bcc.n	8000eaa <chVTDoSetI+0x4a>
  vtp->prev = vtp->next->prev;
 8000eb4:	686b      	ldr	r3, [r5, #4]
 8000eb6:	6073      	str	r3, [r6, #4]
  vtp->next = p;
 8000eb8:	6035      	str	r5, [r6, #0]
  vtp->prev->next = vtp;
 8000eba:	601e      	str	r6, [r3, #0]
  p->prev = vtp;
 8000ebc:	606e      	str	r6, [r5, #4]
  vtp->delta = delta
 8000ebe:	60b4      	str	r4, [r6, #8]
  p->delta -= delta;
 8000ec0:	68ab      	ldr	r3, [r5, #8]
  ch.vtlist.delta = (systime_t)-1;
 8000ec2:	f04f 32ff 	mov.w	r2, #4294967295
  p->delta -= delta;
 8000ec6:	1b1c      	subs	r4, r3, r4
 8000ec8:	60ac      	str	r4, [r5, #8]
  ch.vtlist.delta = (systime_t)-1;
 8000eca:	f8c8 2024 	str.w	r2, [r8, #36]	; 0x24
 8000ece:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8000ed2:	4811      	ldr	r0, [pc, #68]	; (8000f18 <chVTDoSetI+0xb8>)
 8000ed4:	f7ff fca4 	bl	8000820 <chSysHalt>
      p = p->next;
 8000ed8:	682d      	ldr	r5, [r5, #0]
      delta -= p->delta;
 8000eda:	1ae4      	subs	r4, r4, r3
 8000edc:	68ab      	ldr	r3, [r5, #8]
 8000ede:	e7e2      	b.n	8000ea6 <chVTDoSetI+0x46>
 8000ee0:	4420      	add	r0, r4
 8000ee2:	f003 fbf5 	bl	80046d0 <stSetAlarm>
 8000ee6:	68ab      	ldr	r3, [r5, #8]
 8000ee8:	e7dd      	b.n	8000ea6 <chVTDoSetI+0x46>
      ch.vtlist.lasttime = now;
 8000eea:	f8c8 4028 	str.w	r4, [r8, #40]	; 0x28
      ch.vtlist.next = vtp;
 8000eee:	f8c8 601c 	str.w	r6, [r8, #28]
      ch.vtlist.prev = vtp;
 8000ef2:	f8c8 6020 	str.w	r6, [r8, #32]
      vtp->delta = delay;
 8000ef6:	60b1      	str	r1, [r6, #8]
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000ef8:	68d3      	ldr	r3, [r2, #12]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8000efa:	6035      	str	r5, [r6, #0]
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000efc:	f013 0302 	ands.w	r3, r3, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8000f00:	6075      	str	r5, [r6, #4]
 8000f02:	d106      	bne.n	8000f12 <chVTDoSetI+0xb2>
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8000f04:	440c      	add	r4, r1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000f06:	2102      	movs	r1, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000f08:	6354      	str	r4, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000f0a:	6113      	str	r3, [r2, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000f0c:	60d1      	str	r1, [r2, #12]
 8000f0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000f12:	4802      	ldr	r0, [pc, #8]	; (8000f1c <chVTDoSetI+0xbc>)
 8000f14:	f7ff fc84 	bl	8000820 <chSysHalt>
 8000f18:	0800a5d4 	.word	0x0800a5d4
 8000f1c:	0800a730 	.word	0x0800a730
 8000f20:	20001e68 	.word	0x20001e68
	...

08000f30 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000f30:	b570      	push	{r4, r5, r6, lr}
 8000f32:	460c      	mov	r4, r1
 8000f34:	b086      	sub	sp, #24
 8000f36:	4606      	mov	r6, r0
  chDbgCheckClassS();
 8000f38:	f7ff fc8a 	bl	8000850 <chDbgCheckClassS>
  if (TIME_INFINITE != time) {
 8000f3c:	1c63      	adds	r3, r4, #1
 8000f3e:	d014      	beq.n	8000f6a <chSchGoSleepTimeoutS+0x3a>
    chVTDoSetI(&vt, time, wakeup, currp);
 8000f40:	4d0e      	ldr	r5, [pc, #56]	; (8000f7c <chSchGoSleepTimeoutS+0x4c>)
 8000f42:	4a0f      	ldr	r2, [pc, #60]	; (8000f80 <chSchGoSleepTimeoutS+0x50>)
 8000f44:	69ab      	ldr	r3, [r5, #24]
 8000f46:	4621      	mov	r1, r4
 8000f48:	a801      	add	r0, sp, #4
 8000f4a:	f7ff ff89 	bl	8000e60 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000f4e:	4630      	mov	r0, r6
 8000f50:	f7ff fc8e 	bl	8000870 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8000f54:	f7ff fcb4 	bl	80008c0 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 8000f58:	9b04      	ldr	r3, [sp, #16]
 8000f5a:	b113      	cbz	r3, 8000f62 <chSchGoSleepTimeoutS+0x32>
      chVTDoResetI(&vt);
 8000f5c:	a801      	add	r0, sp, #4
 8000f5e:	f7ff ff37 	bl	8000dd0 <chVTDoResetI>
  return currp->u.rdymsg;
 8000f62:	69ab      	ldr	r3, [r5, #24]
}
 8000f64:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000f66:	b006      	add	sp, #24
 8000f68:	bd70      	pop	{r4, r5, r6, pc}
 8000f6a:	4d04      	ldr	r5, [pc, #16]	; (8000f7c <chSchGoSleepTimeoutS+0x4c>)
    chSchGoSleepS(newstate);
 8000f6c:	4630      	mov	r0, r6
 8000f6e:	f7ff fc7f 	bl	8000870 <chSchGoSleepS>
  return currp->u.rdymsg;
 8000f72:	69ab      	ldr	r3, [r5, #24]
}
 8000f74:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000f76:	b006      	add	sp, #24
 8000f78:	bd70      	pop	{r4, r5, r6, pc}
 8000f7a:	bf00      	nop
 8000f7c:	20001e68 	.word	0x20001e68
 8000f80:	080011a1 	.word	0x080011a1
	...

08000f90 <chSemWaitTimeoutS>:
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8000f90:	b538      	push	{r3, r4, r5, lr}
 8000f92:	4604      	mov	r4, r0
 8000f94:	460d      	mov	r5, r1
  chDbgCheckClassS();
 8000f96:	f7ff fc5b 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 8000f9a:	b12c      	cbz	r4, 8000fa8 <chSemWaitTimeoutS+0x18>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8000f9c:	68a3      	ldr	r3, [r4, #8]
 8000f9e:	6822      	ldr	r2, [r4, #0]
 8000fa0:	2b00      	cmp	r3, #0
 8000fa2:	db04      	blt.n	8000fae <chSemWaitTimeoutS+0x1e>
 8000fa4:	4294      	cmp	r4, r2
 8000fa6:	d004      	beq.n	8000fb2 <chSemWaitTimeoutS+0x22>
  chDbgCheck(sp != NULL);
 8000fa8:	480e      	ldr	r0, [pc, #56]	; (8000fe4 <chSemWaitTimeoutS+0x54>)
 8000faa:	f7ff fc39 	bl	8000820 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8000fae:	4294      	cmp	r4, r2
 8000fb0:	d0fa      	beq.n	8000fa8 <chSemWaitTimeoutS+0x18>
  if (--sp->cnt < (cnt_t)0) {
 8000fb2:	1e5a      	subs	r2, r3, #1
 8000fb4:	2a00      	cmp	r2, #0
 8000fb6:	60a2      	str	r2, [r4, #8]
 8000fb8:	db01      	blt.n	8000fbe <chSemWaitTimeoutS+0x2e>
  return MSG_OK;
 8000fba:	2000      	movs	r0, #0
}
 8000fbc:	bd38      	pop	{r3, r4, r5, pc}
    if (TIME_IMMEDIATE == time) {
 8000fbe:	b16d      	cbz	r5, 8000fdc <chSemWaitTimeoutS+0x4c>
    currp->u.wtsemp = sp;
 8000fc0:	4b09      	ldr	r3, [pc, #36]	; (8000fe8 <chSemWaitTimeoutS+0x58>)
 8000fc2:	699b      	ldr	r3, [r3, #24]
 8000fc4:	625c      	str	r4, [r3, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
 8000fc6:	6862      	ldr	r2, [r4, #4]
 8000fc8:	605a      	str	r2, [r3, #4]
  tp->queue.next             = (thread_t *)tqp;
 8000fca:	601c      	str	r4, [r3, #0]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8000fcc:	4629      	mov	r1, r5
  tp->queue.prev->queue.next = tp;
 8000fce:	6013      	str	r3, [r2, #0]
 8000fd0:	2005      	movs	r0, #5
  tqp->prev                  = tp;
 8000fd2:	6063      	str	r3, [r4, #4]
}
 8000fd4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8000fd8:	f7ff bfaa 	b.w	8000f30 <chSchGoSleepTimeoutS>
      sp->cnt++;
 8000fdc:	60a3      	str	r3, [r4, #8]
      return MSG_TIMEOUT;
 8000fde:	f04f 30ff 	mov.w	r0, #4294967295
 8000fe2:	bd38      	pop	{r3, r4, r5, pc}
 8000fe4:	0800a684 	.word	0x0800a684
 8000fe8:	20001e68 	.word	0x20001e68
 8000fec:	00000000 	.word	0x00000000

08000ff0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000ff0:	b161      	cbz	r1, 800100c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000ff2:	4b08      	ldr	r3, [pc, #32]	; (8001014 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000ff4:	b410      	push	{r4}
 8000ff6:	4602      	mov	r2, r0
  tp->queue.prev             = tqp->prev;
 8000ff8:	6844      	ldr	r4, [r0, #4]
  queue_insert(currp, tqp);
 8000ffa:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000ffc:	2004      	movs	r0, #4
 8000ffe:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 8001002:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8001004:	6053      	str	r3, [r2, #4]
}
 8001006:	bc10      	pop	{r4}
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001008:	f7ff bf92 	b.w	8000f30 <chSchGoSleepTimeoutS>
}
 800100c:	f04f 30ff 	mov.w	r0, #4294967295
 8001010:	4770      	bx	lr
 8001012:	bf00      	nop
 8001014:	20001e68 	.word	0x20001e68
	...

08001020 <chSysIntegrityCheckI>:
bool chSysIntegrityCheckI(unsigned testmask) {
 8001020:	b510      	push	{r4, lr}
 8001022:	4604      	mov	r4, r0
  chDbgCheckClassI();
 8001024:	f7ff fc4c 	bl	80008c0 <chDbgCheckClassI>
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8001028:	07e2      	lsls	r2, r4, #31
 800102a:	d513      	bpl.n	8001054 <chSysIntegrityCheckI+0x34>
    tp = ch.rlist.queue.next;
 800102c:	4a2b      	ldr	r2, [pc, #172]	; (80010dc <chSysIntegrityCheckI+0xbc>)
 800102e:	6811      	ldr	r1, [r2, #0]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001030:	4291      	cmp	r1, r2
 8001032:	d047      	beq.n	80010c4 <chSysIntegrityCheckI+0xa4>
 8001034:	2300      	movs	r3, #0
      tp = tp->queue.next;
 8001036:	6809      	ldr	r1, [r1, #0]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001038:	4291      	cmp	r1, r2
      n++;
 800103a:	f103 0301 	add.w	r3, r3, #1
    while (tp != (thread_t *)&ch.rlist.queue) {
 800103e:	d1fa      	bne.n	8001036 <chSysIntegrityCheckI+0x16>
    tp = ch.rlist.queue.prev;
 8001040:	6848      	ldr	r0, [r1, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001042:	4288      	cmp	r0, r1
 8001044:	d03c      	beq.n	80010c0 <chSysIntegrityCheckI+0xa0>
      tp = tp->queue.prev;
 8001046:	6840      	ldr	r0, [r0, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001048:	4290      	cmp	r0, r2
      n--;
 800104a:	f103 33ff 	add.w	r3, r3, #4294967295
    while (tp != (thread_t *)&ch.rlist.queue) {
 800104e:	d1fa      	bne.n	8001046 <chSysIntegrityCheckI+0x26>
    if (n != (cnt_t)0) {
 8001050:	2b00      	cmp	r3, #0
 8001052:	d135      	bne.n	80010c0 <chSysIntegrityCheckI+0xa0>
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 8001054:	07a3      	lsls	r3, r4, #30
 8001056:	d514      	bpl.n	8001082 <chSysIntegrityCheckI+0x62>
    vtp = ch.vtlist.next;
 8001058:	4a20      	ldr	r2, [pc, #128]	; (80010dc <chSysIntegrityCheckI+0xbc>)
 800105a:	4610      	mov	r0, r2
 800105c:	f850 1f1c 	ldr.w	r1, [r0, #28]!
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001060:	4281      	cmp	r1, r0
 8001062:	d035      	beq.n	80010d0 <chSysIntegrityCheckI+0xb0>
 8001064:	2300      	movs	r3, #0
      vtp = vtp->next;
 8001066:	6809      	ldr	r1, [r1, #0]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001068:	4281      	cmp	r1, r0
      n++;
 800106a:	f103 0301 	add.w	r3, r3, #1
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800106e:	d1fa      	bne.n	8001066 <chSysIntegrityCheckI+0x46>
    vtp = ch.vtlist.prev;
 8001070:	6a12      	ldr	r2, [r2, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001072:	428a      	cmp	r2, r1
 8001074:	d024      	beq.n	80010c0 <chSysIntegrityCheckI+0xa0>
      vtp = vtp->prev;
 8001076:	6852      	ldr	r2, [r2, #4]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001078:	4282      	cmp	r2, r0
      n--;
 800107a:	f103 33ff 	add.w	r3, r3, #4294967295
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800107e:	d1fa      	bne.n	8001076 <chSysIntegrityCheckI+0x56>
    if (n != (cnt_t)0) {
 8001080:	b9f3      	cbnz	r3, 80010c0 <chSysIntegrityCheckI+0xa0>
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 8001082:	f014 0004 	ands.w	r0, r4, #4
 8001086:	d01a      	beq.n	80010be <chSysIntegrityCheckI+0x9e>
    tp = ch.rlist.newer;
 8001088:	4a14      	ldr	r2, [pc, #80]	; (80010dc <chSysIntegrityCheckI+0xbc>)
 800108a:	6913      	ldr	r3, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
 800108c:	4293      	cmp	r3, r2
 800108e:	d011      	beq.n	80010b4 <chSysIntegrityCheckI+0x94>
 8001090:	2000      	movs	r0, #0
      tp = tp->newer;
 8001092:	691b      	ldr	r3, [r3, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8001094:	4293      	cmp	r3, r2
      n++;
 8001096:	f100 0001 	add.w	r0, r0, #1
    while (tp != (thread_t *)&ch.rlist) {
 800109a:	d1fa      	bne.n	8001092 <chSysIntegrityCheckI+0x72>
    tp = ch.rlist.older;
 800109c:	6959      	ldr	r1, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 800109e:	4299      	cmp	r1, r3
 80010a0:	d00e      	beq.n	80010c0 <chSysIntegrityCheckI+0xa0>
      tp = tp->older;
 80010a2:	6949      	ldr	r1, [r1, #20]
    while (tp != (thread_t *)&ch.rlist) {
 80010a4:	4291      	cmp	r1, r2
      n--;
 80010a6:	f100 30ff 	add.w	r0, r0, #4294967295
    while (tp != (thread_t *)&ch.rlist) {
 80010aa:	d1fa      	bne.n	80010a2 <chSysIntegrityCheckI+0x82>
    if (n != (cnt_t)0) {
 80010ac:	3000      	adds	r0, #0
 80010ae:	bf18      	it	ne
 80010b0:	2001      	movne	r0, #1
 80010b2:	bd10      	pop	{r4, pc}
    tp = ch.rlist.older;
 80010b4:	6959      	ldr	r1, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 80010b6:	4299      	cmp	r1, r3
    n = (cnt_t)0;
 80010b8:	f04f 0000 	mov.w	r0, #0
    while (tp != (thread_t *)&ch.rlist) {
 80010bc:	d1f1      	bne.n	80010a2 <chSysIntegrityCheckI+0x82>
}
 80010be:	bd10      	pop	{r4, pc}
      return true;
 80010c0:	2001      	movs	r0, #1
 80010c2:	bd10      	pop	{r4, pc}
    tp = ch.rlist.queue.prev;
 80010c4:	6850      	ldr	r0, [r2, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 80010c6:	4290      	cmp	r0, r2
    n = (cnt_t)0;
 80010c8:	bf18      	it	ne
 80010ca:	2300      	movne	r3, #0
    while (tp != (thread_t *)&ch.rlist.queue) {
 80010cc:	d1bb      	bne.n	8001046 <chSysIntegrityCheckI+0x26>
 80010ce:	e7c1      	b.n	8001054 <chSysIntegrityCheckI+0x34>
    vtp = ch.vtlist.prev;
 80010d0:	6a12      	ldr	r2, [r2, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80010d2:	4282      	cmp	r2, r0
    n = (cnt_t)0;
 80010d4:	bf18      	it	ne
 80010d6:	2300      	movne	r3, #0
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80010d8:	d1cd      	bne.n	8001076 <chSysIntegrityCheckI+0x56>
 80010da:	e7d2      	b.n	8001082 <chSysIntegrityCheckI+0x62>
 80010dc:	20001e68 	.word	0x20001e68

080010e0 <_dbg_check_leave_isr>:
void _dbg_check_leave_isr(void) {
 80010e0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80010e2:	2320      	movs	r3, #32
 80010e4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80010e8:	4a06      	ldr	r2, [pc, #24]	; (8001104 <_dbg_check_leave_isr+0x24>)
 80010ea:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80010ec:	2b00      	cmp	r3, #0
 80010ee:	dd01      	ble.n	80010f4 <_dbg_check_leave_isr+0x14>
 80010f0:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80010f2:	b111      	cbz	r1, 80010fa <_dbg_check_leave_isr+0x1a>
    chSysHalt("SV#9");
 80010f4:	4804      	ldr	r0, [pc, #16]	; (8001108 <_dbg_check_leave_isr+0x28>)
 80010f6:	f7ff fb93 	bl	8000820 <chSysHalt>
  ch.dbg.isr_cnt--;
 80010fa:	3b01      	subs	r3, #1
 80010fc:	6313      	str	r3, [r2, #48]	; 0x30
 80010fe:	f381 8811 	msr	BASEPRI, r1
 8001102:	bd08      	pop	{r3, pc}
 8001104:	20001e68 	.word	0x20001e68
 8001108:	0800a750 	.word	0x0800a750
 800110c:	00000000 	.word	0x00000000

08001110 <_dbg_check_enter_isr>:
void _dbg_check_enter_isr(void) {
 8001110:	b508      	push	{r3, lr}
 8001112:	2320      	movs	r3, #32
 8001114:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001118:	4a06      	ldr	r2, [pc, #24]	; (8001134 <_dbg_check_enter_isr+0x24>)
 800111a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800111c:	2b00      	cmp	r3, #0
 800111e:	db01      	blt.n	8001124 <_dbg_check_enter_isr+0x14>
 8001120:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8001122:	b111      	cbz	r1, 800112a <_dbg_check_enter_isr+0x1a>
    chSysHalt("SV#8");
 8001124:	4804      	ldr	r0, [pc, #16]	; (8001138 <_dbg_check_enter_isr+0x28>)
 8001126:	f7ff fb7b 	bl	8000820 <chSysHalt>
  ch.dbg.isr_cnt++;
 800112a:	3301      	adds	r3, #1
 800112c:	6313      	str	r3, [r2, #48]	; 0x30
 800112e:	f381 8811 	msr	BASEPRI, r1
 8001132:	bd08      	pop	{r3, pc}
 8001134:	20001e68 	.word	0x20001e68
 8001138:	0800a748 	.word	0x0800a748
 800113c:	00000000 	.word	0x00000000

08001140 <_dbg_check_unlock_from_isr>:
void _dbg_check_unlock_from_isr(void) {
 8001140:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001142:	4b06      	ldr	r3, [pc, #24]	; (800115c <_dbg_check_unlock_from_isr+0x1c>)
 8001144:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001146:	2a00      	cmp	r2, #0
 8001148:	dd05      	ble.n	8001156 <_dbg_check_unlock_from_isr+0x16>
 800114a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800114c:	2a00      	cmp	r2, #0
 800114e:	dd02      	ble.n	8001156 <_dbg_check_unlock_from_isr+0x16>
  _dbg_leave_lock();
 8001150:	2200      	movs	r2, #0
 8001152:	635a      	str	r2, [r3, #52]	; 0x34
 8001154:	bd08      	pop	{r3, pc}
    chSysHalt("SV#7");
 8001156:	4802      	ldr	r0, [pc, #8]	; (8001160 <_dbg_check_unlock_from_isr+0x20>)
 8001158:	f7ff fb62 	bl	8000820 <chSysHalt>
 800115c:	20001e68 	.word	0x20001e68
 8001160:	0800a778 	.word	0x0800a778
	...

08001170 <_dbg_check_lock_from_isr>:
void _dbg_check_lock_from_isr(void) {
 8001170:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001172:	4b06      	ldr	r3, [pc, #24]	; (800118c <_dbg_check_lock_from_isr+0x1c>)
 8001174:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001176:	2a00      	cmp	r2, #0
 8001178:	dd01      	ble.n	800117e <_dbg_check_lock_from_isr+0xe>
 800117a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800117c:	b112      	cbz	r2, 8001184 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
 800117e:	4804      	ldr	r0, [pc, #16]	; (8001190 <_dbg_check_lock_from_isr+0x20>)
 8001180:	f7ff fb4e 	bl	8000820 <chSysHalt>
  _dbg_enter_lock();
 8001184:	2201      	movs	r2, #1
 8001186:	635a      	str	r2, [r3, #52]	; 0x34
 8001188:	bd08      	pop	{r3, pc}
 800118a:	bf00      	nop
 800118c:	20001e68 	.word	0x20001e68
 8001190:	0800a760 	.word	0x0800a760
	...

080011a0 <wakeup>:
static void wakeup(void *p) {
 80011a0:	b538      	push	{r3, r4, r5, lr}
 80011a2:	4604      	mov	r4, r0
 80011a4:	2320      	movs	r3, #32
 80011a6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80011aa:	f7ff ffe1 	bl	8001170 <_dbg_check_lock_from_isr>
  switch (tp->state) {
 80011ae:	f894 3020 	ldrb.w	r3, [r4, #32]
 80011b2:	2b07      	cmp	r3, #7
 80011b4:	d810      	bhi.n	80011d8 <wakeup+0x38>
 80011b6:	e8df f003 	tbb	[pc, r3]
 80011ba:	0f15      	.short	0x0f15
 80011bc:	040a1b0f 	.word	0x040a1b0f
 80011c0:	0a0f      	.short	0x0a0f
    chSemFastSignalI(tp->u.wtsemp);
 80011c2:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 80011c4:	f7ff fb7c 	bl	80008c0 <chDbgCheckClassI>

  sp->cnt++;
 80011c8:	68ab      	ldr	r3, [r5, #8]
 80011ca:	3301      	adds	r3, #1
 80011cc:	60ab      	str	r3, [r5, #8]
  tp->queue.prev->queue.next = tp->queue.next;
 80011ce:	e894 000c 	ldmia.w	r4, {r2, r3}
 80011d2:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80011d4:	6822      	ldr	r2, [r4, #0]
 80011d6:	6053      	str	r3, [r2, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
 80011d8:	f04f 33ff 	mov.w	r3, #4294967295
 80011dc:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 80011de:	4620      	mov	r0, r4
 80011e0:	f7ff fc36 	bl	8000a50 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80011e4:	f7ff ffac 	bl	8001140 <_dbg_check_unlock_from_isr>
 80011e8:	2300      	movs	r3, #0
 80011ea:	f383 8811 	msr	BASEPRI, r3
 80011ee:	bd38      	pop	{r3, r4, r5, pc}
    *tp->u.wttrp = NULL;
 80011f0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80011f2:	2200      	movs	r2, #0
 80011f4:	601a      	str	r2, [r3, #0]
  tp->u.rdymsg = MSG_TIMEOUT;
 80011f6:	f04f 33ff 	mov.w	r3, #4294967295
 80011fa:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 80011fc:	4620      	mov	r0, r4
 80011fe:	f7ff fc27 	bl	8000a50 <chSchReadyI>
 8001202:	e7ef      	b.n	80011e4 <wakeup+0x44>
	...

08001210 <_dbg_check_unlock>:
void _dbg_check_unlock(void) {
 8001210:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001212:	4b05      	ldr	r3, [pc, #20]	; (8001228 <_dbg_check_unlock+0x18>)
 8001214:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001216:	b922      	cbnz	r2, 8001222 <_dbg_check_unlock+0x12>
 8001218:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800121a:	2900      	cmp	r1, #0
 800121c:	dd01      	ble.n	8001222 <_dbg_check_unlock+0x12>
  _dbg_leave_lock();
 800121e:	635a      	str	r2, [r3, #52]	; 0x34
 8001220:	bd08      	pop	{r3, pc}
    chSysHalt("SV#5");
 8001222:	4802      	ldr	r0, [pc, #8]	; (800122c <_dbg_check_unlock+0x1c>)
 8001224:	f7ff fafc 	bl	8000820 <chSysHalt>
 8001228:	20001e68 	.word	0x20001e68
 800122c:	0800a770 	.word	0x0800a770

08001230 <chSysUnlock.lto_priv.83>:
static inline void chSysUnlock(void) {
 8001230:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8001232:	f7ff ffed 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001236:	4b08      	ldr	r3, [pc, #32]	; (8001258 <chSysUnlock.lto_priv.83+0x28>)
 8001238:	681a      	ldr	r2, [r3, #0]
 800123a:	429a      	cmp	r2, r3
 800123c:	d004      	beq.n	8001248 <chSysUnlock.lto_priv.83+0x18>
 800123e:	6999      	ldr	r1, [r3, #24]
 8001240:	6893      	ldr	r3, [r2, #8]
 8001242:	688a      	ldr	r2, [r1, #8]
 8001244:	429a      	cmp	r2, r3
 8001246:	d303      	bcc.n	8001250 <chSysUnlock.lto_priv.83+0x20>
 8001248:	2300      	movs	r3, #0
 800124a:	f383 8811 	msr	BASEPRI, r3
 800124e:	bd08      	pop	{r3, pc}
 8001250:	4802      	ldr	r0, [pc, #8]	; (800125c <chSysUnlock.lto_priv.83+0x2c>)
 8001252:	f7ff fae5 	bl	8000820 <chSysHalt>
 8001256:	bf00      	nop
 8001258:	20001e68 	.word	0x20001e68
 800125c:	0800c538 	.word	0x0800c538

08001260 <_dbg_check_lock>:
void _dbg_check_lock(void) {
 8001260:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001262:	4b05      	ldr	r3, [pc, #20]	; (8001278 <_dbg_check_lock+0x18>)
 8001264:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001266:	b90a      	cbnz	r2, 800126c <_dbg_check_lock+0xc>
 8001268:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800126a:	b112      	cbz	r2, 8001272 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
 800126c:	4803      	ldr	r0, [pc, #12]	; (800127c <_dbg_check_lock+0x1c>)
 800126e:	f7ff fad7 	bl	8000820 <chSysHalt>
  _dbg_enter_lock();
 8001272:	2201      	movs	r2, #1
 8001274:	635a      	str	r2, [r3, #52]	; 0x34
 8001276:	bd08      	pop	{r3, pc}
 8001278:	20001e68 	.word	0x20001e68
 800127c:	0800a758 	.word	0x0800a758

08001280 <chThdCreateFromHeap>:
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
 8001280:	b570      	push	{r4, r5, r6, lr}
 8001282:	b086      	sub	sp, #24
 8001284:	4616      	mov	r6, r2
 8001286:	461d      	mov	r5, r3
 8001288:	460c      	mov	r4, r1
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 800128a:	f008 fdd1 	bl	8009e30 <chHeapAllocAligned.constprop.41>
  if (wsp == NULL) {
 800128e:	2800      	cmp	r0, #0
 8001290:	d033      	beq.n	80012fa <chThdCreateFromHeap+0x7a>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 8001292:	4404      	add	r4, r0
  thread_descriptor_t td = {
 8001294:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001296:	9304      	str	r3, [sp, #16]
  while (startp < endp) {
 8001298:	42a0      	cmp	r0, r4
 800129a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800129c:	9305      	str	r3, [sp, #20]
 800129e:	9402      	str	r4, [sp, #8]
 80012a0:	9600      	str	r6, [sp, #0]
 80012a2:	9001      	str	r0, [sp, #4]
 80012a4:	9503      	str	r5, [sp, #12]
    *startp++ = v;
 80012a6:	bf38      	it	cc
 80012a8:	2355      	movcc	r3, #85	; 0x55
  while (startp < endp) {
 80012aa:	d203      	bcs.n	80012b4 <chThdCreateFromHeap+0x34>
    *startp++ = v;
 80012ac:	f800 3b01 	strb.w	r3, [r0], #1
  while (startp < endp) {
 80012b0:	4284      	cmp	r4, r0
 80012b2:	d1fb      	bne.n	80012ac <chThdCreateFromHeap+0x2c>
 80012b4:	2320      	movs	r3, #32
 80012b6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80012ba:	f7ff ffd1 	bl	8001260 <_dbg_check_lock>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 80012be:	4668      	mov	r0, sp
 80012c0:	f7ff fb0e 	bl	80008e0 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 80012c4:	2301      	movs	r3, #1
 80012c6:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 80012ca:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(&td);
 80012cc:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 80012ce:	f7ff fd3f 	bl	8000d50 <chSchWakeupS>
  _dbg_check_unlock();
 80012d2:	f7ff ff9d 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80012d6:	4b0a      	ldr	r3, [pc, #40]	; (8001300 <chThdCreateFromHeap+0x80>)
 80012d8:	681a      	ldr	r2, [r3, #0]
 80012da:	429a      	cmp	r2, r3
 80012dc:	d004      	beq.n	80012e8 <chThdCreateFromHeap+0x68>
 80012de:	6999      	ldr	r1, [r3, #24]
 80012e0:	6893      	ldr	r3, [r2, #8]
 80012e2:	688a      	ldr	r2, [r1, #8]
 80012e4:	429a      	cmp	r2, r3
 80012e6:	d305      	bcc.n	80012f4 <chThdCreateFromHeap+0x74>
 80012e8:	2300      	movs	r3, #0
 80012ea:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 80012ee:	4620      	mov	r0, r4
 80012f0:	b006      	add	sp, #24
 80012f2:	bd70      	pop	{r4, r5, r6, pc}
 80012f4:	4803      	ldr	r0, [pc, #12]	; (8001304 <chThdCreateFromHeap+0x84>)
 80012f6:	f7ff fa93 	bl	8000820 <chSysHalt>
    return NULL;
 80012fa:	4604      	mov	r4, r0
 80012fc:	e7f7      	b.n	80012ee <chThdCreateFromHeap+0x6e>
 80012fe:	bf00      	nop
 8001300:	20001e68 	.word	0x20001e68
 8001304:	0800c544 	.word	0x0800c544
	...

08001310 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8001310:	b538      	push	{r3, r4, r5, lr}
 8001312:	4604      	mov	r4, r0
 8001314:	460d      	mov	r5, r1
 8001316:	2320      	movs	r3, #32
 8001318:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800131c:	f7ff ffa0 	bl	8001260 <_dbg_check_lock>

  chSysLock();
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
 8001320:	f894 3020 	ldrb.w	r3, [r4, #32]
 8001324:	2b0d      	cmp	r3, #13
 8001326:	d002      	beq.n	800132e <chMsgRelease+0x1e>
 8001328:	480d      	ldr	r0, [pc, #52]	; (8001360 <chMsgRelease+0x50>)
 800132a:	f7ff fa79 	bl	8000820 <chSysHalt>
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();
 800132e:	f7ff fa8f 	bl	8000850 <chDbgCheckClassS>

  chSchWakeupS(tp, msg);
 8001332:	4629      	mov	r1, r5
 8001334:	4620      	mov	r0, r4
 8001336:	f7ff fd0b 	bl	8000d50 <chSchWakeupS>
  _dbg_check_unlock();
 800133a:	f7ff ff69 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800133e:	4b09      	ldr	r3, [pc, #36]	; (8001364 <chMsgRelease+0x54>)
 8001340:	681a      	ldr	r2, [r3, #0]
 8001342:	429a      	cmp	r2, r3
 8001344:	d004      	beq.n	8001350 <chMsgRelease+0x40>
 8001346:	6999      	ldr	r1, [r3, #24]
 8001348:	6893      	ldr	r3, [r2, #8]
 800134a:	688a      	ldr	r2, [r1, #8]
 800134c:	429a      	cmp	r2, r3
 800134e:	d303      	bcc.n	8001358 <chMsgRelease+0x48>
 8001350:	2300      	movs	r3, #0
 8001352:	f383 8811 	msr	BASEPRI, r3
 8001356:	bd38      	pop	{r3, r4, r5, pc}
 8001358:	4803      	ldr	r0, [pc, #12]	; (8001368 <chMsgRelease+0x58>)
 800135a:	f7ff fa61 	bl	8000820 <chSysHalt>
 800135e:	bf00      	nop
 8001360:	0800a608 	.word	0x0800a608
 8001364:	20001e68 	.word	0x20001e68
 8001368:	0800a5b0 	.word	0x0800a5b0
 800136c:	00000000 	.word	0x00000000

08001370 <chMsgWait>:
thread_t *chMsgWait(void) {
 8001370:	b570      	push	{r4, r5, r6, lr}
 8001372:	2320      	movs	r3, #32
 8001374:	f383 8811 	msr	BASEPRI, r3
  if (!chMsgIsPendingI(currp)) {
 8001378:	4c15      	ldr	r4, [pc, #84]	; (80013d0 <chMsgWait+0x60>)
  _dbg_check_lock();
 800137a:	f7ff ff71 	bl	8001260 <_dbg_check_lock>
 800137e:	69a6      	ldr	r6, [r4, #24]
  chDbgCheckClassI();
 8001380:	f7ff fa9e 	bl	80008c0 <chDbgCheckClassI>
  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 8001384:	4633      	mov	r3, r6
 8001386:	f853 5f2c 	ldr.w	r5, [r3, #44]!
 800138a:	429d      	cmp	r5, r3
 800138c:	d017      	beq.n	80013be <chMsgWait+0x4e>
  tqp->next             = tp->queue.next;
 800138e:	682a      	ldr	r2, [r5, #0]
 8001390:	62f2      	str	r2, [r6, #44]	; 0x2c
  tp->state = CH_STATE_SNDMSG;
 8001392:	210d      	movs	r1, #13
  tqp->next->queue.prev = (thread_t *)tqp;
 8001394:	6053      	str	r3, [r2, #4]
 8001396:	f885 1020 	strb.w	r1, [r5, #32]
  _dbg_check_unlock();
 800139a:	f7ff ff39 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800139e:	6823      	ldr	r3, [r4, #0]
 80013a0:	42a3      	cmp	r3, r4
 80013a2:	d004      	beq.n	80013ae <chMsgWait+0x3e>
 80013a4:	69a2      	ldr	r2, [r4, #24]
 80013a6:	689b      	ldr	r3, [r3, #8]
 80013a8:	6892      	ldr	r2, [r2, #8]
 80013aa:	429a      	cmp	r2, r3
 80013ac:	d304      	bcc.n	80013b8 <chMsgWait+0x48>
 80013ae:	2300      	movs	r3, #0
 80013b0:	f383 8811 	msr	BASEPRI, r3
}
 80013b4:	4628      	mov	r0, r5
 80013b6:	bd70      	pop	{r4, r5, r6, pc}
 80013b8:	4806      	ldr	r0, [pc, #24]	; (80013d4 <chMsgWait+0x64>)
 80013ba:	f7ff fa31 	bl	8000820 <chSysHalt>
    chSchGoSleepS(CH_STATE_WTMSG);
 80013be:	200e      	movs	r0, #14
 80013c0:	f7ff fa56 	bl	8000870 <chSchGoSleepS>
 80013c4:	69a6      	ldr	r6, [r4, #24]
 80013c6:	6af5      	ldr	r5, [r6, #44]	; 0x2c
 80013c8:	f106 032c 	add.w	r3, r6, #44	; 0x2c
 80013cc:	e7df      	b.n	800138e <chMsgWait+0x1e>
 80013ce:	bf00      	nop
 80013d0:	20001e68 	.word	0x20001e68
 80013d4:	0800a5b0 	.word	0x0800a5b0
	...

080013e0 <chMsgSend>:
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 80013e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 80013e2:	4e19      	ldr	r6, [pc, #100]	; (8001448 <chMsgSend+0x68>)
 80013e4:	69b4      	ldr	r4, [r6, #24]
  chDbgCheck(tp != NULL);
 80013e6:	b360      	cbz	r0, 8001442 <chMsgSend+0x62>
 80013e8:	460f      	mov	r7, r1
 80013ea:	4605      	mov	r5, r0
 80013ec:	2320      	movs	r3, #32
 80013ee:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80013f2:	f7ff ff35 	bl	8001260 <_dbg_check_lock>
  ctp->u.sentmsg = msg;
 80013f6:	6267      	str	r7, [r4, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
 80013f8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80013fa:	6063      	str	r3, [r4, #4]
  msg_insert(ctp, &tp->msgqueue);
 80013fc:	f105 022c 	add.w	r2, r5, #44	; 0x2c
  tp->queue.next             = (thread_t *)tqp;
 8001400:	6022      	str	r2, [r4, #0]
  tp->queue.prev->queue.next = tp;
 8001402:	601c      	str	r4, [r3, #0]
  if (tp->state == CH_STATE_WTMSG) {
 8001404:	f895 3020 	ldrb.w	r3, [r5, #32]
  tqp->prev                  = tp;
 8001408:	632c      	str	r4, [r5, #48]	; 0x30
 800140a:	2b0e      	cmp	r3, #14
 800140c:	d015      	beq.n	800143a <chMsgSend+0x5a>
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 800140e:	200c      	movs	r0, #12
 8001410:	f7ff fa2e 	bl	8000870 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 8001414:	6a64      	ldr	r4, [r4, #36]	; 0x24
  _dbg_check_unlock();
 8001416:	f7ff fefb 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800141a:	6833      	ldr	r3, [r6, #0]
 800141c:	42b3      	cmp	r3, r6
 800141e:	d004      	beq.n	800142a <chMsgSend+0x4a>
 8001420:	69b2      	ldr	r2, [r6, #24]
 8001422:	689b      	ldr	r3, [r3, #8]
 8001424:	6892      	ldr	r2, [r2, #8]
 8001426:	429a      	cmp	r2, r3
 8001428:	d304      	bcc.n	8001434 <chMsgSend+0x54>
 800142a:	2300      	movs	r3, #0
 800142c:	f383 8811 	msr	BASEPRI, r3
}
 8001430:	4620      	mov	r0, r4
 8001432:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001434:	4805      	ldr	r0, [pc, #20]	; (800144c <chMsgSend+0x6c>)
 8001436:	f7ff f9f3 	bl	8000820 <chSysHalt>
    (void) chSchReadyI(tp);
 800143a:	4628      	mov	r0, r5
 800143c:	f7ff fb08 	bl	8000a50 <chSchReadyI>
 8001440:	e7e5      	b.n	800140e <chMsgSend+0x2e>
  chDbgCheck(tp != NULL);
 8001442:	4803      	ldr	r0, [pc, #12]	; (8001450 <chMsgSend+0x70>)
 8001444:	f7ff f9ec 	bl	8000820 <chSysHalt>
 8001448:	20001e68 	.word	0x20001e68
 800144c:	0800a5b0 	.word	0x0800a5b0
 8001450:	0800a5bc 	.word	0x0800a5bc
	...

08001460 <chEvtAddEvents>:
eventmask_t chEvtAddEvents(eventmask_t events) {
 8001460:	b538      	push	{r3, r4, r5, lr}
 8001462:	4605      	mov	r5, r0
 8001464:	2320      	movs	r3, #32
 8001466:	f383 8811 	msr	BASEPRI, r3
  currp->epending |= events;
 800146a:	4c0c      	ldr	r4, [pc, #48]	; (800149c <chEvtAddEvents+0x3c>)
  _dbg_check_lock();
 800146c:	f7ff fef8 	bl	8001260 <_dbg_check_lock>
 8001470:	69a3      	ldr	r3, [r4, #24]
 8001472:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8001474:	4305      	orrs	r5, r0
 8001476:	635d      	str	r5, [r3, #52]	; 0x34
  _dbg_check_unlock();
 8001478:	f7ff feca 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800147c:	6823      	ldr	r3, [r4, #0]
 800147e:	42a3      	cmp	r3, r4
 8001480:	d004      	beq.n	800148c <chEvtAddEvents+0x2c>
 8001482:	69a2      	ldr	r2, [r4, #24]
 8001484:	689b      	ldr	r3, [r3, #8]
 8001486:	6892      	ldr	r2, [r2, #8]
 8001488:	429a      	cmp	r2, r3
 800148a:	d304      	bcc.n	8001496 <chEvtAddEvents+0x36>
 800148c:	2300      	movs	r3, #0
 800148e:	f383 8811 	msr	BASEPRI, r3
}
 8001492:	4628      	mov	r0, r5
 8001494:	bd38      	pop	{r3, r4, r5, pc}
 8001496:	4802      	ldr	r0, [pc, #8]	; (80014a0 <chEvtAddEvents+0x40>)
 8001498:	f7ff f9c2 	bl	8000820 <chSysHalt>
 800149c:	20001e68 	.word	0x20001e68
 80014a0:	0800c538 	.word	0x0800c538
	...

080014b0 <chEvtUnregister>:
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 80014b0:	b538      	push	{r3, r4, r5, lr}
  chDbgCheck((esp != NULL) && (elp != NULL));
 80014b2:	b320      	cbz	r0, 80014fe <chEvtUnregister+0x4e>
 80014b4:	460d      	mov	r5, r1
 80014b6:	b311      	cbz	r1, 80014fe <chEvtUnregister+0x4e>
 80014b8:	4604      	mov	r4, r0
 80014ba:	2320      	movs	r3, #32
 80014bc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80014c0:	f7ff fece 	bl	8001260 <_dbg_check_lock>
 80014c4:	4622      	mov	r2, r4
 80014c6:	e002      	b.n	80014ce <chEvtUnregister+0x1e>
    if (p->next == elp) {
 80014c8:	429d      	cmp	r5, r3
 80014ca:	d015      	beq.n	80014f8 <chEvtUnregister+0x48>
 80014cc:	461a      	mov	r2, r3
  while (p->next != (event_listener_t *)esp) {
 80014ce:	6813      	ldr	r3, [r2, #0]
 80014d0:	429c      	cmp	r4, r3
 80014d2:	d1f9      	bne.n	80014c8 <chEvtUnregister+0x18>
  _dbg_check_unlock();
 80014d4:	f7ff fe9c 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80014d8:	4b0a      	ldr	r3, [pc, #40]	; (8001504 <chEvtUnregister+0x54>)
 80014da:	681a      	ldr	r2, [r3, #0]
 80014dc:	429a      	cmp	r2, r3
 80014de:	d004      	beq.n	80014ea <chEvtUnregister+0x3a>
 80014e0:	6999      	ldr	r1, [r3, #24]
 80014e2:	6893      	ldr	r3, [r2, #8]
 80014e4:	688a      	ldr	r2, [r1, #8]
 80014e6:	429a      	cmp	r2, r3
 80014e8:	d303      	bcc.n	80014f2 <chEvtUnregister+0x42>
 80014ea:	2300      	movs	r3, #0
 80014ec:	f383 8811 	msr	BASEPRI, r3
 80014f0:	bd38      	pop	{r3, r4, r5, pc}
 80014f2:	4805      	ldr	r0, [pc, #20]	; (8001508 <chEvtUnregister+0x58>)
 80014f4:	f7ff f994 	bl	8000820 <chSysHalt>
      p->next = elp->next;
 80014f8:	682b      	ldr	r3, [r5, #0]
 80014fa:	6013      	str	r3, [r2, #0]
 80014fc:	e7ea      	b.n	80014d4 <chEvtUnregister+0x24>
  chDbgCheck((esp != NULL) && (elp != NULL));
 80014fe:	4803      	ldr	r0, [pc, #12]	; (800150c <chEvtUnregister+0x5c>)
 8001500:	f7ff f98e 	bl	8000820 <chSysHalt>
 8001504:	20001e68 	.word	0x20001e68
 8001508:	0800c538 	.word	0x0800c538
 800150c:	0800a5ec 	.word	0x0800a5ec

08001510 <chMtxUnlock>:
void chMtxUnlock(mutex_t *mp) {
 8001510:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  thread_t *ctp = currp;
 8001514:	4f28      	ldr	r7, [pc, #160]	; (80015b8 <chMtxUnlock+0xa8>)
 8001516:	69bd      	ldr	r5, [r7, #24]
  chDbgCheck(mp != NULL);
 8001518:	b150      	cbz	r0, 8001530 <chMtxUnlock+0x20>
 800151a:	4606      	mov	r6, r0
 800151c:	2320      	movs	r3, #32
 800151e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8001522:	f7ff fe9d 	bl	8001260 <_dbg_check_lock>
  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8001526:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001528:	b113      	cbz	r3, 8001530 <chMtxUnlock+0x20>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800152a:	689a      	ldr	r2, [r3, #8]
 800152c:	4295      	cmp	r5, r2
 800152e:	d002      	beq.n	8001536 <chMtxUnlock+0x26>
  chDbgCheck(mp != NULL);
 8001530:	4822      	ldr	r0, [pc, #136]	; (80015bc <chMtxUnlock+0xac>)
 8001532:	f7ff f975 	bl	8000820 <chSysHalt>
    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8001536:	429e      	cmp	r6, r3
 8001538:	d1fa      	bne.n	8001530 <chMtxUnlock+0x20>
    ctp->mtxlist = mp->next;
 800153a:	68f4      	ldr	r4, [r6, #12]
 800153c:	63ac      	str	r4, [r5, #56]	; 0x38
 800153e:	f7ff f987 	bl	8000850 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8001542:	f8d6 9000 	ldr.w	r9, [r6]
    if (chMtxQueueNotEmptyS(mp)) {
 8001546:	454e      	cmp	r6, r9
 8001548:	d032      	beq.n	80015b0 <chMtxUnlock+0xa0>
      tprio_t newprio = ctp->realprio;
 800154a:	f8d5 803c 	ldr.w	r8, [r5, #60]	; 0x3c
      while (lmp != NULL) {
 800154e:	b15c      	cbz	r4, 8001568 <chMtxUnlock+0x58>
 8001550:	f7ff f97e 	bl	8000850 <chDbgCheckClassS>
 8001554:	6823      	ldr	r3, [r4, #0]
        if (chMtxQueueNotEmptyS(lmp) &&
 8001556:	429c      	cmp	r4, r3
 8001558:	d003      	beq.n	8001562 <chMtxUnlock+0x52>
 800155a:	689b      	ldr	r3, [r3, #8]
 800155c:	4598      	cmp	r8, r3
 800155e:	bf38      	it	cc
 8001560:	4698      	movcc	r8, r3
        lmp = lmp->next;
 8001562:	68e4      	ldr	r4, [r4, #12]
      while (lmp != NULL) {
 8001564:	2c00      	cmp	r4, #0
 8001566:	d1f3      	bne.n	8001550 <chMtxUnlock+0x40>
  tqp->next             = tp->queue.next;
 8001568:	f8d9 3000 	ldr.w	r3, [r9]
      mp->next = tp->mtxlist;
 800156c:	f8d9 2038 	ldr.w	r2, [r9, #56]	; 0x38
      ctp->prio = newprio;
 8001570:	f8c5 8008 	str.w	r8, [r5, #8]
      (void) chSchReadyI(tp);
 8001574:	4648      	mov	r0, r9
 8001576:	6033      	str	r3, [r6, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001578:	605e      	str	r6, [r3, #4]
      mp->next = tp->mtxlist;
 800157a:	60f2      	str	r2, [r6, #12]
      mp->owner = tp;
 800157c:	f8c6 9008 	str.w	r9, [r6, #8]
      tp->mtxlist = mp;
 8001580:	f8c9 6038 	str.w	r6, [r9, #56]	; 0x38
      (void) chSchReadyI(tp);
 8001584:	f7ff fa64 	bl	8000a50 <chSchReadyI>
      chSchRescheduleS();
 8001588:	f7ff fa4a 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 800158c:	f7ff fe40 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001590:	683b      	ldr	r3, [r7, #0]
 8001592:	42bb      	cmp	r3, r7
 8001594:	d004      	beq.n	80015a0 <chMtxUnlock+0x90>
 8001596:	69ba      	ldr	r2, [r7, #24]
 8001598:	689b      	ldr	r3, [r3, #8]
 800159a:	6892      	ldr	r2, [r2, #8]
 800159c:	429a      	cmp	r2, r3
 800159e:	d304      	bcc.n	80015aa <chMtxUnlock+0x9a>
 80015a0:	2300      	movs	r3, #0
 80015a2:	f383 8811 	msr	BASEPRI, r3
 80015a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80015aa:	4805      	ldr	r0, [pc, #20]	; (80015c0 <chMtxUnlock+0xb0>)
 80015ac:	f7ff f938 	bl	8000820 <chSysHalt>
      mp->owner = NULL;
 80015b0:	2300      	movs	r3, #0
 80015b2:	60b3      	str	r3, [r6, #8]
 80015b4:	e7ea      	b.n	800158c <chMtxUnlock+0x7c>
 80015b6:	bf00      	nop
 80015b8:	20001e68 	.word	0x20001e68
 80015bc:	0800a678 	.word	0x0800a678
 80015c0:	0800c520 	.word	0x0800c520
	...

080015d0 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
 80015d0:	b510      	push	{r4, lr}
 80015d2:	2320      	movs	r3, #32
 80015d4:	4604      	mov	r4, r0
 80015d6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80015da:	f7ff fe41 	bl	8001260 <_dbg_check_lock>
  chMtxLockS(mp);
 80015de:	4620      	mov	r0, r4
 80015e0:	f7ff faee 	bl	8000bc0 <chMtxLockS>
  _dbg_check_unlock();
 80015e4:	f7ff fe14 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80015e8:	4b07      	ldr	r3, [pc, #28]	; (8001608 <chMtxLock+0x38>)
 80015ea:	681a      	ldr	r2, [r3, #0]
 80015ec:	429a      	cmp	r2, r3
 80015ee:	d004      	beq.n	80015fa <chMtxLock+0x2a>
 80015f0:	6999      	ldr	r1, [r3, #24]
 80015f2:	6893      	ldr	r3, [r2, #8]
 80015f4:	688a      	ldr	r2, [r1, #8]
 80015f6:	429a      	cmp	r2, r3
 80015f8:	d303      	bcc.n	8001602 <chMtxLock+0x32>
 80015fa:	2300      	movs	r3, #0
 80015fc:	f383 8811 	msr	BASEPRI, r3
 8001600:	bd10      	pop	{r4, pc}
 8001602:	4802      	ldr	r0, [pc, #8]	; (800160c <chMtxLock+0x3c>)
 8001604:	f7ff f90c 	bl	8000820 <chSysHalt>
 8001608:	20001e68 	.word	0x20001e68
 800160c:	0800c520 	.word	0x0800c520

08001610 <chSemSignal>:
void chSemSignal(semaphore_t *sp) {
 8001610:	b510      	push	{r4, lr}
  chDbgCheck(sp != NULL);
 8001612:	b130      	cbz	r0, 8001622 <chSemSignal+0x12>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8001614:	6883      	ldr	r3, [r0, #8]
 8001616:	2b00      	cmp	r3, #0
 8001618:	4604      	mov	r4, r0
 800161a:	6803      	ldr	r3, [r0, #0]
 800161c:	db04      	blt.n	8001628 <chSemSignal+0x18>
 800161e:	4298      	cmp	r0, r3
 8001620:	d004      	beq.n	800162c <chSemSignal+0x1c>
  chDbgCheck(sp != NULL);
 8001622:	4814      	ldr	r0, [pc, #80]	; (8001674 <chSemSignal+0x64>)
 8001624:	f7ff f8fc 	bl	8000820 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8001628:	4298      	cmp	r0, r3
 800162a:	d0fa      	beq.n	8001622 <chSemSignal+0x12>
 800162c:	2320      	movs	r3, #32
 800162e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8001632:	f7ff fe15 	bl	8001260 <_dbg_check_lock>
  if (++sp->cnt <= (cnt_t)0) {
 8001636:	68a3      	ldr	r3, [r4, #8]
 8001638:	3301      	adds	r3, #1
 800163a:	2b00      	cmp	r3, #0
 800163c:	60a3      	str	r3, [r4, #8]
 800163e:	dd11      	ble.n	8001664 <chSemSignal+0x54>
  _dbg_check_unlock();
 8001640:	f7ff fde6 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001644:	4b0c      	ldr	r3, [pc, #48]	; (8001678 <chSemSignal+0x68>)
 8001646:	681a      	ldr	r2, [r3, #0]
 8001648:	429a      	cmp	r2, r3
 800164a:	d004      	beq.n	8001656 <chSemSignal+0x46>
 800164c:	6999      	ldr	r1, [r3, #24]
 800164e:	6893      	ldr	r3, [r2, #8]
 8001650:	688a      	ldr	r2, [r1, #8]
 8001652:	429a      	cmp	r2, r3
 8001654:	d303      	bcc.n	800165e <chSemSignal+0x4e>
 8001656:	2300      	movs	r3, #0
 8001658:	f383 8811 	msr	BASEPRI, r3
 800165c:	bd10      	pop	{r4, pc}
 800165e:	4807      	ldr	r0, [pc, #28]	; (800167c <chSemSignal+0x6c>)
 8001660:	f7ff f8de 	bl	8000820 <chSysHalt>
  thread_t *tp = tqp->next;
 8001664:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 8001666:	6803      	ldr	r3, [r0, #0]
 8001668:	6023      	str	r3, [r4, #0]
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 800166a:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 800166c:	605c      	str	r4, [r3, #4]
 800166e:	f7ff fb6f 	bl	8000d50 <chSchWakeupS>
 8001672:	e7e5      	b.n	8001640 <chSemSignal+0x30>
 8001674:	0800a698 	.word	0x0800a698
 8001678:	20001e68 	.word	0x20001e68
 800167c:	0800c514 	.word	0x0800c514

08001680 <chSemWait>:
msg_t chSemWait(semaphore_t *sp) {
 8001680:	b538      	push	{r3, r4, r5, lr}
 8001682:	4604      	mov	r4, r0
 8001684:	2320      	movs	r3, #32
 8001686:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800168a:	f7ff fde9 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassS();
 800168e:	f7ff f8df 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 8001692:	b12c      	cbz	r4, 80016a0 <chSemWait+0x20>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8001694:	68a3      	ldr	r3, [r4, #8]
 8001696:	6822      	ldr	r2, [r4, #0]
 8001698:	2b00      	cmp	r3, #0
 800169a:	db04      	blt.n	80016a6 <chSemWait+0x26>
 800169c:	4294      	cmp	r4, r2
 800169e:	d004      	beq.n	80016aa <chSemWait+0x2a>
  chDbgCheck(sp != NULL);
 80016a0:	4814      	ldr	r0, [pc, #80]	; (80016f4 <chSemWait+0x74>)
 80016a2:	f7ff f8bd 	bl	8000820 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 80016a6:	4294      	cmp	r4, r2
 80016a8:	d0fa      	beq.n	80016a0 <chSemWait+0x20>
  if (--sp->cnt < (cnt_t)0) {
 80016aa:	3b01      	subs	r3, #1
 80016ac:	2b00      	cmp	r3, #0
 80016ae:	60a3      	str	r3, [r4, #8]
    currp->u.wtsemp = sp;
 80016b0:	4d11      	ldr	r5, [pc, #68]	; (80016f8 <chSemWait+0x78>)
  if (--sp->cnt < (cnt_t)0) {
 80016b2:	db12      	blt.n	80016da <chSemWait+0x5a>
  return MSG_OK;
 80016b4:	2400      	movs	r4, #0
  _dbg_check_unlock();
 80016b6:	f7ff fdab 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80016ba:	682b      	ldr	r3, [r5, #0]
 80016bc:	42ab      	cmp	r3, r5
 80016be:	d004      	beq.n	80016ca <chSemWait+0x4a>
 80016c0:	69aa      	ldr	r2, [r5, #24]
 80016c2:	689b      	ldr	r3, [r3, #8]
 80016c4:	6892      	ldr	r2, [r2, #8]
 80016c6:	429a      	cmp	r2, r3
 80016c8:	d304      	bcc.n	80016d4 <chSemWait+0x54>
 80016ca:	2300      	movs	r3, #0
 80016cc:	f383 8811 	msr	BASEPRI, r3
}
 80016d0:	4620      	mov	r0, r4
 80016d2:	bd38      	pop	{r3, r4, r5, pc}
 80016d4:	4809      	ldr	r0, [pc, #36]	; (80016fc <chSemWait+0x7c>)
 80016d6:	f7ff f8a3 	bl	8000820 <chSysHalt>
    currp->u.wtsemp = sp;
 80016da:	69ab      	ldr	r3, [r5, #24]
 80016dc:	625c      	str	r4, [r3, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
 80016de:	6862      	ldr	r2, [r4, #4]
 80016e0:	605a      	str	r2, [r3, #4]
  tp->queue.next             = (thread_t *)tqp;
 80016e2:	601c      	str	r4, [r3, #0]
    chSchGoSleepS(CH_STATE_WTSEM);
 80016e4:	2005      	movs	r0, #5
  tp->queue.prev->queue.next = tp;
 80016e6:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 80016e8:	6063      	str	r3, [r4, #4]
 80016ea:	f7ff f8c1 	bl	8000870 <chSchGoSleepS>
    return currp->u.rdymsg;
 80016ee:	69ab      	ldr	r3, [r5, #24]
 80016f0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80016f2:	e7e0      	b.n	80016b6 <chSemWait+0x36>
 80016f4:	0800a654 	.word	0x0800a654
 80016f8:	20001e68 	.word	0x20001e68
 80016fc:	0800c514 	.word	0x0800c514

08001700 <chSemReset>:
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001700:	b570      	push	{r4, r5, r6, lr}
 8001702:	2320      	movs	r3, #32
 8001704:	4604      	mov	r4, r0
 8001706:	460e      	mov	r6, r1
 8001708:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800170c:	f7ff fda8 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8001710:	f7ff f8d6 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
 8001714:	b13c      	cbz	r4, 8001726 <chSemReset+0x26>
 8001716:	2e00      	cmp	r6, #0
 8001718:	db05      	blt.n	8001726 <chSemReset+0x26>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 800171a:	68a5      	ldr	r5, [r4, #8]
 800171c:	6823      	ldr	r3, [r4, #0]
 800171e:	2d00      	cmp	r5, #0
 8001720:	db04      	blt.n	800172c <chSemReset+0x2c>
 8001722:	429c      	cmp	r4, r3
 8001724:	d004      	beq.n	8001730 <chSemReset+0x30>
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
 8001726:	4815      	ldr	r0, [pc, #84]	; (800177c <chSemReset+0x7c>)
 8001728:	f7ff f87a 	bl	8000820 <chSysHalt>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 800172c:	429c      	cmp	r4, r3
 800172e:	d0fa      	beq.n	8001726 <chSemReset+0x26>
  while (++cnt <= (cnt_t)0) {
 8001730:	3501      	adds	r5, #1
 8001732:	2d00      	cmp	r5, #0
  sp->cnt = n;
 8001734:	60a6      	str	r6, [r4, #8]
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 8001736:	bfd8      	it	le
 8001738:	f06f 0601 	mvnle.w	r6, #1
  while (++cnt <= (cnt_t)0) {
 800173c:	dc09      	bgt.n	8001752 <chSemReset+0x52>
  thread_t *tp = tqp->prev;
 800173e:	6860      	ldr	r0, [r4, #4]
  tqp->prev             = tp->queue.prev;
 8001740:	6843      	ldr	r3, [r0, #4]
 8001742:	6063      	str	r3, [r4, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 8001744:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 8001746:	f7ff f983 	bl	8000a50 <chSchReadyI>
  while (++cnt <= (cnt_t)0) {
 800174a:	3501      	adds	r5, #1
 800174c:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 800174e:	6246      	str	r6, [r0, #36]	; 0x24
  while (++cnt <= (cnt_t)0) {
 8001750:	d1f5      	bne.n	800173e <chSemReset+0x3e>
  chSchRescheduleS();
 8001752:	f7ff f965 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8001756:	f7ff fd5b 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800175a:	4b09      	ldr	r3, [pc, #36]	; (8001780 <chSemReset+0x80>)
 800175c:	681a      	ldr	r2, [r3, #0]
 800175e:	429a      	cmp	r2, r3
 8001760:	d004      	beq.n	800176c <chSemReset+0x6c>
 8001762:	6999      	ldr	r1, [r3, #24]
 8001764:	6893      	ldr	r3, [r2, #8]
 8001766:	688a      	ldr	r2, [r1, #8]
 8001768:	429a      	cmp	r2, r3
 800176a:	d303      	bcc.n	8001774 <chSemReset+0x74>
 800176c:	2300      	movs	r3, #0
 800176e:	f383 8811 	msr	BASEPRI, r3
 8001772:	bd70      	pop	{r4, r5, r6, pc}
 8001774:	4803      	ldr	r0, [pc, #12]	; (8001784 <chSemReset+0x84>)
 8001776:	f7ff f853 	bl	8000820 <chSysHalt>
 800177a:	bf00      	nop
 800177c:	0800a5fc 	.word	0x0800a5fc
 8001780:	20001e68 	.word	0x20001e68
 8001784:	0800c514 	.word	0x0800c514
	...

08001790 <chThdYield>:
void chThdYield(void) {
 8001790:	b538      	push	{r3, r4, r5, lr}
 8001792:	2320      	movs	r3, #32
 8001794:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 8001798:	4c1b      	ldr	r4, [pc, #108]	; (8001808 <chThdYield+0x78>)
  _dbg_check_lock();
 800179a:	f7ff fd61 	bl	8001260 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();
 800179e:	f7ff f857 	bl	8000850 <chDbgCheckClassS>
  chDbgCheckClassS();
 80017a2:	f7ff f855 	bl	8000850 <chDbgCheckClassS>
  return firstprio(&ch.rlist.queue) >= currp->prio;
 80017a6:	6823      	ldr	r3, [r4, #0]
 80017a8:	69a0      	ldr	r0, [r4, #24]

  if (chSchCanYieldS()) {
 80017aa:	6899      	ldr	r1, [r3, #8]
 80017ac:	6882      	ldr	r2, [r0, #8]
 80017ae:	4291      	cmp	r1, r2
 80017b0:	d210      	bcs.n	80017d4 <chThdYield+0x44>
  _dbg_check_unlock();
 80017b2:	f7ff fd2d 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80017b6:	6823      	ldr	r3, [r4, #0]
 80017b8:	42a3      	cmp	r3, r4
 80017ba:	d004      	beq.n	80017c6 <chThdYield+0x36>
 80017bc:	69a2      	ldr	r2, [r4, #24]
 80017be:	689b      	ldr	r3, [r3, #8]
 80017c0:	6892      	ldr	r2, [r2, #8]
 80017c2:	429a      	cmp	r2, r3
 80017c4:	d303      	bcc.n	80017ce <chThdYield+0x3e>
 80017c6:	2300      	movs	r3, #0
 80017c8:	f383 8811 	msr	BASEPRI, r3
 80017cc:	bd38      	pop	{r3, r4, r5, pc}
 80017ce:	480f      	ldr	r0, [pc, #60]	; (800180c <chThdYield+0x7c>)
 80017d0:	f7ff f826 	bl	8000820 <chSysHalt>
  tqp->next             = tp->queue.next;
 80017d4:	681a      	ldr	r2, [r3, #0]
 80017d6:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 80017d8:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80017da:	6054      	str	r4, [r2, #4]
 80017dc:	f883 1020 	strb.w	r1, [r3, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
 80017e0:	61a3      	str	r3, [r4, #24]
  otp = chSchReadyI(otp);
 80017e2:	f7ff f935 	bl	8000a50 <chSchReadyI>
 80017e6:	4605      	mov	r5, r0
  chSysSwitch(currp, otp);
 80017e8:	f008 fa8a 	bl	8009d00 <_trace_switch.constprop.78>
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80017ec:	f3ef 8309 	mrs	r3, PSP
 80017f0:	69ea      	ldr	r2, [r5, #28]
 80017f2:	3b24      	subs	r3, #36	; 0x24
 80017f4:	429a      	cmp	r2, r3
 80017f6:	d804      	bhi.n	8001802 <chThdYield+0x72>
 80017f8:	4629      	mov	r1, r5
 80017fa:	69a0      	ldr	r0, [r4, #24]
 80017fc:	f7fe fd4a 	bl	8000294 <_port_switch>
 8001800:	e7d7      	b.n	80017b2 <chThdYield+0x22>
 8001802:	4803      	ldr	r0, [pc, #12]	; (8001810 <chThdYield+0x80>)
 8001804:	f7ff f80c 	bl	8000820 <chSysHalt>
 8001808:	20001e68 	.word	0x20001e68
 800180c:	0800c508 	.word	0x0800c508
 8001810:	0800a790 	.word	0x0800a790
	...

08001820 <chThdSleep>:
void chThdSleep(systime_t time) {
 8001820:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001822:	2320      	movs	r3, #32
 8001824:	4604      	mov	r4, r0
 8001826:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800182a:	f7ff fd19 	bl	8001260 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 800182e:	b1ac      	cbz	r4, 800185c <chThdSleep+0x3c>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8001830:	4621      	mov	r1, r4
 8001832:	2008      	movs	r0, #8
 8001834:	f7ff fb7c 	bl	8000f30 <chSchGoSleepTimeoutS>
  _dbg_check_unlock();
 8001838:	f7ff fcea 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800183c:	4b09      	ldr	r3, [pc, #36]	; (8001864 <chThdSleep+0x44>)
 800183e:	681a      	ldr	r2, [r3, #0]
 8001840:	429a      	cmp	r2, r3
 8001842:	d004      	beq.n	800184e <chThdSleep+0x2e>
 8001844:	6999      	ldr	r1, [r3, #24]
 8001846:	6893      	ldr	r3, [r2, #8]
 8001848:	688a      	ldr	r2, [r1, #8]
 800184a:	429a      	cmp	r2, r3
 800184c:	d303      	bcc.n	8001856 <chThdSleep+0x36>
 800184e:	2300      	movs	r3, #0
 8001850:	f383 8811 	msr	BASEPRI, r3
 8001854:	bd10      	pop	{r4, pc}
 8001856:	4804      	ldr	r0, [pc, #16]	; (8001868 <chThdSleep+0x48>)
 8001858:	f7fe ffe2 	bl	8000820 <chSysHalt>
  chDbgCheck(time != TIME_IMMEDIATE);
 800185c:	4803      	ldr	r0, [pc, #12]	; (800186c <chThdSleep+0x4c>)
 800185e:	f7fe ffdf 	bl	8000820 <chSysHalt>
 8001862:	bf00      	nop
 8001864:	20001e68 	.word	0x20001e68
 8001868:	0800c508 	.word	0x0800c508
 800186c:	0800b76c 	.word	0x0800b76c

08001870 <chThdSetPriority>:
  chDbgCheck(newprio <= HIGHPRIO);
 8001870:	28ff      	cmp	r0, #255	; 0xff
tprio_t chThdSetPriority(tprio_t newprio) {
 8001872:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck(newprio <= HIGHPRIO);
 8001874:	d823      	bhi.n	80018be <chThdSetPriority+0x4e>
 8001876:	4604      	mov	r4, r0
 8001878:	2320      	movs	r3, #32
 800187a:	f383 8811 	msr	BASEPRI, r3
  oldprio = currp->realprio;
 800187e:	4d11      	ldr	r5, [pc, #68]	; (80018c4 <chThdSetPriority+0x54>)
  _dbg_check_lock();
 8001880:	f7ff fcee 	bl	8001260 <_dbg_check_lock>
 8001884:	69ab      	ldr	r3, [r5, #24]
 8001886:	6bde      	ldr	r6, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 8001888:	689a      	ldr	r2, [r3, #8]
 800188a:	4296      	cmp	r6, r2
 800188c:	d001      	beq.n	8001892 <chThdSetPriority+0x22>
 800188e:	4294      	cmp	r4, r2
 8001890:	d900      	bls.n	8001894 <chThdSetPriority+0x24>
    currp->prio = newprio;
 8001892:	609c      	str	r4, [r3, #8]
  currp->realprio = newprio;
 8001894:	63dc      	str	r4, [r3, #60]	; 0x3c
  chSchRescheduleS();
 8001896:	f7ff f8c3 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 800189a:	f7ff fcb9 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800189e:	682b      	ldr	r3, [r5, #0]
 80018a0:	42ab      	cmp	r3, r5
 80018a2:	d004      	beq.n	80018ae <chThdSetPriority+0x3e>
 80018a4:	69aa      	ldr	r2, [r5, #24]
 80018a6:	689b      	ldr	r3, [r3, #8]
 80018a8:	6892      	ldr	r2, [r2, #8]
 80018aa:	429a      	cmp	r2, r3
 80018ac:	d304      	bcc.n	80018b8 <chThdSetPriority+0x48>
 80018ae:	2300      	movs	r3, #0
 80018b0:	f383 8811 	msr	BASEPRI, r3
}
 80018b4:	4630      	mov	r0, r6
 80018b6:	bd70      	pop	{r4, r5, r6, pc}
 80018b8:	4803      	ldr	r0, [pc, #12]	; (80018c8 <chThdSetPriority+0x58>)
 80018ba:	f7fe ffb1 	bl	8000820 <chSysHalt>
  chDbgCheck(newprio <= HIGHPRIO);
 80018be:	4803      	ldr	r0, [pc, #12]	; (80018cc <chThdSetPriority+0x5c>)
 80018c0:	f7fe ffae 	bl	8000820 <chSysHalt>
 80018c4:	20001e68 	.word	0x20001e68
 80018c8:	0800c508 	.word	0x0800c508
 80018cc:	0800a70c 	.word	0x0800a70c

080018d0 <chThdExit>:
void chThdExit(msg_t msg) {
 80018d0:	b508      	push	{r3, lr}
 80018d2:	4604      	mov	r4, r0
 80018d4:	2320      	movs	r3, #32
 80018d6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80018da:	f7ff fcc1 	bl	8001260 <_dbg_check_lock>
  chThdExitS(msg);
 80018de:	4620      	mov	r0, r4
 80018e0:	f7ff fa0e 	bl	8000d00 <chThdExitS>
	...

080018f0 <chThdRelease>:
void chThdRelease(thread_t *tp) {
 80018f0:	b570      	push	{r4, r5, r6, lr}
 80018f2:	2320      	movs	r3, #32
 80018f4:	4604      	mov	r4, r0
 80018f6:	f383 8811 	msr	BASEPRI, r3
 80018fa:	f7ff fcb1 	bl	8001260 <_dbg_check_lock>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80018fe:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8001902:	b1b3      	cbz	r3, 8001932 <chThdRelease+0x42>
  tp->refs--;
 8001904:	3b01      	subs	r3, #1
 8001906:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800190a:	6a23      	ldr	r3, [r4, #32]
 800190c:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8001910:	2b0f      	cmp	r3, #15
 8001912:	d014      	beq.n	800193e <chThdRelease+0x4e>
  _dbg_check_unlock();
 8001914:	f7ff fc7c 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001918:	4b25      	ldr	r3, [pc, #148]	; (80019b0 <chThdRelease+0xc0>)
 800191a:	681a      	ldr	r2, [r3, #0]
 800191c:	429a      	cmp	r2, r3
 800191e:	d004      	beq.n	800192a <chThdRelease+0x3a>
 8001920:	6999      	ldr	r1, [r3, #24]
 8001922:	6893      	ldr	r3, [r2, #8]
 8001924:	688a      	ldr	r2, [r1, #8]
 8001926:	429a      	cmp	r2, r3
 8001928:	d306      	bcc.n	8001938 <chThdRelease+0x48>
 800192a:	2300      	movs	r3, #0
 800192c:	f383 8811 	msr	BASEPRI, r3
 8001930:	bd70      	pop	{r4, r5, r6, pc}
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8001932:	4820      	ldr	r0, [pc, #128]	; (80019b4 <chThdRelease+0xc4>)
 8001934:	f7fe ff74 	bl	8000820 <chSysHalt>
 8001938:	481f      	ldr	r0, [pc, #124]	; (80019b8 <chThdRelease+0xc8>)
 800193a:	f7fe ff71 	bl	8000820 <chSysHalt>
    REG_REMOVE(tp);
 800193e:	6963      	ldr	r3, [r4, #20]
 8001940:	6922      	ldr	r2, [r4, #16]
 8001942:	611a      	str	r2, [r3, #16]
 8001944:	6922      	ldr	r2, [r4, #16]
 8001946:	4d1a      	ldr	r5, [pc, #104]	; (80019b0 <chThdRelease+0xc0>)
 8001948:	6153      	str	r3, [r2, #20]
  _dbg_check_unlock();
 800194a:	f7ff fc61 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800194e:	682b      	ldr	r3, [r5, #0]
 8001950:	42ab      	cmp	r3, r5
 8001952:	d004      	beq.n	800195e <chThdRelease+0x6e>
 8001954:	69aa      	ldr	r2, [r5, #24]
 8001956:	689b      	ldr	r3, [r3, #8]
 8001958:	6892      	ldr	r2, [r2, #8]
 800195a:	429a      	cmp	r2, r3
 800195c:	d3ec      	bcc.n	8001938 <chThdRelease+0x48>
 800195e:	2300      	movs	r3, #0
 8001960:	f383 8811 	msr	BASEPRI, r3
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8001964:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8001968:	f003 0303 	and.w	r3, r3, #3
 800196c:	2b01      	cmp	r3, #1
 800196e:	d01a      	beq.n	80019a6 <chThdRelease+0xb6>
 8001970:	2b02      	cmp	r3, #2
 8001972:	d117      	bne.n	80019a4 <chThdRelease+0xb4>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8001974:	6c26      	ldr	r6, [r4, #64]	; 0x40
 8001976:	69e4      	ldr	r4, [r4, #28]
 8001978:	2320      	movs	r3, #32
 800197a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800197e:	f7ff fc6f 	bl	8001260 <_dbg_check_lock>
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
 8001982:	4621      	mov	r1, r4
 8001984:	4630      	mov	r0, r6
 8001986:	f002 fee3 	bl	8004750 <chPoolFreeI>
  _dbg_check_unlock();
 800198a:	f7ff fc41 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800198e:	682b      	ldr	r3, [r5, #0]
 8001990:	42ab      	cmp	r3, r5
 8001992:	d0ca      	beq.n	800192a <chThdRelease+0x3a>
 8001994:	69aa      	ldr	r2, [r5, #24]
 8001996:	689b      	ldr	r3, [r3, #8]
 8001998:	6892      	ldr	r2, [r2, #8]
 800199a:	429a      	cmp	r2, r3
 800199c:	d2c5      	bcs.n	800192a <chThdRelease+0x3a>
 800199e:	4807      	ldr	r0, [pc, #28]	; (80019bc <chThdRelease+0xcc>)
 80019a0:	f7fe ff3e 	bl	8000820 <chSysHalt>
 80019a4:	bd70      	pop	{r4, r5, r6, pc}
      chHeapFree(chThdGetWorkingAreaX(tp));
 80019a6:	69e0      	ldr	r0, [r4, #28]
}
 80019a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      chHeapFree(chThdGetWorkingAreaX(tp));
 80019ac:	f002 bf30 	b.w	8004810 <chHeapFree>
 80019b0:	20001e68 	.word	0x20001e68
 80019b4:	0800a6e4 	.word	0x0800a6e4
 80019b8:	0800c508 	.word	0x0800c508
 80019bc:	0800a840 	.word	0x0800a840

080019c0 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 80019c0:	b570      	push	{r4, r5, r6, lr}
 80019c2:	2320      	movs	r3, #32
 80019c4:	4606      	mov	r6, r0
 80019c6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80019ca:	f7ff fc49 	bl	8001260 <_dbg_check_lock>
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 80019ce:	4c12      	ldr	r4, [pc, #72]	; (8001a18 <chRegNextThread+0x58>)
  ntp = tp->newer;
 80019d0:	6935      	ldr	r5, [r6, #16]
  if (ntp == (thread_t *)&ch.rlist) {
 80019d2:	42a5      	cmp	r5, r4
 80019d4:	d01e      	beq.n	8001a14 <chRegNextThread+0x54>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 80019d6:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 80019da:	2bff      	cmp	r3, #255	; 0xff
 80019dc:	d017      	beq.n	8001a0e <chRegNextThread+0x4e>
    ntp->refs++;
 80019de:	3301      	adds	r3, #1
 80019e0:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
  _dbg_check_unlock();
 80019e4:	f7ff fc14 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80019e8:	6823      	ldr	r3, [r4, #0]
 80019ea:	42a3      	cmp	r3, r4
 80019ec:	d004      	beq.n	80019f8 <chRegNextThread+0x38>
 80019ee:	69a2      	ldr	r2, [r4, #24]
 80019f0:	689b      	ldr	r3, [r3, #8]
 80019f2:	6892      	ldr	r2, [r2, #8]
 80019f4:	429a      	cmp	r2, r3
 80019f6:	d307      	bcc.n	8001a08 <chRegNextThread+0x48>
 80019f8:	2300      	movs	r3, #0
 80019fa:	f383 8811 	msr	BASEPRI, r3
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80019fe:	4630      	mov	r0, r6
 8001a00:	f7ff ff76 	bl	80018f0 <chThdRelease>
#endif

  return ntp;
}
 8001a04:	4628      	mov	r0, r5
 8001a06:	bd70      	pop	{r4, r5, r6, pc}
 8001a08:	4804      	ldr	r0, [pc, #16]	; (8001a1c <chRegNextThread+0x5c>)
 8001a0a:	f7fe ff09 	bl	8000820 <chSysHalt>
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8001a0e:	4804      	ldr	r0, [pc, #16]	; (8001a20 <chRegNextThread+0x60>)
 8001a10:	f7fe ff06 	bl	8000820 <chSysHalt>
    ntp = NULL;
 8001a14:	2500      	movs	r5, #0
 8001a16:	e7e5      	b.n	80019e4 <chRegNextThread+0x24>
 8001a18:	20001e68 	.word	0x20001e68
 8001a1c:	0800ae5c 	.word	0x0800ae5c
 8001a20:	0800a720 	.word	0x0800a720
	...

08001a30 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8001a30:	b530      	push	{r4, r5, lr}
 8001a32:	2320      	movs	r3, #32
 8001a34:	b083      	sub	sp, #12
 8001a36:	4604      	mov	r4, r0
 8001a38:	f383 8811 	msr	BASEPRI, r3
  tp = ch.rlist.newer;
 8001a3c:	4d11      	ldr	r5, [pc, #68]	; (8001a84 <chRegFindThreadByWorkingArea+0x54>)
  _dbg_check_lock();
 8001a3e:	f7ff fc0f 	bl	8001260 <_dbg_check_lock>
 8001a42:	6928      	ldr	r0, [r5, #16]
  tp->refs++;
 8001a44:	9001      	str	r0, [sp, #4]
 8001a46:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 8001a4a:	3301      	adds	r3, #1
 8001a4c:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
  _dbg_check_unlock();
 8001a50:	f7ff fbde 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001a54:	682b      	ldr	r3, [r5, #0]
 8001a56:	9801      	ldr	r0, [sp, #4]
 8001a58:	42ab      	cmp	r3, r5
 8001a5a:	d004      	beq.n	8001a66 <chRegFindThreadByWorkingArea+0x36>
 8001a5c:	69aa      	ldr	r2, [r5, #24]
 8001a5e:	689b      	ldr	r3, [r3, #8]
 8001a60:	6892      	ldr	r2, [r2, #8]
 8001a62:	429a      	cmp	r2, r3
 8001a64:	d30b      	bcc.n	8001a7e <chRegFindThreadByWorkingArea+0x4e>
 8001a66:	2300      	movs	r3, #0
 8001a68:	f383 8811 	msr	BASEPRI, r3
 8001a6c:	e002      	b.n	8001a74 <chRegFindThreadByWorkingArea+0x44>
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
 8001a6e:	f7ff ffa7 	bl	80019c0 <chRegNextThread>
  } while (ctp != NULL);
 8001a72:	b110      	cbz	r0, 8001a7a <chRegFindThreadByWorkingArea+0x4a>
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8001a74:	69c3      	ldr	r3, [r0, #28]
 8001a76:	429c      	cmp	r4, r3
 8001a78:	d1f9      	bne.n	8001a6e <chRegFindThreadByWorkingArea+0x3e>

  return NULL;
}
 8001a7a:	b003      	add	sp, #12
 8001a7c:	bd30      	pop	{r4, r5, pc}
 8001a7e:	4802      	ldr	r0, [pc, #8]	; (8001a88 <chRegFindThreadByWorkingArea+0x58>)
 8001a80:	f7fe fece 	bl	8000820 <chSysHalt>
 8001a84:	20001e68 	.word	0x20001e68
 8001a88:	0800ae5c 	.word	0x0800ae5c
 8001a8c:	00000000 	.word	0x00000000

08001a90 <chThdWait>:
msg_t chThdWait(thread_t *tp) {
 8001a90:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck(tp != NULL);
 8001a92:	b360      	cbz	r0, 8001aee <chThdWait+0x5e>
 8001a94:	4604      	mov	r4, r0
 8001a96:	2320      	movs	r3, #32
 8001a98:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp != currp, "waiting self");
 8001a9c:	4d15      	ldr	r5, [pc, #84]	; (8001af4 <chThdWait+0x64>)
  _dbg_check_lock();
 8001a9e:	f7ff fbdf 	bl	8001260 <_dbg_check_lock>
 8001aa2:	69ab      	ldr	r3, [r5, #24]
 8001aa4:	429c      	cmp	r4, r3
 8001aa6:	d022      	beq.n	8001aee <chThdWait+0x5e>
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
 8001aa8:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
 8001aac:	b1fa      	cbz	r2, 8001aee <chThdWait+0x5e>
  if (tp->state != CH_STATE_FINAL) {
 8001aae:	f894 2020 	ldrb.w	r2, [r4, #32]
 8001ab2:	2a0f      	cmp	r2, #15
 8001ab4:	d005      	beq.n	8001ac2 <chThdWait+0x32>
  tp->queue.next = tlp->next;
 8001ab6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001ab8:	601a      	str	r2, [r3, #0]
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001aba:	2009      	movs	r0, #9
  tlp->next = tp;
 8001abc:	62a3      	str	r3, [r4, #40]	; 0x28
 8001abe:	f7fe fed7 	bl	8000870 <chSchGoSleepS>
  msg = tp->u.exitcode;
 8001ac2:	6a66      	ldr	r6, [r4, #36]	; 0x24
  _dbg_check_unlock();
 8001ac4:	f7ff fba4 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001ac8:	682b      	ldr	r3, [r5, #0]
 8001aca:	42ab      	cmp	r3, r5
 8001acc:	d004      	beq.n	8001ad8 <chThdWait+0x48>
 8001ace:	69aa      	ldr	r2, [r5, #24]
 8001ad0:	689b      	ldr	r3, [r3, #8]
 8001ad2:	6892      	ldr	r2, [r2, #8]
 8001ad4:	429a      	cmp	r2, r3
 8001ad6:	d307      	bcc.n	8001ae8 <chThdWait+0x58>
 8001ad8:	2300      	movs	r3, #0
 8001ada:	f383 8811 	msr	BASEPRI, r3
  chThdRelease(tp);
 8001ade:	4620      	mov	r0, r4
 8001ae0:	f7ff ff06 	bl	80018f0 <chThdRelease>
}
 8001ae4:	4630      	mov	r0, r6
 8001ae6:	bd70      	pop	{r4, r5, r6, pc}
 8001ae8:	4803      	ldr	r0, [pc, #12]	; (8001af8 <chThdWait+0x68>)
 8001aea:	f7fe fe99 	bl	8000820 <chSysHalt>
  chDbgCheck(tp != NULL);
 8001aee:	4803      	ldr	r0, [pc, #12]	; (8001afc <chThdWait+0x6c>)
 8001af0:	f7fe fe96 	bl	8000820 <chSysHalt>
 8001af4:	20001e68 	.word	0x20001e68
 8001af8:	0800c508 	.word	0x0800c508
 8001afc:	0800a700 	.word	0x0800a700

08001b00 <chSysGetStatusAndLockX.part.1>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001b00:	f3ef 8305 	mrs	r3, IPSR
  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 8001b04:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (port_is_isr_context()) {
 8001b08:	b923      	cbnz	r3, 8001b14 <chSysGetStatusAndLockX.part.1+0x14>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001b0a:	2320      	movs	r3, #32
 8001b0c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8001b10:	f7ff bba6 	b.w	8001260 <_dbg_check_lock>
 8001b14:	2320      	movs	r3, #32
 8001b16:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8001b1a:	f7ff bb29 	b.w	8001170 <_dbg_check_lock_from_isr>
 8001b1e:	bf00      	nop

08001b20 <_dbg_check_enable>:
void _dbg_check_enable(void) {
 8001b20:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001b22:	4b04      	ldr	r3, [pc, #16]	; (8001b34 <_dbg_check_enable+0x14>)
 8001b24:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001b26:	b90a      	cbnz	r2, 8001b2c <_dbg_check_enable+0xc>
 8001b28:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001b2a:	b113      	cbz	r3, 8001b32 <_dbg_check_enable+0x12>
    chSysHalt("SV#3");
 8001b2c:	4802      	ldr	r0, [pc, #8]	; (8001b38 <_dbg_check_enable+0x18>)
 8001b2e:	f7fe fe77 	bl	8000820 <chSysHalt>
 8001b32:	bd08      	pop	{r3, pc}
 8001b34:	20001e68 	.word	0x20001e68
 8001b38:	0800a740 	.word	0x0800a740
 8001b3c:	00000000 	.word	0x00000000

08001b40 <_dbg_check_suspend>:
void _dbg_check_suspend(void) {
 8001b40:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001b42:	4b04      	ldr	r3, [pc, #16]	; (8001b54 <_dbg_check_suspend+0x14>)
 8001b44:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001b46:	b90a      	cbnz	r2, 8001b4c <_dbg_check_suspend+0xc>
 8001b48:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001b4a:	b113      	cbz	r3, 8001b52 <_dbg_check_suspend+0x12>
    chSysHalt("SV#2");
 8001b4c:	4802      	ldr	r0, [pc, #8]	; (8001b58 <_dbg_check_suspend+0x18>)
 8001b4e:	f7fe fe67 	bl	8000820 <chSysHalt>
 8001b52:	bd08      	pop	{r3, pc}
 8001b54:	20001e68 	.word	0x20001e68
 8001b58:	0800a768 	.word	0x0800a768
 8001b5c:	00000000 	.word	0x00000000

08001b60 <chSysRestoreStatusX.part.2>:
void chSysRestoreStatusX(syssts_t sts) {
 8001b60:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001b62:	f3ef 8305 	mrs	r3, IPSR
 8001b66:	f3c3 0308 	ubfx	r3, r3, #0, #9
    if (port_is_isr_context()) {
 8001b6a:	b983      	cbnz	r3, 8001b8e <chSysRestoreStatusX.part.2+0x2e>
      chSchRescheduleS();
 8001b6c:	f7fe ff58 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8001b70:	f7ff fb4e 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001b74:	4b0a      	ldr	r3, [pc, #40]	; (8001ba0 <chSysRestoreStatusX.part.2+0x40>)
 8001b76:	681a      	ldr	r2, [r3, #0]
 8001b78:	429a      	cmp	r2, r3
 8001b7a:	d004      	beq.n	8001b86 <chSysRestoreStatusX.part.2+0x26>
 8001b7c:	6999      	ldr	r1, [r3, #24]
 8001b7e:	6893      	ldr	r3, [r2, #8]
 8001b80:	688a      	ldr	r2, [r1, #8]
 8001b82:	429a      	cmp	r2, r3
 8001b84:	d309      	bcc.n	8001b9a <chSysRestoreStatusX.part.2+0x3a>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001b86:	2300      	movs	r3, #0
 8001b88:	f383 8811 	msr	BASEPRI, r3
 8001b8c:	bd08      	pop	{r3, pc}
  _dbg_check_unlock_from_isr();
 8001b8e:	f7ff fad7 	bl	8001140 <_dbg_check_unlock_from_isr>
 8001b92:	2300      	movs	r3, #0
 8001b94:	f383 8811 	msr	BASEPRI, r3
 8001b98:	bd08      	pop	{r3, pc}
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001b9a:	4802      	ldr	r0, [pc, #8]	; (8001ba4 <chSysRestoreStatusX.part.2+0x44>)
 8001b9c:	f7fe fe40 	bl	8000820 <chSysHalt>
 8001ba0:	20001e68 	.word	0x20001e68
 8001ba4:	0800a5a4 	.word	0x0800a5a4
	...

08001bb0 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 8001bb0:	e7fe      	b.n	8001bb0 <BusFault_Handler>
 8001bb2:	bf00      	nop
	...

08001bc0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001bc0:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001bc2:	4f12      	ldr	r7, [pc, #72]	; (8001c0c <__init_ram_areas+0x4c>)
void __init_ram_areas(void) {
 8001bc4:	4d12      	ldr	r5, [pc, #72]	; (8001c10 <__init_ram_areas+0x50>)
 8001bc6:	4c13      	ldr	r4, [pc, #76]	; (8001c14 <__init_ram_areas+0x54>)
 8001bc8:	4b13      	ldr	r3, [pc, #76]	; (8001c18 <__init_ram_areas+0x58>)
 8001bca:	4914      	ldr	r1, [pc, #80]	; (8001c1c <__init_ram_areas+0x5c>)
 8001bcc:	f107 0e80 	add.w	lr, r7, #128	; 0x80
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001bd0:	2600      	movs	r6, #0
    while (p < rap->clear_area) {
 8001bd2:	429c      	cmp	r4, r3
 8001bd4:	d911      	bls.n	8001bfa <__init_ram_areas+0x3a>
 8001bd6:	3904      	subs	r1, #4
 8001bd8:	461a      	mov	r2, r3
      *p = *tp;
 8001bda:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8001bde:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
 8001be2:	4294      	cmp	r4, r2
 8001be4:	d8f9      	bhi.n	8001bda <__init_ram_areas+0x1a>
 8001be6:	43da      	mvns	r2, r3
 8001be8:	4414      	add	r4, r2
 8001bea:	f024 0403 	bic.w	r4, r4, #3
 8001bee:	3404      	adds	r4, #4
 8001bf0:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
 8001bf2:	429d      	cmp	r5, r3
 8001bf4:	d903      	bls.n	8001bfe <__init_ram_areas+0x3e>
      *p = 0;
 8001bf6:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
 8001bfa:	429d      	cmp	r5, r3
 8001bfc:	d8fb      	bhi.n	8001bf6 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
 8001bfe:	3710      	adds	r7, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001c00:	4577      	cmp	r7, lr
 8001c02:	d202      	bcs.n	8001c0a <__init_ram_areas+0x4a>
 8001c04:	e897 003a 	ldmia.w	r7, {r1, r3, r4, r5}
 8001c08:	e7e3      	b.n	8001bd2 <__init_ram_areas+0x12>
 8001c0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001c0c:	0800a7a0 	.word	0x0800a7a0
 8001c10:	20002738 	.word	0x20002738
 8001c14:	20002738 	.word	0x20002738
 8001c18:	20002738 	.word	0x20002738
 8001c1c:	0800ca3c 	.word	0x0800ca3c

08001c20 <__default_exit>:
void __default_exit(void) {
 8001c20:	e7fe      	b.n	8001c20 <__default_exit>
 8001c22:	bf00      	nop
	...

08001c30 <__late_init>:
 8001c30:	4770      	bx	lr
 8001c32:	bf00      	nop
	...

08001c40 <__core_init>:
void __core_init(void) {
 8001c40:	4770      	bx	lr
 8001c42:	bf00      	nop
	...

08001c50 <Thread1>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8001c50:	4b0e      	ldr	r3, [pc, #56]	; (8001c8c <Thread1+0x3c>)
 8001c52:	4a0f      	ldr	r2, [pc, #60]	; (8001c90 <Thread1+0x40>)
 8001c54:	699b      	ldr	r3, [r3, #24]
 8001c56:	f8df 8040 	ldr.w	r8, [pc, #64]	; 8001c98 <Thread1+0x48>
  while (true) {
    systime_t time;

    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
#if defined(BOARD_ST_STM32F4_DISCOVERY)
    palClearLine(LINE_LED4);
 8001c5a:	4d0e      	ldr	r5, [pc, #56]	; (8001c94 <Thread1+0x44>)
 8001c5c:	f44f 5680 	mov.w	r6, #4096	; 0x1000
static THD_FUNCTION(Thread1, arg) {
 8001c60:	b580      	push	{r7, lr}
 8001c62:	619a      	str	r2, [r3, #24]
    palClearLine(LINE_LED4);
 8001c64:	4637      	mov	r7, r6
    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
 8001c66:	f898 2000 	ldrb.w	r2, [r8]
    palClearLine(LINE_LED4);
 8001c6a:	836f      	strh	r7, [r5, #26]
    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
 8001c6c:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001c70:	f241 3488 	movw	r4, #5000	; 0x1388
 8001c74:	2a04      	cmp	r2, #4
 8001c76:	bf08      	it	eq
 8001c78:	461c      	moveq	r4, r3
    chThdSleepMilliseconds(time);
 8001c7a:	4620      	mov	r0, r4
 8001c7c:	f7ff fdd0 	bl	8001820 <chThdSleep>
    palSetLine(LINE_LED4);
    chThdSleepMilliseconds(time);
 8001c80:	4620      	mov	r0, r4
    palSetLine(LINE_LED4);
 8001c82:	832e      	strh	r6, [r5, #24]
    chThdSleepMilliseconds(time);
 8001c84:	f7ff fdcc 	bl	8001820 <chThdSleep>
 8001c88:	e7ed      	b.n	8001c66 <Thread1+0x16>
 8001c8a:	bf00      	nop
 8001c8c:	20001e68 	.word	0x20001e68
 8001c90:	0800a820 	.word	0x0800a820
 8001c94:	40020c00 	.word	0x40020c00
 8001c98:	20001118 	.word	0x20001118
 8001c9c:	00000000 	.word	0x00000000

08001ca0 <cmd_write>:
  if (argc > 0) {
 8001ca0:	2900      	cmp	r1, #0
 8001ca2:	dc18      	bgt.n	8001cd6 <cmd_write+0x36>
static void cmd_write(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001ca4:	b570      	push	{r4, r5, r6, lr}
 8001ca6:	4604      	mov	r4, r0
    chnWrite(&SDU1, buf, sizeof buf - 1);
 8001ca8:	4e0c      	ldr	r6, [pc, #48]	; (8001cdc <cmd_write+0x3c>)
 8001caa:	4d0d      	ldr	r5, [pc, #52]	; (8001ce0 <cmd_write+0x40>)
 8001cac:	e002      	b.n	8001cb4 <cmd_write+0x14>
 8001cae:	6833      	ldr	r3, [r6, #0]
 8001cb0:	681b      	ldr	r3, [r3, #0]
 8001cb2:	4798      	blx	r3
  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 8001cb4:	6823      	ldr	r3, [r4, #0]
 8001cb6:	2100      	movs	r1, #0
 8001cb8:	695b      	ldr	r3, [r3, #20]
 8001cba:	4620      	mov	r0, r4
 8001cbc:	4798      	blx	r3
 8001cbe:	3001      	adds	r0, #1
    chnWrite(&SDU1, buf, sizeof buf - 1);
 8001cc0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001cc4:	4629      	mov	r1, r5
 8001cc6:	4805      	ldr	r0, [pc, #20]	; (8001cdc <cmd_write+0x3c>)
  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 8001cc8:	d0f1      	beq.n	8001cae <cmd_write+0xe>
  chprintf(chp, "\r\n\nstopped\r\n");
 8001cca:	4620      	mov	r0, r4
 8001ccc:	4905      	ldr	r1, [pc, #20]	; (8001ce4 <cmd_write+0x44>)
}
 8001cce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chprintf(chp, "\r\n\nstopped\r\n");
 8001cd2:	f004 b8ad 	b.w	8005e30 <chprintf>
    chprintf(chp, "Usage: write\r\n");
 8001cd6:	4904      	ldr	r1, [pc, #16]	; (8001ce8 <cmd_write+0x48>)
 8001cd8:	f004 b8aa 	b.w	8005e30 <chprintf>
 8001cdc:	20000c88 	.word	0x20000c88
 8001ce0:	20000800 	.word	0x20000800
 8001ce4:	0800a8c0 	.word	0x0800a8c0
 8001ce8:	0800a8d0 	.word	0x0800a8d0
 8001cec:	00000000 	.word	0x00000000

08001cf0 <chMBPostI.constprop.31>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8001cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8001cf2:	4c13      	ldr	r4, [pc, #76]	; (8001d40 <chMBPostI.constprop.31+0x50>)
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8001cf4:	4607      	mov	r7, r0
  chDbgCheckClassI();
 8001cf6:	f7fe fde3 	bl	80008c0 <chDbgCheckClassI>
  if (mbp->reset) {
 8001cfa:	7d23      	ldrb	r3, [r4, #20]
 8001cfc:	b9d3      	cbnz	r3, 8001d34 <chMBPostI.constprop.31+0x44>
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();
 8001cfe:	f7fe fddf 	bl	80008c0 <chDbgCheckClassI>
 8001d02:	6826      	ldr	r6, [r4, #0]
 8001d04:	6865      	ldr	r5, [r4, #4]
  chDbgCheckClassI();
 8001d06:	f7fe fddb 	bl	80008c0 <chDbgCheckClassI>

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8001d0a:	6923      	ldr	r3, [r4, #16]
  return (cnt_t)(mbp->top - mbp->buffer);
 8001d0c:	1baa      	subs	r2, r5, r6
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8001d0e:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8001d12:	2b00      	cmp	r3, #0
 8001d14:	dd11      	ble.n	8001d3a <chMBPostI.constprop.31+0x4a>
    *mbp->wrptr++ = msg;
 8001d16:	68a2      	ldr	r2, [r4, #8]
      mbp->wrptr = mbp->buffer;
    }
    mbp->cnt++;

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001d18:	480a      	ldr	r0, [pc, #40]	; (8001d44 <chMBPostI.constprop.31+0x54>)
    *mbp->wrptr++ = msg;
 8001d1a:	1d13      	adds	r3, r2, #4
 8001d1c:	60a3      	str	r3, [r4, #8]
 8001d1e:	6017      	str	r7, [r2, #0]
    if (mbp->wrptr >= mbp->top) {
 8001d20:	429d      	cmp	r5, r3
    mbp->cnt++;
 8001d22:	6923      	ldr	r3, [r4, #16]
      mbp->wrptr = mbp->buffer;
 8001d24:	bf98      	it	ls
 8001d26:	60a6      	strls	r6, [r4, #8]
    mbp->cnt++;
 8001d28:	3301      	adds	r3, #1
 8001d2a:	6123      	str	r3, [r4, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001d2c:	f008 f828 	bl	8009d80 <chThdDequeueNextI.constprop.69>

    return MSG_OK;
 8001d30:	2000      	movs	r0, #0
 8001d32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return MSG_RESET;
 8001d34:	f06f 0001 	mvn.w	r0, #1
 8001d38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 8001d3a:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001d3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001d40:	20000c60 	.word	0x20000c60
 8001d44:	20000c80 	.word	0x20000c80
	...

08001d50 <chMBPostAheadI.constprop.28>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8001d50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8001d52:	4c13      	ldr	r4, [pc, #76]	; (8001da0 <chMBPostAheadI.constprop.28+0x50>)
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8001d54:	4607      	mov	r7, r0
  chDbgCheckClassI();
 8001d56:	f7fe fdb3 	bl	80008c0 <chDbgCheckClassI>
  if (mbp->reset) {
 8001d5a:	7d23      	ldrb	r3, [r4, #20]
 8001d5c:	b9d3      	cbnz	r3, 8001d94 <chMBPostAheadI.constprop.28+0x44>
  chDbgCheckClassI();
 8001d5e:	f7fe fdaf 	bl	80008c0 <chDbgCheckClassI>
 8001d62:	e894 0060 	ldmia.w	r4, {r5, r6}
  chDbgCheckClassI();
 8001d66:	f7fe fdab 	bl	80008c0 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8001d6a:	6923      	ldr	r3, [r4, #16]
  return (cnt_t)(mbp->top - mbp->buffer);
 8001d6c:	1b72      	subs	r2, r6, r5
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8001d6e:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8001d72:	2b00      	cmp	r3, #0
 8001d74:	dd11      	ble.n	8001d9a <chMBPostAheadI.constprop.28+0x4a>
    if (--mbp->rdptr < mbp->buffer) {
 8001d76:	68e3      	ldr	r3, [r4, #12]
    }
    *mbp->rdptr = msg;
    mbp->cnt++;

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001d78:	480a      	ldr	r0, [pc, #40]	; (8001da4 <chMBPostAheadI.constprop.28+0x54>)
    if (--mbp->rdptr < mbp->buffer) {
 8001d7a:	3b04      	subs	r3, #4
 8001d7c:	429d      	cmp	r5, r3
      mbp->rdptr = mbp->top - 1;
 8001d7e:	bf88      	it	hi
 8001d80:	1f33      	subhi	r3, r6, #4
 8001d82:	60e3      	str	r3, [r4, #12]
    *mbp->rdptr = msg;
 8001d84:	601f      	str	r7, [r3, #0]
    mbp->cnt++;
 8001d86:	6923      	ldr	r3, [r4, #16]
 8001d88:	3301      	adds	r3, #1
 8001d8a:	6123      	str	r3, [r4, #16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001d8c:	f007 fff8 	bl	8009d80 <chThdDequeueNextI.constprop.69>

    return MSG_OK;
 8001d90:	2000      	movs	r0, #0
 8001d92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return MSG_RESET;
 8001d94:	f06f 0001 	mvn.w	r0, #1
 8001d98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 8001d9a:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001d9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001da0:	20000c60 	.word	0x20000c60
 8001da4:	20000c80 	.word	0x20000c80
	...

08001db0 <chMBFetchI.constprop.25>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8001db0:	b538      	push	{r3, r4, r5, lr}
 8001db2:	4605      	mov	r5, r0

  chDbgCheckClassI();
 8001db4:	f7fe fd84 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8001db8:	b1cd      	cbz	r5, 8001dee <chMBFetchI.constprop.25+0x3e>

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8001dba:	4c11      	ldr	r4, [pc, #68]	; (8001e00 <chMBFetchI.constprop.25+0x50>)
 8001dbc:	7d23      	ldrb	r3, [r4, #20]
 8001dbe:	b9cb      	cbnz	r3, 8001df4 <chMBFetchI.constprop.25+0x44>
  chDbgCheckClassI();
 8001dc0:	f7fe fd7e 	bl	80008c0 <chDbgCheckClassI>
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
 8001dc4:	6923      	ldr	r3, [r4, #16]
 8001dc6:	2b00      	cmp	r3, #0
 8001dc8:	dd17      	ble.n	8001dfa <chMBFetchI.constprop.25+0x4a>
    *msgp = *mbp->rdptr++;
 8001dca:	68e3      	ldr	r3, [r4, #12]
    if (mbp->rdptr >= mbp->top) {
 8001dcc:	6862      	ldr	r2, [r4, #4]
    *msgp = *mbp->rdptr++;
 8001dce:	6819      	ldr	r1, [r3, #0]
      mbp->rdptr = mbp->buffer;
    }
    mbp->cnt--;

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8001dd0:	480c      	ldr	r0, [pc, #48]	; (8001e04 <chMBFetchI.constprop.25+0x54>)
    *msgp = *mbp->rdptr++;
 8001dd2:	3304      	adds	r3, #4
    if (mbp->rdptr >= mbp->top) {
 8001dd4:	4293      	cmp	r3, r2
    *msgp = *mbp->rdptr++;
 8001dd6:	60e3      	str	r3, [r4, #12]
 8001dd8:	6029      	str	r1, [r5, #0]
      mbp->rdptr = mbp->buffer;
 8001dda:	bf24      	itt	cs
 8001ddc:	6823      	ldrcs	r3, [r4, #0]
 8001dde:	60e3      	strcs	r3, [r4, #12]
    mbp->cnt--;
 8001de0:	6923      	ldr	r3, [r4, #16]
 8001de2:	3b01      	subs	r3, #1
 8001de4:	6123      	str	r3, [r4, #16]
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8001de6:	f007 ffcb 	bl	8009d80 <chThdDequeueNextI.constprop.69>

    return MSG_OK;
 8001dea:	2000      	movs	r0, #0
 8001dec:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8001dee:	4806      	ldr	r0, [pc, #24]	; (8001e08 <chMBFetchI.constprop.25+0x58>)
 8001df0:	f7fe fd16 	bl	8000820 <chSysHalt>
    return MSG_RESET;
 8001df4:	f06f 0001 	mvn.w	r0, #1
 8001df8:	bd38      	pop	{r3, r4, r5, pc}
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
 8001dfa:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001dfe:	bd38      	pop	{r3, r4, r5, pc}
 8001e00:	20000c60 	.word	0x20000c60
 8001e04:	20000c78 	.word	0x20000c78
 8001e08:	0800a870 	.word	0x0800a870
 8001e0c:	00000000 	.word	0x00000000

08001e10 <_test_assert_time_window.constprop.3>:
  return (systime_t)STM32_ST_TIM->CNT;
 8001e10:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8001e14:	1a09      	subs	r1, r1, r0
 8001e16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001e18:	1a1b      	subs	r3, r3, r0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 8001e1a:	428b      	cmp	r3, r1
 8001e1c:	d308      	bcc.n	8001e30 <_test_assert_time_window.constprop.3+0x20>
  test_failure_message = msg;
 8001e1e:	4905      	ldr	r1, [pc, #20]	; (8001e34 <_test_assert_time_window.constprop.3+0x24>)
  test_local_fail      = true;
 8001e20:	4a05      	ldr	r2, [pc, #20]	; (8001e38 <_test_assert_time_window.constprop.3+0x28>)
  test_global_fail     = true;
 8001e22:	4b06      	ldr	r3, [pc, #24]	; (8001e3c <_test_assert_time_window.constprop.3+0x2c>)
  test_failure_message = msg;
 8001e24:	4806      	ldr	r0, [pc, #24]	; (8001e40 <_test_assert_time_window.constprop.3+0x30>)
 8001e26:	6008      	str	r0, [r1, #0]
  test_local_fail      = true;
 8001e28:	2001      	movs	r0, #1
 8001e2a:	7010      	strb	r0, [r2, #0]
  test_global_fail     = true;
 8001e2c:	7018      	strb	r0, [r3, #0]
 8001e2e:	4770      	bx	lr
    return _test_fail(msg);
  return false;
 8001e30:	2000      	movs	r0, #0
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
 8001e32:	4770      	bx	lr
 8001e34:	2000159c 	.word	0x2000159c
 8001e38:	200015a1 	.word	0x200015a1
 8001e3c:	200015a0 	.word	0x200015a0
 8001e40:	0800a894 	.word	0x0800a894
	...

08001e50 <chMBFetch.constprop.26>:
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8001e50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001e54:	2320      	movs	r3, #32
 8001e56:	4680      	mov	r8, r0
 8001e58:	460e      	mov	r6, r1
 8001e5a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8001e5e:	f7ff f9ff 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassS();
 8001e62:	f7fe fcf5 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8001e66:	f1b8 0f00 	cmp.w	r8, #0
 8001e6a:	d03c      	beq.n	8001ee6 <chMBFetch.constprop.26+0x96>
 8001e6c:	4c1f      	ldr	r4, [pc, #124]	; (8001eec <chMBFetch.constprop.26+0x9c>)
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8001e6e:	f104 0720 	add.w	r7, r4, #32
 8001e72:	e00a      	b.n	8001e8a <chMBFetch.constprop.26+0x3a>
 8001e74:	f7fe fd24 	bl	80008c0 <chDbgCheckClassI>
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
 8001e78:	6923      	ldr	r3, [r4, #16]
 8001e7a:	2b00      	cmp	r3, #0
 8001e7c:	dc1e      	bgt.n	8001ebc <chMBFetch.constprop.26+0x6c>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8001e7e:	4631      	mov	r1, r6
 8001e80:	4638      	mov	r0, r7
 8001e82:	f7ff f8b5 	bl	8000ff0 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8001e86:	4605      	mov	r5, r0
 8001e88:	b920      	cbnz	r0, 8001e94 <chMBFetch.constprop.26+0x44>
    if (mbp->reset) {
 8001e8a:	7d23      	ldrb	r3, [r4, #20]
 8001e8c:	2b00      	cmp	r3, #0
 8001e8e:	d0f1      	beq.n	8001e74 <chMBFetch.constprop.26+0x24>
      return MSG_RESET;
 8001e90:	f06f 0501 	mvn.w	r5, #1
  _dbg_check_unlock();
 8001e94:	f7ff f9bc 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001e98:	4b15      	ldr	r3, [pc, #84]	; (8001ef0 <chMBFetch.constprop.26+0xa0>)
 8001e9a:	681a      	ldr	r2, [r3, #0]
 8001e9c:	429a      	cmp	r2, r3
 8001e9e:	d004      	beq.n	8001eaa <chMBFetch.constprop.26+0x5a>
 8001ea0:	6999      	ldr	r1, [r3, #24]
 8001ea2:	6893      	ldr	r3, [r2, #8]
 8001ea4:	688a      	ldr	r2, [r1, #8]
 8001ea6:	429a      	cmp	r2, r3
 8001ea8:	d305      	bcc.n	8001eb6 <chMBFetch.constprop.26+0x66>
 8001eaa:	2300      	movs	r3, #0
 8001eac:	f383 8811 	msr	BASEPRI, r3
}
 8001eb0:	4628      	mov	r0, r5
 8001eb2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001eb6:	480f      	ldr	r0, [pc, #60]	; (8001ef4 <chMBFetch.constprop.26+0xa4>)
 8001eb8:	f7fe fcb2 	bl	8000820 <chSysHalt>
      *msgp = *mbp->rdptr++;
 8001ebc:	68e3      	ldr	r3, [r4, #12]
      if (mbp->rdptr >= mbp->top) {
 8001ebe:	6862      	ldr	r2, [r4, #4]
      *msgp = *mbp->rdptr++;
 8001ec0:	6819      	ldr	r1, [r3, #0]
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8001ec2:	480d      	ldr	r0, [pc, #52]	; (8001ef8 <chMBFetch.constprop.26+0xa8>)
      *msgp = *mbp->rdptr++;
 8001ec4:	3304      	adds	r3, #4
      if (mbp->rdptr >= mbp->top) {
 8001ec6:	4293      	cmp	r3, r2
      *msgp = *mbp->rdptr++;
 8001ec8:	60e3      	str	r3, [r4, #12]
 8001eca:	f8c8 1000 	str.w	r1, [r8]
        mbp->rdptr = mbp->buffer;
 8001ece:	bf24      	itt	cs
 8001ed0:	6823      	ldrcs	r3, [r4, #0]
 8001ed2:	60e3      	strcs	r3, [r4, #12]
      mbp->cnt--;
 8001ed4:	6923      	ldr	r3, [r4, #16]
 8001ed6:	3b01      	subs	r3, #1
 8001ed8:	6123      	str	r3, [r4, #16]
      chSchRescheduleS();
 8001eda:	2500      	movs	r5, #0
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8001edc:	f007 ff50 	bl	8009d80 <chThdDequeueNextI.constprop.69>
      chSchRescheduleS();
 8001ee0:	f7fe fd9e 	bl	8000a20 <chSchRescheduleS>
 8001ee4:	e7d6      	b.n	8001e94 <chMBFetch.constprop.26+0x44>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8001ee6:	4805      	ldr	r0, [pc, #20]	; (8001efc <chMBFetch.constprop.26+0xac>)
 8001ee8:	f7fe fc9a 	bl	8000820 <chSysHalt>
 8001eec:	20000c60 	.word	0x20000c60
 8001ef0:	20001e68 	.word	0x20001e68
 8001ef4:	0800a834 	.word	0x0800a834
 8001ef8:	20000c78 	.word	0x20000c78
 8001efc:	0800a864 	.word	0x0800a864

08001f00 <chMBReset.constprop.34>:
void chMBReset(mailbox_t *mbp) {
 8001f00:	b508      	push	{r3, lr}
 8001f02:	2320      	movs	r3, #32
 8001f04:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8001f08:	f7ff f9aa 	bl	8001260 <_dbg_check_lock>
  chMBResetI(mbp);
 8001f0c:	f008 f818 	bl	8009f40 <chMBResetI.constprop.35>
  chSchRescheduleS();
 8001f10:	f7fe fd86 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8001f14:	f7ff f97c 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001f18:	4b07      	ldr	r3, [pc, #28]	; (8001f38 <chMBReset.constprop.34+0x38>)
 8001f1a:	681a      	ldr	r2, [r3, #0]
 8001f1c:	429a      	cmp	r2, r3
 8001f1e:	d004      	beq.n	8001f2a <chMBReset.constprop.34+0x2a>
 8001f20:	6999      	ldr	r1, [r3, #24]
 8001f22:	6893      	ldr	r3, [r2, #8]
 8001f24:	688a      	ldr	r2, [r1, #8]
 8001f26:	429a      	cmp	r2, r3
 8001f28:	d303      	bcc.n	8001f32 <chMBReset.constprop.34+0x32>
 8001f2a:	2300      	movs	r3, #0
 8001f2c:	f383 8811 	msr	BASEPRI, r3
 8001f30:	bd08      	pop	{r3, pc}
 8001f32:	4802      	ldr	r0, [pc, #8]	; (8001f3c <chMBReset.constprop.34+0x3c>)
 8001f34:	f7fe fc74 	bl	8000820 <chSysHalt>
 8001f38:	20001e68 	.word	0x20001e68
 8001f3c:	0800a834 	.word	0x0800a834

08001f40 <chMBPost.constprop.32>:
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8001f40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001f44:	4680      	mov	r8, r0
 8001f46:	460f      	mov	r7, r1
 8001f48:	2320      	movs	r3, #32
 8001f4a:	f383 8811 	msr	BASEPRI, r3
 8001f4e:	4c24      	ldr	r4, [pc, #144]	; (8001fe0 <chMBPost.constprop.32+0xa0>)
  _dbg_check_lock();
 8001f50:	f7ff f986 	bl	8001260 <_dbg_check_lock>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8001f54:	f104 0618 	add.w	r6, r4, #24
  chDbgCheckClassS();
 8001f58:	f7fe fc7a 	bl	8000850 <chDbgCheckClassS>
 8001f5c:	e013      	b.n	8001f86 <chMBPost.constprop.32+0x46>
  chDbgCheckClassI();
 8001f5e:	f7fe fcaf 	bl	80008c0 <chDbgCheckClassI>
 8001f62:	f8d4 9000 	ldr.w	r9, [r4]
 8001f66:	6865      	ldr	r5, [r4, #4]
  chDbgCheckClassI();
 8001f68:	f7fe fcaa 	bl	80008c0 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8001f6c:	6923      	ldr	r3, [r4, #16]
  return (cnt_t)(mbp->top - mbp->buffer);
 8001f6e:	eba5 0209 	sub.w	r2, r5, r9
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8001f72:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8001f76:	2b00      	cmp	r3, #0
 8001f78:	dc1e      	bgt.n	8001fb8 <chMBPost.constprop.32+0x78>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8001f7a:	4639      	mov	r1, r7
 8001f7c:	4630      	mov	r0, r6
 8001f7e:	f7ff f837 	bl	8000ff0 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8001f82:	4605      	mov	r5, r0
 8001f84:	b920      	cbnz	r0, 8001f90 <chMBPost.constprop.32+0x50>
    if (mbp->reset) {
 8001f86:	7d23      	ldrb	r3, [r4, #20]
 8001f88:	2b00      	cmp	r3, #0
 8001f8a:	d0e8      	beq.n	8001f5e <chMBPost.constprop.32+0x1e>
      return MSG_RESET;
 8001f8c:	f06f 0501 	mvn.w	r5, #1
  _dbg_check_unlock();
 8001f90:	f7ff f93e 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001f94:	4b13      	ldr	r3, [pc, #76]	; (8001fe4 <chMBPost.constprop.32+0xa4>)
 8001f96:	681a      	ldr	r2, [r3, #0]
 8001f98:	429a      	cmp	r2, r3
 8001f9a:	d004      	beq.n	8001fa6 <chMBPost.constprop.32+0x66>
 8001f9c:	6999      	ldr	r1, [r3, #24]
 8001f9e:	6893      	ldr	r3, [r2, #8]
 8001fa0:	688a      	ldr	r2, [r1, #8]
 8001fa2:	429a      	cmp	r2, r3
 8001fa4:	d305      	bcc.n	8001fb2 <chMBPost.constprop.32+0x72>
 8001fa6:	2300      	movs	r3, #0
 8001fa8:	f383 8811 	msr	BASEPRI, r3
}
 8001fac:	4628      	mov	r0, r5
 8001fae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001fb2:	480d      	ldr	r0, [pc, #52]	; (8001fe8 <chMBPost.constprop.32+0xa8>)
 8001fb4:	f7fe fc34 	bl	8000820 <chSysHalt>
      *mbp->wrptr++ = msg;
 8001fb8:	68a2      	ldr	r2, [r4, #8]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001fba:	480c      	ldr	r0, [pc, #48]	; (8001fec <chMBPost.constprop.32+0xac>)
      *mbp->wrptr++ = msg;
 8001fbc:	1d13      	adds	r3, r2, #4
 8001fbe:	60a3      	str	r3, [r4, #8]
 8001fc0:	f8c2 8000 	str.w	r8, [r2]
      if (mbp->wrptr >= mbp->top) {
 8001fc4:	429d      	cmp	r5, r3
      mbp->cnt++;
 8001fc6:	6923      	ldr	r3, [r4, #16]
        mbp->wrptr = mbp->buffer;
 8001fc8:	bf98      	it	ls
 8001fca:	f8c4 9008 	strls.w	r9, [r4, #8]
      mbp->cnt++;
 8001fce:	3301      	adds	r3, #1
 8001fd0:	6123      	str	r3, [r4, #16]
      chSchRescheduleS();
 8001fd2:	2500      	movs	r5, #0
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001fd4:	f007 fed4 	bl	8009d80 <chThdDequeueNextI.constprop.69>
      chSchRescheduleS();
 8001fd8:	f7fe fd22 	bl	8000a20 <chSchRescheduleS>
 8001fdc:	e7d8      	b.n	8001f90 <chMBPost.constprop.32+0x50>
 8001fde:	bf00      	nop
 8001fe0:	20000c60 	.word	0x20000c60
 8001fe4:	20001e68 	.word	0x20001e68
 8001fe8:	0800a834 	.word	0x0800a834
 8001fec:	20000c80 	.word	0x20000c80

08001ff0 <chMBPostAhead.constprop.29>:
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8001ff0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001ff4:	4680      	mov	r8, r0
 8001ff6:	460f      	mov	r7, r1
 8001ff8:	2320      	movs	r3, #32
 8001ffa:	f383 8811 	msr	BASEPRI, r3
 8001ffe:	4c23      	ldr	r4, [pc, #140]	; (800208c <chMBPostAhead.constprop.29+0x9c>)
  _dbg_check_lock();
 8002000:	f7ff f92e 	bl	8001260 <_dbg_check_lock>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8002004:	f104 0618 	add.w	r6, r4, #24
  chDbgCheckClassS();
 8002008:	f7fe fc22 	bl	8000850 <chDbgCheckClassS>
 800200c:	e012      	b.n	8002034 <chMBPostAhead.constprop.29+0x44>
  chDbgCheckClassI();
 800200e:	f7fe fc57 	bl	80008c0 <chDbgCheckClassI>
 8002012:	e894 0220 	ldmia.w	r4, {r5, r9}
  chDbgCheckClassI();
 8002016:	f7fe fc53 	bl	80008c0 <chDbgCheckClassI>
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800201a:	6923      	ldr	r3, [r4, #16]
  return (cnt_t)(mbp->top - mbp->buffer);
 800201c:	eba9 0205 	sub.w	r2, r9, r5
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8002020:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8002024:	2b00      	cmp	r3, #0
 8002026:	dc1e      	bgt.n	8002066 <chMBPostAhead.constprop.29+0x76>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8002028:	4639      	mov	r1, r7
 800202a:	4630      	mov	r0, r6
 800202c:	f7fe ffe0 	bl	8000ff0 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8002030:	4605      	mov	r5, r0
 8002032:	b920      	cbnz	r0, 800203e <chMBPostAhead.constprop.29+0x4e>
    if (mbp->reset) {
 8002034:	7d23      	ldrb	r3, [r4, #20]
 8002036:	2b00      	cmp	r3, #0
 8002038:	d0e9      	beq.n	800200e <chMBPostAhead.constprop.29+0x1e>
      return MSG_RESET;
 800203a:	f06f 0501 	mvn.w	r5, #1
  _dbg_check_unlock();
 800203e:	f7ff f8e7 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002042:	4b13      	ldr	r3, [pc, #76]	; (8002090 <chMBPostAhead.constprop.29+0xa0>)
 8002044:	681a      	ldr	r2, [r3, #0]
 8002046:	429a      	cmp	r2, r3
 8002048:	d004      	beq.n	8002054 <chMBPostAhead.constprop.29+0x64>
 800204a:	6999      	ldr	r1, [r3, #24]
 800204c:	6893      	ldr	r3, [r2, #8]
 800204e:	688a      	ldr	r2, [r1, #8]
 8002050:	429a      	cmp	r2, r3
 8002052:	d305      	bcc.n	8002060 <chMBPostAhead.constprop.29+0x70>
 8002054:	2300      	movs	r3, #0
 8002056:	f383 8811 	msr	BASEPRI, r3
}
 800205a:	4628      	mov	r0, r5
 800205c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002060:	480c      	ldr	r0, [pc, #48]	; (8002094 <chMBPostAhead.constprop.29+0xa4>)
 8002062:	f7fe fbdd 	bl	8000820 <chSysHalt>
      if (--mbp->rdptr < mbp->buffer) {
 8002066:	68e3      	ldr	r3, [r4, #12]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002068:	480b      	ldr	r0, [pc, #44]	; (8002098 <chMBPostAhead.constprop.29+0xa8>)
      if (--mbp->rdptr < mbp->buffer) {
 800206a:	3b04      	subs	r3, #4
 800206c:	429d      	cmp	r5, r3
        mbp->rdptr = mbp->top - 1;
 800206e:	bf88      	it	hi
 8002070:	f1a9 0304 	subhi.w	r3, r9, #4
 8002074:	60e3      	str	r3, [r4, #12]
      *mbp->rdptr = msg;
 8002076:	f8c3 8000 	str.w	r8, [r3]
      mbp->cnt++;
 800207a:	6923      	ldr	r3, [r4, #16]
 800207c:	3301      	adds	r3, #1
 800207e:	6123      	str	r3, [r4, #16]
      chSchRescheduleS();
 8002080:	2500      	movs	r5, #0
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002082:	f007 fe7d 	bl	8009d80 <chThdDequeueNextI.constprop.69>
      chSchRescheduleS();
 8002086:	f7fe fccb 	bl	8000a20 <chSchRescheduleS>
 800208a:	e7d8      	b.n	800203e <chMBPostAhead.constprop.29+0x4e>
 800208c:	20000c60 	.word	0x20000c60
 8002090:	20001e68 	.word	0x20001e68
 8002094:	0800a834 	.word	0x0800a834
 8002098:	20000c80 	.word	0x20000c80
 800209c:	00000000 	.word	0x00000000

080020a0 <chGuardedPoolAllocTimeout.constprop.20>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
 80020a0:	b510      	push	{r4, lr}
 80020a2:	2320      	movs	r3, #32
 80020a4:	4604      	mov	r4, r0
 80020a6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80020aa:	f7ff f8d9 	bl	8001260 <_dbg_check_lock>
  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
 80020ae:	4621      	mov	r1, r4
 80020b0:	480e      	ldr	r0, [pc, #56]	; (80020ec <chGuardedPoolAllocTimeout.constprop.20+0x4c>)
 80020b2:	f7fe ff6d 	bl	8000f90 <chSemWaitTimeoutS>
  if (msg != MSG_OK) {
 80020b6:	b9b0      	cbnz	r0, 80020e6 <chGuardedPoolAllocTimeout.constprop.20+0x46>
  return chPoolAllocI(&gmp->pool);
 80020b8:	480d      	ldr	r0, [pc, #52]	; (80020f0 <chGuardedPoolAllocTimeout.constprop.20+0x50>)
 80020ba:	f002 fb59 	bl	8004770 <chPoolAllocI>
 80020be:	4604      	mov	r4, r0
  _dbg_check_unlock();
 80020c0:	f7ff f8a6 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80020c4:	4b0b      	ldr	r3, [pc, #44]	; (80020f4 <chGuardedPoolAllocTimeout.constprop.20+0x54>)
 80020c6:	681a      	ldr	r2, [r3, #0]
 80020c8:	429a      	cmp	r2, r3
 80020ca:	d004      	beq.n	80020d6 <chGuardedPoolAllocTimeout.constprop.20+0x36>
 80020cc:	6999      	ldr	r1, [r3, #24]
 80020ce:	6893      	ldr	r3, [r2, #8]
 80020d0:	688a      	ldr	r2, [r1, #8]
 80020d2:	429a      	cmp	r2, r3
 80020d4:	d304      	bcc.n	80020e0 <chGuardedPoolAllocTimeout.constprop.20+0x40>
 80020d6:	2300      	movs	r3, #0
 80020d8:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 80020dc:	4620      	mov	r0, r4
 80020de:	bd10      	pop	{r4, pc}
 80020e0:	4805      	ldr	r0, [pc, #20]	; (80020f8 <chGuardedPoolAllocTimeout.constprop.20+0x58>)
 80020e2:	f7fe fb9d 	bl	8000820 <chSysHalt>
    return NULL;
 80020e6:	2400      	movs	r4, #0
 80020e8:	e7ea      	b.n	80020c0 <chGuardedPoolAllocTimeout.constprop.20+0x20>
 80020ea:	bf00      	nop
 80020ec:	20000c04 	.word	0x20000c04
 80020f0:	20000c10 	.word	0x20000c10
 80020f4:	20001e68 	.word	0x20001e68
 80020f8:	0800a840 	.word	0x0800a840
 80020fc:	00000000 	.word	0x00000000

08002100 <main>:
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c) and AHB2 is not
     present in STM32F410. */
  rccResetAHB1(~0);
 8002100:	4ba7      	ldr	r3, [pc, #668]	; (80023a0 <main+0x2a0>)
  PWR->CR |= PWR_CR_DBP;
 8002102:	4ca8      	ldr	r4, [pc, #672]	; (80023a4 <main+0x2a4>)
  rccResetAHB1(~0);
 8002104:	691a      	ldr	r2, [r3, #16]
 8002106:	f04f 31ff 	mov.w	r1, #4294967295
 800210a:	2200      	movs	r2, #0
}

/*
 * Application entry point.
 */
int main(void) {
 800210c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8002110:	6119      	str	r1, [r3, #16]
 8002112:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8002114:	6958      	ldr	r0, [r3, #20]
 8002116:	6159      	str	r1, [r3, #20]
 8002118:	615a      	str	r2, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800211a:	6a18      	ldr	r0, [r3, #32]
 800211c:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8002120:	6218      	str	r0, [r3, #32]
 8002122:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8002124:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002126:	6259      	str	r1, [r3, #36]	; 0x24
 8002128:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800212a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800212c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8002130:	6419      	str	r1, [r3, #64]	; 0x40
  PWR->CR |= PWR_CR_DBP;
 8002132:	6821      	ldr	r1, [r4, #0]
 8002134:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8002138:	6021      	str	r1, [r4, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800213a:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800213c:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8002140:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8002144:	b08b      	sub	sp, #44	; 0x2c
 8002146:	d003      	beq.n	8002150 <main+0x50>
    RCC->BDCR = RCC_BDCR_BDRST;
 8002148:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800214c:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800214e:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 8002150:	4e94      	ldr	r6, [pc, #592]	; (80023a4 <main+0x2a4>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8002152:	4893      	ldr	r0, [pc, #588]	; (80023a0 <main+0x2a0>)
 8002154:	6873      	ldr	r3, [r6, #4]
  gpiop->OTYPER  = config->otyper;
 8002156:	4a94      	ldr	r2, [pc, #592]	; (80023a8 <main+0x2a8>)
 8002158:	4d94      	ldr	r5, [pc, #592]	; (80023ac <main+0x2ac>)
  gpiop->PUPDR   = config->pupdr;
 800215a:	f8df e2c4 	ldr.w	lr, [pc, #708]	; 8002420 <main+0x320>
  gpiop->OTYPER  = config->otyper;
 800215e:	4c94      	ldr	r4, [pc, #592]	; (80023b0 <main+0x2b0>)
 8002160:	4994      	ldr	r1, [pc, #592]	; (80023b4 <main+0x2b4>)
 8002162:	4f95      	ldr	r7, [pc, #596]	; (80023b8 <main+0x2b8>)
 8002164:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8002168:	6073      	str	r3, [r6, #4]
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 800216a:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800216c:	f240 1cff 	movw	ip, #511	; 0x1ff
 8002170:	ea43 030c 	orr.w	r3, r3, ip
 8002174:	6303      	str	r3, [r0, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8002176:	6d06      	ldr	r6, [r0, #80]	; 0x50
 8002178:	ea46 060c 	orr.w	r6, r6, ip
  gpiop->OTYPER  = config->otyper;
 800217c:	2300      	movs	r3, #0
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 800217e:	6506      	str	r6, [r0, #80]	; 0x50
  gpiop->OSPEEDR = config->ospeedr;
 8002180:	f46f 46a8 	mvn.w	r6, #21504	; 0x5400
  gpiop->OTYPER  = config->otyper;
 8002184:	6053      	str	r3, [r2, #4]
  gpiop->ODR     = config->odr;
 8002186:	f64f 70ff 	movw	r0, #65535	; 0xffff
  gpiop->OSPEEDR = config->ospeedr;
 800218a:	6096      	str	r6, [r2, #8]
  gpiop->AFRL    = config->afrl;
 800218c:	f8df c294 	ldr.w	ip, [pc, #660]	; 8002424 <main+0x324>
  gpiop->AFRH    = config->afrh;
 8002190:	4e8a      	ldr	r6, [pc, #552]	; (80023bc <main+0x2bc>)
  gpiop->PUPDR   = config->pupdr;
 8002192:	f8c2 e00c 	str.w	lr, [r2, #12]
  gpiop->ODR     = config->odr;
 8002196:	6150      	str	r0, [r2, #20]
  gpiop->MODER   = config->moder;
 8002198:	f8df e28c 	ldr.w	lr, [pc, #652]	; 8002428 <main+0x328>
  gpiop->AFRL    = config->afrl;
 800219c:	f8c2 c020 	str.w	ip, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80021a0:	6256      	str	r6, [r2, #36]	; 0x24
  gpiop->OTYPER  = config->otyper;
 80021a2:	f44f 7610 	mov.w	r6, #576	; 0x240
  gpiop->MODER   = config->moder;
 80021a6:	f8c2 e000 	str.w	lr, [r2]
  gpiop->OTYPER  = config->otyper;
 80021aa:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80021ac:	f04f 32ff 	mov.w	r2, #4294967295
  gpiop->PUPDR   = config->pupdr;
 80021b0:	f8df e278 	ldr.w	lr, [pc, #632]	; 800242c <main+0x32c>
  gpiop->OSPEEDR = config->ospeedr;
 80021b4:	60aa      	str	r2, [r5, #8]
  gpiop->AFRL    = config->afrl;
 80021b6:	f04f 6680 	mov.w	r6, #67108864	; 0x4000000
  gpiop->PUPDR   = config->pupdr;
 80021ba:	f8c5 e00c 	str.w	lr, [r5, #12]
  gpiop->ODR     = config->odr;
 80021be:	6168      	str	r0, [r5, #20]
  gpiop->AFRH    = config->afrh;
 80021c0:	f04f 0e40 	mov.w	lr, #64	; 0x40
  gpiop->AFRL    = config->afrl;
 80021c4:	622e      	str	r6, [r5, #32]
  gpiop->MODER   = config->moder;
 80021c6:	4e7e      	ldr	r6, [pc, #504]	; (80023c0 <main+0x2c0>)
  gpiop->AFRH    = config->afrh;
 80021c8:	f8c5 e024 	str.w	lr, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80021cc:	602e      	str	r6, [r5, #0]
  gpiop->PUPDR   = config->pupdr;
 80021ce:	f105 55a2 	add.w	r5, r5, #339738624	; 0x14400000
 80021d2:	f505 3544 	add.w	r5, r5, #200704	; 0x31000
 80021d6:	f505 75aa 	add.w	r5, r5, #340	; 0x154
  gpiop->OTYPER  = config->otyper;
 80021da:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80021dc:	60a2      	str	r2, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80021de:	60e5      	str	r5, [r4, #12]
  gpiop->AFRL    = config->afrl;
 80021e0:	f04f 45c0 	mov.w	r5, #1610612736	; 0x60000000
  gpiop->ODR     = config->odr;
 80021e4:	6160      	str	r0, [r4, #20]
  gpiop->AFRL    = config->afrl;
 80021e6:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 80021e8:	4d76      	ldr	r5, [pc, #472]	; (80023c4 <main+0x2c4>)
 80021ea:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80021ec:	4d76      	ldr	r5, [pc, #472]	; (80023c8 <main+0x2c8>)
 80021ee:	6025      	str	r5, [r4, #0]
  gpiop->PUPDR   = config->pupdr;
 80021f0:	4c76      	ldr	r4, [pc, #472]	; (80023cc <main+0x2cc>)
  gpiop->OTYPER  = config->otyper;
 80021f2:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80021f4:	608a      	str	r2, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 80021f6:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 80021f8:	f640 74ff 	movw	r4, #4095	; 0xfff
  gpiop->OTYPER  = config->otyper;
 80021fc:	4e74      	ldr	r6, [pc, #464]	; (80023d0 <main+0x2d0>)
  gpiop->ODR     = config->odr;
 80021fe:	614c      	str	r4, [r1, #20]
  gpiop->MODER   = config->moder;
 8002200:	4c74      	ldr	r4, [pc, #464]	; (80023d4 <main+0x2d4>)
  gpiop->OTYPER  = config->otyper;
 8002202:	4d75      	ldr	r5, [pc, #468]	; (80023d8 <main+0x2d8>)
  gpiop->AFRL    = config->afrl;
 8002204:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8002206:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002208:	600c      	str	r4, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 800220a:	607b      	str	r3, [r7, #4]
 800220c:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
  gpiop->OSPEEDR = config->ospeedr;
 8002210:	60ba      	str	r2, [r7, #8]
  gpiop->OTYPER  = config->otyper;
 8002212:	4c72      	ldr	r4, [pc, #456]	; (80023dc <main+0x2dc>)
  gpiop->PUPDR   = config->pupdr;
 8002214:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 8002216:	6178      	str	r0, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8002218:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 800221a:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800221c:	f8c7 e000 	str.w	lr, [r7]
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8002220:	4f6f      	ldr	r7, [pc, #444]	; (80023e0 <main+0x2e0>)
  gpiop->OTYPER  = config->otyper;
 8002222:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002224:	60b2      	str	r2, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8002226:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 8002228:	6170      	str	r0, [r6, #20]
  gpiop->AFRL    = config->afrl;
 800222a:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 800222c:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800222e:	6033      	str	r3, [r6, #0]
 8002230:	2601      	movs	r6, #1
  gpiop->OTYPER  = config->otyper;
 8002232:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002234:	60aa      	str	r2, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8002236:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 8002238:	6168      	str	r0, [r5, #20]
  gpiop->AFRL    = config->afrl;
 800223a:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 800223c:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800223e:	602b      	str	r3, [r5, #0]
  gpiop->OTYPER  = config->otyper;
 8002240:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002242:	608a      	str	r2, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8002244:	60cb      	str	r3, [r1, #12]
  gpiop->ODR     = config->odr;
 8002246:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8002248:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800224a:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800224c:	600b      	str	r3, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 800224e:	6063      	str	r3, [r4, #4]
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8002250:	4619      	mov	r1, r3
  gpiop->OSPEEDR = config->ospeedr;
 8002252:	60a2      	str	r2, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8002254:	60e3      	str	r3, [r4, #12]
 8002256:	f107 0224 	add.w	r2, r7, #36	; 0x24
  gpiop->ODR     = config->odr;
 800225a:	6160      	str	r0, [r4, #20]
  gpiop->AFRL    = config->afrl;
 800225c:	6223      	str	r3, [r4, #32]
 800225e:	f107 0038 	add.w	r0, r7, #56	; 0x38
  usbp->config       = NULL;
 8002262:	607b      	str	r3, [r7, #4]
  gpiop->AFRH    = config->afrh;
 8002264:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002266:	6023      	str	r3, [r4, #0]
  usbp->state        = USB_STOP;
 8002268:	703e      	strb	r6, [r7, #0]
    usbp->in_params[i]  = NULL;
 800226a:	f842 1b04 	str.w	r1, [r2], #4
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 800226e:	4282      	cmp	r2, r0
    usbp->out_params[i] = NULL;
 8002270:	6111      	str	r1, [r2, #16]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8002272:	d1fa      	bne.n	800226a <main+0x16a>
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8002274:	4e5b      	ldr	r6, [pc, #364]	; (80023e4 <main+0x2e4>)
  USBD1.otgparams = &fsparams;
 8002276:	4a5c      	ldr	r2, [pc, #368]	; (80023e8 <main+0x2e8>)
 8002278:	673a      	str	r2, [r7, #112]	; 0x70
  USBD1.otg       = OTG_FS;
 800227a:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
  }
  usbp->transmitting = 0;
 800227e:	8139      	strh	r1, [r7, #8]
  usbp->receiving    = 0;
 8002280:	8179      	strh	r1, [r7, #10]
  USBD1.wait      = NULL;
 8002282:	67f9      	str	r1, [r7, #124]	; 0x7c
  USBD1.tr = NULL;
 8002284:	f8c7 1080 	str.w	r1, [r7, #128]	; 0x80
 8002288:	4633      	mov	r3, r6
 800228a:	f506 78a4 	add.w	r8, r6, #328	; 0x148
  USBD1.otg       = OTG_FS;
 800228e:	66f8      	str	r0, [r7, #108]	; 0x6c
    *startp++ = v;
 8002290:	2255      	movs	r2, #85	; 0x55
 8002292:	f803 2b01 	strb.w	r2, [r3], #1
  while (startp < endp) {
 8002296:	4543      	cmp	r3, r8
 8002298:	d1fb      	bne.n	8002292 <main+0x192>
  usbp->state        = USB_STOP;
 800229a:	4854      	ldr	r0, [pc, #336]	; (80023ec <main+0x2ec>)
 800229c:	2301      	movs	r3, #1
  usbp->config       = NULL;
 800229e:	2200      	movs	r2, #0
  usbp->state        = USB_STOP;
 80022a0:	7003      	strb	r3, [r0, #0]
  usbp->config       = NULL;
 80022a2:	6042      	str	r2, [r0, #4]
 80022a4:	f100 0324 	add.w	r3, r0, #36	; 0x24
 80022a8:	f100 0138 	add.w	r1, r0, #56	; 0x38
    usbp->in_params[i]  = NULL;
 80022ac:	f843 2b04 	str.w	r2, [r3], #4
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80022b0:	428b      	cmp	r3, r1
    usbp->out_params[i] = NULL;
 80022b2:	611a      	str	r2, [r3, #16]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80022b4:	d1fa      	bne.n	80022ac <main+0x1ac>
  USBD2.wait      = NULL;
  USBD2.otg       = OTG_HS;
  USBD2.otgparams = &hsparams;

#if defined(_CHIBIOS_RT_)
  USBD2.tr = NULL;
 80022b6:	4b4e      	ldr	r3, [pc, #312]	; (80023f0 <main+0x2f0>)
  USBD2.otg       = OTG_HS;
 80022b8:	4d4e      	ldr	r5, [pc, #312]	; (80023f4 <main+0x2f4>)
  USBD2.otgparams = &hsparams;
 80022ba:	4c4f      	ldr	r4, [pc, #316]	; (80023f8 <main+0x2f8>)
  usbp->transmitting = 0;
 80022bc:	8102      	strh	r2, [r0, #8]
  usbp->receiving    = 0;
 80022be:	8142      	strh	r2, [r0, #10]
  USBD2.wait      = NULL;
 80022c0:	67c2      	str	r2, [r0, #124]	; 0x7c
  USBD2.tr = NULL;
 80022c2:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 80022c6:	f503 71a4 	add.w	r1, r3, #328	; 0x148
  USBD2.otg       = OTG_HS;
 80022ca:	66c5      	str	r5, [r0, #108]	; 0x6c
  USBD2.otgparams = &hsparams;
 80022cc:	6704      	str	r4, [r0, #112]	; 0x70
    *startp++ = v;
 80022ce:	2255      	movs	r2, #85	; 0x55
 80022d0:	f803 2b01 	strb.w	r2, [r3], #1
  while (startp < endp) {
 80022d4:	428b      	cmp	r3, r1
 80022d6:	d1fb      	bne.n	80022d0 <main+0x1d0>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80022d8:	4931      	ldr	r1, [pc, #196]	; (80023a0 <main+0x2a0>)
  tqp->next = (thread_t *)tqp;
 80022da:	4d48      	ldr	r5, [pc, #288]	; (80023fc <main+0x2fc>)
 80022dc:	6c0b      	ldr	r3, [r1, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80022de:	4848      	ldr	r0, [pc, #288]	; (8002400 <main+0x300>)
  tqp->prev = (thread_t *)tqp;
 80022e0:	606d      	str	r5, [r5, #4]
  ST_ENABLE_CLOCK();
 80022e2:	f043 0301 	orr.w	r3, r3, #1
 80022e6:	640b      	str	r3, [r1, #64]	; 0x40
  ST_ENABLE_STOP();
 80022e8:	6881      	ldr	r1, [r0, #8]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 80022ea:	612d      	str	r5, [r5, #16]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80022ec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  ST_ENABLE_STOP();
 80022f0:	f041 0101 	orr.w	r1, r1, #1
 80022f4:	6081      	str	r1, [r0, #8]
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80022f6:	f04f 31ff 	mov.w	r1, #4294967295
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80022fa:	f242 00cf 	movw	r0, #8399	; 0x20cf
 80022fe:	6298      	str	r0, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002300:	62d9      	str	r1, [r3, #44]	; 0x2c
  ch.vtlist.delta = (systime_t)-1;
 8002302:	6269      	str	r1, [r5, #36]	; 0x24
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8002304:	f105 0140 	add.w	r1, r5, #64	; 0x40
 8002308:	63e9      	str	r1, [r5, #60]	; 0x3c
  STM32_ST_TIM->CCMR1  = 0;
 800230a:	2400      	movs	r4, #0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800230c:	4a3d      	ldr	r2, [pc, #244]	; (8002404 <main+0x304>)
  ch.rlist.older = (thread_t *)&ch.rlist;
 800230e:	616d      	str	r5, [r5, #20]
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002310:	2101      	movs	r1, #1
  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8002312:	200f      	movs	r0, #15
 8002314:	8728      	strh	r0, [r5, #56]	; 0x38
  STM32_ST_TIM->CCMR1  = 0;
 8002316:	619c      	str	r4, [r3, #24]
  ch.rlist.prio = NOPRIO;
 8002318:	60ac      	str	r4, [r5, #8]
  STM32_ST_TIM->CCR[0] = 0;
 800231a:	635c      	str	r4, [r3, #52]	; 0x34
  ch.vtlist.lasttime = (systime_t)0;
 800231c:	62ac      	str	r4, [r5, #40]	; 0x28
  STM32_ST_TIM->DIER   = 0;
 800231e:	60dc      	str	r4, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002320:	605c      	str	r4, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002322:	6159      	str	r1, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002324:	6019      	str	r1, [r3, #0]
 8002326:	2380      	movs	r3, #128	; 0x80
 8002328:	f882 331c 	strb.w	r3, [r2, #796]	; 0x31c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800232c:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8002330:	876b      	strh	r3, [r5, #58]	; 0x3a
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8002332:	f105 031c 	add.w	r3, r5, #28
 8002336:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
 800233a:	61eb      	str	r3, [r5, #28]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800233c:	6011      	str	r1, [r2, #0]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 800233e:	622b      	str	r3, [r5, #32]
  tqp->next = (thread_t *)tqp;
 8002340:	602d      	str	r5, [r5, #0]
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8002342:	3401      	adds	r4, #1
 8002344:	eb05 1304 	add.w	r3, r5, r4, lsl #4
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002348:	2c80      	cmp	r4, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800234a:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 800234e:	f36f 0202 	bfc	r2, #0, #3
 8002352:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002356:	d1f4      	bne.n	8002342 <main+0x242>
  ch.dbg.isr_cnt  = (cnt_t)0;
 8002358:	f04f 0900 	mov.w	r9, #0
  tmp->best       = (rtcnt_t)-1;
 800235c:	f04f 31ff 	mov.w	r1, #4294967295
  tmp->cumulative = (rttime_t)0;
 8002360:	2200      	movs	r2, #0
 8002362:	2300      	movs	r3, #0
  chTMStartMeasurementX(&tm);
 8002364:	a804      	add	r0, sp, #16
  tmp->cumulative = (rttime_t)0;
 8002366:	e9cd 2308 	strd	r2, r3, [sp, #32]
  tmp->best       = (rtcnt_t)-1;
 800236a:	9104      	str	r1, [sp, #16]
 800236c:	f8c5 9030 	str.w	r9, [r5, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 8002370:	f8c5 9034 	str.w	r9, [r5, #52]	; 0x34
  ch.tm.offset = (rtcnt_t)0;
 8002374:	f8c5 9884 	str.w	r9, [r5, #2180]	; 0x884
  tmp->worst      = (rtcnt_t)0;
 8002378:	f8cd 9014 	str.w	r9, [sp, #20]
  tmp->last       = (rtcnt_t)0;
 800237c:	f8cd 9018 	str.w	r9, [sp, #24]
  tmp->n          = (ucnt_t)0;
 8002380:	f8cd 901c 	str.w	r9, [sp, #28]
  chTMStartMeasurementX(&tm);
 8002384:	f007 fcdc 	bl	8009d40 <chTMStartMeasurementX.constprop.75>
  chTMStopMeasurementX(&tm);
 8002388:	a804      	add	r0, sp, #16
 800238a:	f7fe f9b1 	bl	80006f0 <chTMStopMeasurementX>
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 800238e:	4b1e      	ldr	r3, [pc, #120]	; (8002408 <main+0x308>)
 8002390:	491e      	ldr	r1, [pc, #120]	; (800240c <main+0x30c>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8002392:	4a1f      	ldr	r2, [pc, #124]	; (8002410 <main+0x310>)
 8002394:	6019      	str	r1, [r3, #0]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002396:	491f      	ldr	r1, [pc, #124]	; (8002414 <main+0x314>)
  endmem  = __heap_end__;
 8002398:	481f      	ldr	r0, [pc, #124]	; (8002418 <main+0x318>)
 800239a:	4b20      	ldr	r3, [pc, #128]	; (800241c <main+0x31c>)
 800239c:	6013      	str	r3, [r2, #0]
 800239e:	e047      	b.n	8002430 <main+0x330>
 80023a0:	40023800 	.word	0x40023800
 80023a4:	40007000 	.word	0x40007000
 80023a8:	40020000 	.word	0x40020000
 80023ac:	40020400 	.word	0x40020400
 80023b0:	40020800 	.word	0x40020800
 80023b4:	40020c00 	.word	0x40020c00
 80023b8:	40021000 	.word	0x40021000
 80023bc:	000aaa00 	.word	0x000aaa00
 80023c0:	00082080 	.word	0x00082080
 80023c4:	00060600 	.word	0x00060600
 80023c8:	02208001 	.word	0x02208001
 80023cc:	00555055 	.word	0x00555055
 80023d0:	40021400 	.word	0x40021400
 80023d4:	55000100 	.word	0x55000100
 80023d8:	40021800 	.word	0x40021800
 80023dc:	40022000 	.word	0x40022000
 80023e0:	20001118 	.word	0x20001118
 80023e4:	200011a0 	.word	0x200011a0
 80023e8:	0800a8f0 	.word	0x0800a8f0
 80023ec:	200012e8 	.word	0x200012e8
 80023f0:	20001370 	.word	0x20001370
 80023f4:	40040000 	.word	0x40040000
 80023f8:	0800a8fc 	.word	0x0800a8fc
 80023fc:	20001e68 	.word	0x20001e68
 8002400:	e0042000 	.word	0xe0042000
 8002404:	e000e100 	.word	0xe000e100
 8002408:	20001594 	.word	0x20001594
 800240c:	20002738 	.word	0x20002738
 8002410:	200026f0 	.word	0x200026f0
 8002414:	e000ed00 	.word	0xe000ed00
 8002418:	20001590 	.word	0x20001590
 800241c:	08004d41 	.word	0x08004d41
 8002420:	40010054 	.word	0x40010054
 8002424:	55560000 	.word	0x55560000
 8002428:	2aa0aa00 	.word	0x2aa0aa00
 800242c:	55514515 	.word	0x55514515
 8002430:	f8df e2dc 	ldr.w	lr, [pc, #732]	; 8002710 <main+0x610>
 8002434:	68cb      	ldr	r3, [r1, #12]
 8002436:	f8c0 e000 	str.w	lr, [r0]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800243a:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
 800243e:	489d      	ldr	r0, [pc, #628]	; (80026b4 <main+0x5b4>)
  REG_INSERT(tp);
 8002440:	f8d5 e014 	ldr.w	lr, [r5, #20]
  tp->prio      = prio;
 8002444:	f8c5 4848 	str.w	r4, [r5, #2120]	; 0x848
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002448:	ea03 030c 	and.w	r3, r3, ip
  reg_value  =  (reg_value                                   |
 800244c:	4318      	orrs	r0, r3
 800244e:	f102 0310 	add.w	r3, r2, #16
 8002452:	6113      	str	r3, [r2, #16]
  tqp->prev = (thread_t *)tqp;
 8002454:	6153      	str	r3, [r2, #20]
  ch.tm.offset = tm.last;
 8002456:	9b06      	ldr	r3, [sp, #24]
 8002458:	f8c5 3884 	str.w	r3, [r5, #2180]	; 0x884
  tp->name      = name;
 800245c:	4b96      	ldr	r3, [pc, #600]	; (80026b8 <main+0x5b8>)
  tp->realprio  = prio;
 800245e:	f8c5 487c 	str.w	r4, [r5, #2172]	; 0x87c
  tp->name      = name;
 8002462:	f8c5 3858 	str.w	r3, [r5, #2136]	; 0x858
  tp->refs      = (trefs_t)1;
 8002466:	2401      	movs	r4, #1
  REG_INSERT(tp);
 8002468:	4b94      	ldr	r3, [pc, #592]	; (80026bc <main+0x5bc>)
  tp->refs      = (trefs_t)1;
 800246a:	f885 4862 	strb.w	r4, [r5, #2146]	; 0x862
  tp->flags     = CH_FLAG_MODE_STATIC;
 800246e:	f885 9861 	strb.w	r9, [r5, #2145]	; 0x861
  tp->epending  = (eventmask_t)0;
 8002472:	f8c5 9874 	str.w	r9, [r5, #2164]	; 0x874
  mp->owner = NULL;
 8002476:	f8c2 9018 	str.w	r9, [r2, #24]
  REG_INSERT(tp);
 800247a:	f8c5 e854 	str.w	lr, [r5, #2132]	; 0x854
  tp->mtxlist   = NULL;
 800247e:	f8c5 9878 	str.w	r9, [r5, #2168]	; 0x878
  REG_INSERT(tp);
 8002482:	f8c5 5850 	str.w	r5, [r5, #2128]	; 0x850
 8002486:	f8ce 3010 	str.w	r3, [lr, #16]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800248a:	f8df e288 	ldr.w	lr, [pc, #648]	; 8002714 <main+0x614>
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800248e:	60c8      	str	r0, [r1, #12]
 8002490:	f8de 000c 	ldr.w	r0, [lr, #12]
  H_NEXT(&default_heap.header) = NULL;
 8002494:	f8c2 9008 	str.w	r9, [r2, #8]
 8002498:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
 800249c:	f8ce 000c 	str.w	r0, [lr, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80024a0:	4887      	ldr	r0, [pc, #540]	; (80026c0 <main+0x5c0>)
    currp->wabase = &__main_thread_stack_base__;
 80024a2:	f8df e274 	ldr.w	lr, [pc, #628]	; 8002718 <main+0x618>
  H_PAGES(&default_heap.header) = 0;
 80024a6:	f8c2 900c 	str.w	r9, [r2, #12]
 80024aa:	616b      	str	r3, [r5, #20]
  tlp->next = (thread_t *)tlp;
 80024ac:	f103 0228 	add.w	r2, r3, #40	; 0x28
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80024b0:	61ab      	str	r3, [r5, #24]
  currp->state = CH_STATE_CURRENT;
 80024b2:	f885 4860 	strb.w	r4, [r5, #2144]	; 0x860
  tqp->next = (thread_t *)tqp;
 80024b6:	332c      	adds	r3, #44	; 0x2c
  tlp->next = (thread_t *)tlp;
 80024b8:	f8c5 2868 	str.w	r2, [r5, #2152]	; 0x868
    currp->wabase = &__main_thread_stack_base__;
 80024bc:	f8c5 e85c 	str.w	lr, [r5, #2140]	; 0x85c
  tqp->next = (thread_t *)tqp;
 80024c0:	f8c5 386c 	str.w	r3, [r5, #2156]	; 0x86c
  tqp->prev = (thread_t *)tqp;
 80024c4:	f8c5 3870 	str.w	r3, [r5, #2160]	; 0x870
 80024c8:	6803      	ldr	r3, [r0, #0]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80024ca:	2220      	movs	r2, #32
 80024cc:	f043 0301 	orr.w	r3, r3, #1
 80024d0:	2410      	movs	r4, #16
 80024d2:	6003      	str	r3, [r0, #0]
 80024d4:	77cc      	strb	r4, [r1, #31]
 80024d6:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  _dbg_check_enable();
 80024da:	f7ff fb21 	bl	8001b20 <_dbg_check_enable>
 80024de:	f389 8811 	msr	BASEPRI, r9
  __ASM volatile ("cpsie i" : : : "memory");
 80024e2:	b662      	cpsie	i
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 80024e4:	4877      	ldr	r0, [pc, #476]	; (80026c4 <main+0x5c4>)
 80024e6:	f7ff faa3 	bl	8001a30 <chRegFindThreadByWorkingArea>
 80024ea:	b110      	cbz	r0, 80024f2 <main+0x3f2>
 80024ec:	4876      	ldr	r0, [pc, #472]	; (80026c8 <main+0x5c8>)
 80024ee:	f7fe f997 	bl	8000820 <chSysHalt>
 80024f2:	4b74      	ldr	r3, [pc, #464]	; (80026c4 <main+0x5c4>)
    *startp++ = v;
 80024f4:	2155      	movs	r1, #85	; 0x55
 80024f6:	f103 02d8 	add.w	r2, r3, #216	; 0xd8
 80024fa:	f803 1b01 	strb.w	r1, [r3], #1
  while (startp < endp) {
 80024fe:	4293      	cmp	r3, r2
 8002500:	d1fb      	bne.n	80024fa <main+0x3fa>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002502:	2320      	movs	r3, #32
 8002504:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002508:	f7fe feaa 	bl	8001260 <_dbg_check_lock>
  tp = chThdCreateSuspendedI(tdp);
 800250c:	486f      	ldr	r0, [pc, #444]	; (80026cc <main+0x5cc>)
 800250e:	f7fe f9e7 	bl	80008e0 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8002512:	2100      	movs	r1, #0
 8002514:	f7fe fc1c 	bl	8000d50 <chSchWakeupS>
  _dbg_check_unlock();
 8002518:	f7fe fe7a 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800251c:	682b      	ldr	r3, [r5, #0]
 800251e:	42ab      	cmp	r3, r5
 8002520:	d004      	beq.n	800252c <main+0x42c>
 8002522:	69aa      	ldr	r2, [r5, #24]
 8002524:	689b      	ldr	r3, [r3, #8]
 8002526:	6892      	ldr	r2, [r2, #8]
 8002528:	429a      	cmp	r2, r3
 800252a:	d346      	bcc.n	80025ba <main+0x4ba>
 800252c:	2300      	movs	r3, #0
 800252e:	f383 8811 	msr	BASEPRI, r3
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
 8002532:	4c67      	ldr	r4, [pc, #412]	; (80026d0 <main+0x5d0>)
 8002534:	4a67      	ldr	r2, [pc, #412]	; (80026d4 <main+0x5d4>)

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
 8002536:	61a3      	str	r3, [r4, #24]
 8002538:	4621      	mov	r1, r4
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
  ibqp->buffers   = bp;
  ibqp->ptr       = NULL;
 800253a:	6363      	str	r3, [r4, #52]	; 0x34
 800253c:	f841 2b04 	str.w	r2, [r1], #4
  ibqp->top       = NULL;
 8002540:	63a3      	str	r3, [r4, #56]	; 0x38
  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8002542:	f204 428c 	addw	r2, r4, #1164	; 0x48c
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
 8002546:	66e3      	str	r3, [r4, #108]	; 0x6c
  obqp->top       = NULL;
 8002548:	6723      	str	r3, [r4, #112]	; 0x70
  obqp->notify    = onfy;
 800254a:	4b63      	ldr	r3, [pc, #396]	; (80026d8 <main+0x5d8>)
  ibqp->notify    = infy;
 800254c:	4863      	ldr	r0, [pc, #396]	; (80026dc <main+0x5dc>)
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800254e:	65e2      	str	r2, [r4, #92]	; 0x5c
  obqp->notify    = onfy;
 8002550:	6763      	str	r3, [r4, #116]	; 0x74
  ibqp->brdptr    = bp;
 8002552:	f104 027c 	add.w	r2, r4, #124	; 0x7c
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8002556:	f504 7321 	add.w	r3, r4, #644	; 0x284
  ibqp->bn        = n;
 800255a:	f04f 0902 	mov.w	r9, #2
  ibqp->notify    = infy;
 800255e:	63e0      	str	r0, [r4, #60]	; 0x3c
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8002560:	6061      	str	r1, [r4, #4]
  tqp->next = (thread_t *)tqp;
 8002562:	f104 000c 	add.w	r0, r4, #12
 8002566:	f104 0144 	add.w	r1, r4, #68	; 0x44
  ibqp->brdptr    = bp;
 800256a:	6222      	str	r2, [r4, #32]
  ibqp->bwrptr    = bp;
 800256c:	61e2      	str	r2, [r4, #28]
  ibqp->buffers   = bp;
 800256e:	6322      	str	r2, [r4, #48]	; 0x30
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8002570:	6263      	str	r3, [r4, #36]	; 0x24
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 8002572:	2201      	movs	r2, #1
  obqp->brdptr    = bp;
 8002574:	65a3      	str	r3, [r4, #88]	; 0x58
  obqp->bwrptr    = bp;
 8002576:	6563      	str	r3, [r4, #84]	; 0x54
  obqp->buffers   = bp;
 8002578:	66a3      	str	r3, [r4, #104]	; 0x68
  ibqp->bsize     = size + sizeof (size_t);
 800257a:	f44f 7382 	mov.w	r3, #260	; 0x104
 800257e:	62a3      	str	r3, [r4, #40]	; 0x28
  obqp->bsize     = size + sizeof (size_t);
 8002580:	6623      	str	r3, [r4, #96]	; 0x60
  ibqp->link      = link;
 8002582:	6424      	str	r4, [r4, #64]	; 0x40
  obqp->link      = link;
 8002584:	67a4      	str	r4, [r4, #120]	; 0x78
 8002586:	60e0      	str	r0, [r4, #12]
  tqp->prev = (thread_t *)tqp;
 8002588:	6120      	str	r0, [r4, #16]
  tqp->next = (thread_t *)tqp;
 800258a:	6461      	str	r1, [r4, #68]	; 0x44
  tqp->prev = (thread_t *)tqp;
 800258c:	64a1      	str	r1, [r4, #72]	; 0x48
 800258e:	7222      	strb	r2, [r4, #8]
  ibqp->suspended = suspended;
 8002590:	7522      	strb	r2, [r4, #20]
  obqp->suspended = suspended;
 8002592:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
  ibqp->bn        = n;
 8002596:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
  obqp->bcounter  = n;
 800259a:	f8c4 9050 	str.w	r9, [r4, #80]	; 0x50
  obqp->bn        = n;
 800259e:	f8c4 9064 	str.w	r9, [r4, #100]	; 0x64
 80025a2:	2320      	movs	r3, #32
 80025a4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80025a8:	f7fe fe5a 	bl	8001260 <_dbg_check_lock>
  USBDriver *usbp = config->usbp;

  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 80025ac:	7a23      	ldrb	r3, [r4, #8]
 80025ae:	3b01      	subs	r3, #1
 80025b0:	2b01      	cmp	r3, #1
 80025b2:	d905      	bls.n	80025c0 <main+0x4c0>
 80025b4:	484a      	ldr	r0, [pc, #296]	; (80026e0 <main+0x5e0>)
 80025b6:	f7fe f933 	bl	8000820 <chSysHalt>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80025ba:	484a      	ldr	r0, [pc, #296]	; (80026e4 <main+0x5e4>)
 80025bc:	f7fe f930 	bl	8000820 <chSysHalt>
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  usbp->out_params[config->bulk_out - 1U] = sdup;
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
  }
  sdup->config = config;
 80025c0:	4b49      	ldr	r3, [pc, #292]	; (80026e8 <main+0x5e8>)
 80025c2:	f8c4 348c 	str.w	r3, [r4, #1164]	; 0x48c
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 80025c6:	627c      	str	r4, [r7, #36]	; 0x24
  usbp->out_params[config->bulk_out - 1U] = sdup;
 80025c8:	63bc      	str	r4, [r7, #56]	; 0x38
    usbp->in_params[config->int_in - 1U]  = sdup;
 80025ca:	62bc      	str	r4, [r7, #40]	; 0x28
  sdup->state = SDU_READY;
 80025cc:	f884 9008 	strb.w	r9, [r4, #8]
  _dbg_check_unlock();
 80025d0:	f7fe fe1e 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80025d4:	682b      	ldr	r3, [r5, #0]
 80025d6:	42ab      	cmp	r3, r5
 80025d8:	d004      	beq.n	80025e4 <main+0x4e4>
 80025da:	69aa      	ldr	r2, [r5, #24]
 80025dc:	689b      	ldr	r3, [r3, #8]
 80025de:	6892      	ldr	r2, [r2, #8]
 80025e0:	429a      	cmp	r2, r3
 80025e2:	d363      	bcc.n	80026ac <main+0x5ac>
 80025e4:	f04f 0a00 	mov.w	sl, #0
 80025e8:	f38a 8811 	msr	BASEPRI, sl
  /*
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbDisconnectBus(serusbcfg.usbp);
 80025ec:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80025ee:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80025f0:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80025f4:	6393      	str	r3, [r2, #56]	; 0x38
  chThdSleepMilliseconds(1500);
 80025f6:	f643 2098 	movw	r0, #15000	; 0x3a98
 80025fa:	f7ff f911 	bl	8001820 <chThdSleep>
 80025fe:	2020      	movs	r0, #32
 8002600:	f380 8811 	msr	BASEPRI, r0
 8002604:	9003      	str	r0, [sp, #12]
  _dbg_check_lock();
 8002606:	f7fe fe2b 	bl	8001260 <_dbg_check_lock>
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800260a:	f897 b000 	ldrb.w	fp, [r7]
 800260e:	9803      	ldr	r0, [sp, #12]
 8002610:	f10b 33ff 	add.w	r3, fp, #4294967295
 8002614:	2b01      	cmp	r3, #1
 8002616:	d902      	bls.n	800261e <main+0x51e>
 8002618:	4834      	ldr	r0, [pc, #208]	; (80026ec <main+0x5ec>)
 800261a:	f7fe f901 	bl	8000820 <chSysHalt>
                "invalid state");
  usbp->config = config;
 800261e:	4b34      	ldr	r3, [pc, #208]	; (80026f0 <main+0x5f0>)
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 8002620:	f8c7 a00c 	str.w	sl, [r7, #12]
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 8002624:	f1bb 0f01 	cmp.w	fp, #1
 8002628:	f8c7 a010 	str.w	sl, [r7, #16]
 800262c:	f8c7 a014 	str.w	sl, [r7, #20]
 8002630:	f8c7 a018 	str.w	sl, [r7, #24]
 8002634:	f8c7 a01c 	str.w	sl, [r7, #28]
 8002638:	f8c7 a020 	str.w	sl, [r7, #32]
  usbp->config = config;
 800263c:	607b      	str	r3, [r7, #4]
 800263e:	d06d      	beq.n	800271c <main+0x61c>
  }
  usb_lld_start(usbp);
  usbp->state = USB_READY;
 8002640:	2302      	movs	r3, #2
 8002642:	703b      	strb	r3, [r7, #0]
  _dbg_check_unlock();
 8002644:	f7fe fde4 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002648:	682b      	ldr	r3, [r5, #0]
 800264a:	42ab      	cmp	r3, r5
 800264c:	d005      	beq.n	800265a <main+0x55a>
 800264e:	69aa      	ldr	r2, [r5, #24]
 8002650:	689b      	ldr	r3, [r3, #8]
 8002652:	6892      	ldr	r2, [r2, #8]
 8002654:	429a      	cmp	r2, r3
 8002656:	f0c0 80d0 	bcc.w	80027fa <main+0x6fa>
 800265a:	2300      	movs	r3, #0
 800265c:	f383 8811 	msr	BASEPRI, r3
  usbStart(serusbcfg.usbp, &usbcfg);
  usbConnectBus(serusbcfg.usbp);
 8002660:	6efd      	ldr	r5, [r7, #108]	; 0x6c
 8002662:	4e24      	ldr	r6, [pc, #144]	; (80026f4 <main+0x5f4>)
 8002664:	6ba9      	ldr	r1, [r5, #56]	; 0x38
  shellInit();

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8002666:	4a24      	ldr	r2, [pc, #144]	; (80026f8 <main+0x5f8>)
 8002668:	4824      	ldr	r0, [pc, #144]	; (80026fc <main+0x5fc>)
 800266a:	6036      	str	r6, [r6, #0]
  usbConnectBus(serusbcfg.usbp);
 800266c:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
 8002670:	63a9      	str	r1, [r5, #56]	; 0x38
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8002672:	2180      	movs	r1, #128	; 0x80
 8002674:	f007 fc7c 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8002678:	4f21      	ldr	r7, [pc, #132]	; (8002700 <main+0x600>)
 800267a:	4e22      	ldr	r6, [pc, #136]	; (8002704 <main+0x604>)
  /*
   * Normal main() thread activity, spawning shells.
   */
  while (true) {
    if (SDU1.config->usbp->state == USB_ACTIVE) {
      thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
 800267c:	4d22      	ldr	r5, [pc, #136]	; (8002708 <main+0x608>)
 800267e:	e003      	b.n	8002688 <main+0x588>
                                              "shell", NORMALPRIO + 1,
                                              shellThread, (void *)&shell_cfg1);
      chThdWait(shelltp);               /* Waiting termination.             */
    }
    chThdSleepMilliseconds(1000);
 8002680:	f242 7010 	movw	r0, #10000	; 0x2710
 8002684:	f7ff f8cc 	bl	8001820 <chThdSleep>
    if (SDU1.config->usbp->state == USB_ACTIVE) {
 8002688:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
 800268c:	681b      	ldr	r3, [r3, #0]
 800268e:	781b      	ldrb	r3, [r3, #0]
 8002690:	2b04      	cmp	r3, #4
 8002692:	d1f5      	bne.n	8002680 <main+0x580>
      thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
 8002694:	2381      	movs	r3, #129	; 0x81
 8002696:	462a      	mov	r2, r5
 8002698:	f640 01c8 	movw	r1, #2248	; 0x8c8
 800269c:	e88d 00c0 	stmia.w	sp, {r6, r7}
 80026a0:	2000      	movs	r0, #0
 80026a2:	f7fe fded 	bl	8001280 <chThdCreateFromHeap>
      chThdWait(shelltp);               /* Waiting termination.             */
 80026a6:	f7ff f9f3 	bl	8001a90 <chThdWait>
 80026aa:	e7e9      	b.n	8002680 <main+0x580>
 80026ac:	4817      	ldr	r0, [pc, #92]	; (800270c <main+0x60c>)
 80026ae:	f7fe f8b7 	bl	8000820 <chSysHalt>
 80026b2:	bf00      	nop
 80026b4:	05fa0300 	.word	0x05fa0300
 80026b8:	0800a8a8 	.word	0x0800a8a8
 80026bc:	200026a8 	.word	0x200026a8
 80026c0:	e0001000 	.word	0xe0001000
 80026c4:	200014b8 	.word	0x200014b8
 80026c8:	0800a858 	.word	0x0800a858
 80026cc:	0800a908 	.word	0x0800a908
 80026d0:	20000c88 	.word	0x20000c88
 80026d4:	0800a964 	.word	0x0800a964
 80026d8:	08004681 	.word	0x08004681
 80026dc:	08004581 	.word	0x08004581
 80026e0:	0800a87c 	.word	0x0800a87c
 80026e4:	0800c508 	.word	0x0800c508
 80026e8:	0800a934 	.word	0x0800a934
 80026ec:	0800a888 	.word	0x0800a888
 80026f0:	0800a954 	.word	0x0800a954
 80026f4:	20001598 	.word	0x20001598
 80026f8:	08001c51 	.word	0x08001c51
 80026fc:	200015a8 	.word	0x200015a8
 8002700:	0800a93c 	.word	0x0800a93c
 8002704:	080063d1 	.word	0x080063d1
 8002708:	0800a92c 	.word	0x0800a92c
 800270c:	0800a828 	.word	0x0800a828
 8002710:	20020000 	.word	0x20020000
 8002714:	e000edf0 	.word	0xe000edf0
 8002718:	20000400 	.word	0x20000400
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(false);
 800271c:	4b44      	ldr	r3, [pc, #272]	; (8002830 <main+0x730>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800271e:	4a45      	ldr	r2, [pc, #276]	; (8002834 <main+0x734>)
 8002720:	6b59      	ldr	r1, [r3, #52]	; 0x34
  stm32_otg_t *otgp = usbp->otg;
 8002722:	f8d7 906c 	ldr.w	r9, [r7, #108]	; 0x6c
      rccEnableOTG_FS(false);
 8002726:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 800272a:	6359      	str	r1, [r3, #52]	; 0x34
      rccResetOTG_FS();
 800272c:	6959      	ldr	r1, [r3, #20]
 800272e:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8002732:	6159      	str	r1, [r3, #20]
 8002734:	f8c3 a014 	str.w	sl, [r3, #20]
 8002738:	23e0      	movs	r3, #224	; 0xe0
 800273a:	f882 3343 	strb.w	r3, [r2, #835]	; 0x343
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800273e:	2308      	movs	r3, #8
 8002740:	f8c2 3188 	str.w	r3, [r2, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002744:	6093      	str	r3, [r2, #8]
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8002746:	4a3c      	ldr	r2, [pc, #240]	; (8002838 <main+0x738>)
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8002748:	4b3c      	ldr	r3, [pc, #240]	; (800283c <main+0x73c>)
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 800274a:	f8c9 200c 	str.w	r2, [r9, #12]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 800274e:	f8c9 3800 	str.w	r3, [r9, #2048]	; 0x800

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8002752:	22c0      	movs	r2, #192	; 0xc0
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8002754:	f44f 2350 	mov.w	r3, #851968	; 0xd0000
    usbp->txpending = 0;
 8002758:	f8c7 a078 	str.w	sl, [r7, #120]	; 0x78
    otgp->PCGCCTL = 0;
 800275c:	f8c9 ae00 	str.w	sl, [r9, #3584]	; 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8002760:	f8c9 2000 	str.w	r2, [r9]
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8002764:	f8c9 3038 	str.w	r3, [r9, #56]	; 0x38
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8002768:	f7fe f84a 	bl	8000800 <chSysPolledDelayX>
  otgp->GRSTCTL = GRSTCTL_CSRST;
 800276c:	f8c9 b010 	str.w	fp, [r9, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8002770:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8002774:	f013 0a01 	ands.w	sl, r3, #1
 8002778:	d1fa      	bne.n	8002770 <main+0x670>
 800277a:	2012      	movs	r0, #18
 800277c:	f7fe f840 	bl	8000800 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8002780:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8002784:	2b00      	cmp	r3, #0
 8002786:	dafb      	bge.n	8002780 <main+0x680>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8002788:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800278a:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800278c:	f8d3 e008 	ldr.w	lr, [r3, #8]

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8002790:	2300      	movs	r3, #0
 8002792:	f8c9 3008 	str.w	r3, [r9, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8002796:	f04f 31ff 	mov.w	r1, #4294967295
 800279a:	eb00 124a 	add.w	r2, r0, sl, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800279e:	f10a 0a01 	add.w	sl, sl, #1
 80027a2:	45f2      	cmp	sl, lr
    otgp->ie[i].DIEPCTL = 0;
 80027a4:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
 80027a8:	f8c2 3910 	str.w	r3, [r2, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80027ac:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
 80027b0:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 80027b4:	f8c2 3b10 	str.w	r3, [r2, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80027b8:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80027bc:	d9ed      	bls.n	800279a <main+0x69a>
    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 80027be:	687a      	ldr	r2, [r7, #4]
 80027c0:	68d2      	ldr	r2, [r2, #12]
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80027c2:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 80027c6:	f8c0 181c 	str.w	r1, [r0, #2076]	; 0x81c
    otgp->DIEPMSK  = 0;
 80027ca:	f8c9 3810 	str.w	r3, [r9, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 80027ce:	f8c9 3814 	str.w	r3, [r9, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 80027d2:	f8c9 381c 	str.w	r3, [r9, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 80027d6:	b33a      	cbz	r2, 8002828 <main+0x728>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 80027d8:	4b19      	ldr	r3, [pc, #100]	; (8002840 <main+0x740>)
 80027da:	f8c9 3018 	str.w	r3, [r9, #24]
    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 80027de:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
    otgp->GINTSTS  = 0xFFFFFFFF;
 80027e2:	f04f 32ff 	mov.w	r2, #4294967295
 80027e6:	f8c9 2014 	str.w	r2, [r9, #20]
    if (usbp->tr == NULL) {
 80027ea:	b14b      	cbz	r3, 8002800 <main+0x700>
      chSchRescheduleS();
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 80027ec:	f8d9 3008 	ldr.w	r3, [r9, #8]
 80027f0:	f043 0301 	orr.w	r3, r3, #1
 80027f4:	f8c9 3008 	str.w	r3, [r9, #8]
 80027f8:	e722      	b.n	8002640 <main+0x540>
 80027fa:	4812      	ldr	r0, [pc, #72]	; (8002844 <main+0x744>)
 80027fc:	f7fe f810 	bl	8000820 <chSysHalt>
      thread_descriptor_t usbpump_descriptor = {
 8002800:	4911      	ldr	r1, [pc, #68]	; (8002848 <main+0x748>)
 8002802:	4b12      	ldr	r3, [pc, #72]	; (800284c <main+0x74c>)
 8002804:	9104      	str	r1, [sp, #16]
 8002806:	2202      	movs	r2, #2
  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8002808:	a804      	add	r0, sp, #16
 800280a:	9207      	str	r2, [sp, #28]
 800280c:	9308      	str	r3, [sp, #32]
 800280e:	9605      	str	r6, [sp, #20]
 8002810:	f8cd 8018 	str.w	r8, [sp, #24]
 8002814:	9709      	str	r7, [sp, #36]	; 0x24
 8002816:	f7fe f863 	bl	80008e0 <chThdCreateSuspendedI>
 800281a:	f7fe f919 	bl	8000a50 <chSchReadyI>
      usbp->tr = chThdCreateI(&usbpump_descriptor);
 800281e:	f8c7 0080 	str.w	r0, [r7, #128]	; 0x80
      chSchRescheduleS();
 8002822:	f7fe f8fd 	bl	8000a20 <chSchRescheduleS>
 8002826:	e7e1      	b.n	80027ec <main+0x6ec>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8002828:	4b09      	ldr	r3, [pc, #36]	; (8002850 <main+0x750>)
 800282a:	f8c9 3018 	str.w	r3, [r9, #24]
 800282e:	e7d6      	b.n	80027de <main+0x6de>
 8002830:	40023800 	.word	0x40023800
 8002834:	e000e100 	.word	0xe000e100
 8002838:	40001440 	.word	0x40001440
 800283c:	02200003 	.word	0x02200003
 8002840:	c0303c08 	.word	0xc0303c08
 8002844:	0800a84c 	.word	0x0800a84c
 8002848:	0800a920 	.word	0x0800a920
 800284c:	08009a81 	.word	0x08009a81
 8002850:	c0303c00 	.word	0xc0303c00
	...

08002860 <thread1.lto_priv.155>:
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 8002860:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 8002862:	4c06      	ldr	r4, [pc, #24]	; (800287c <thread1.lto_priv.155+0x1c>)
static THD_FUNCTION(thread1, p) {
 8002864:	4605      	mov	r5, r0
  chMtxLock(&m1);
 8002866:	4620      	mov	r0, r4
 8002868:	f7fe feb2 	bl	80015d0 <chMtxLock>
  test_emit_token(*(char *)p);
 800286c:	7828      	ldrb	r0, [r5, #0]
 800286e:	f007 f8d7 	bl	8009a20 <test_emit_token>
  chMtxUnlock(&m1);
 8002872:	4620      	mov	r0, r4
}
 8002874:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m1);
 8002878:	f7fe be4a 	b.w	8001510 <chMtxUnlock>
 800287c:	20000c50 	.word	0x20000c50

08002880 <test_004_005_setup.lto_priv.195>:
  tqp->next = (thread_t *)tqp;
 8002880:	4b02      	ldr	r3, [pc, #8]	; (800288c <test_004_005_setup.lto_priv.195+0xc>)
  sp->cnt = n;
 8002882:	2200      	movs	r2, #0
 8002884:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002886:	605b      	str	r3, [r3, #4]
 8002888:	609a      	str	r2, [r3, #8]
 800288a:	4770      	bx	lr
 800288c:	2000272c 	.word	0x2000272c

08002890 <test_004_004_setup.lto_priv.193>:
 8002890:	f7ff bff6 	b.w	8002880 <test_004_005_setup.lto_priv.195>
	...

080028a0 <test_004_003_setup.lto_priv.191>:
 80028a0:	f7ff bfee 	b.w	8002880 <test_004_005_setup.lto_priv.195>
	...

080028b0 <test_004_002_setup.lto_priv.189>:
 80028b0:	f7ff bfe6 	b.w	8002880 <test_004_005_setup.lto_priv.195>
	...

080028c0 <test_004_001_setup.lto_priv.186>:
  tqp->next = (thread_t *)tqp;
 80028c0:	4b02      	ldr	r3, [pc, #8]	; (80028cc <test_004_001_setup.lto_priv.186+0xc>)
 80028c2:	2201      	movs	r2, #1
 80028c4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80028c6:	605b      	str	r3, [r3, #4]
 80028c8:	609a      	str	r2, [r3, #8]
 80028ca:	4770      	bx	lr
 80028cc:	2000272c 	.word	0x2000272c

080028d0 <thread4A.lto_priv.152>:
  chMtxUnlock(&m2);
  test_emit_token('A');
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {
 80028d0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
 80028d2:	4c06      	ldr	r4, [pc, #24]	; (80028ec <thread4A.lto_priv.152+0x1c>)
  chThdSleepMilliseconds(50);
 80028d4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80028d8:	f7fe ffa2 	bl	8001820 <chThdSleep>
  chMtxLock(&m1);
 80028dc:	4620      	mov	r0, r4
 80028de:	f7fe fe77 	bl	80015d0 <chMtxLock>
  chMtxUnlock(&m1);
 80028e2:	4620      	mov	r0, r4
}
 80028e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMtxUnlock(&m1);
 80028e8:	f7fe be12 	b.w	8001510 <chMtxUnlock>
 80028ec:	20000c50 	.word	0x20000c50

080028f0 <test_004_001_teardown.lto_priv.187>:
static void test_004_001_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_004_001_teardown(void) {
  chSemReset(&sem1, 0);
 80028f0:	2100      	movs	r1, #0
 80028f2:	4801      	ldr	r0, [pc, #4]	; (80028f8 <test_004_001_teardown.lto_priv.187+0x8>)
 80028f4:	f7fe bf04 	b.w	8001700 <chSemReset>
 80028f8:	2000272c 	.word	0x2000272c
 80028fc:	00000000 	.word	0x00000000

08002900 <test_004_006_teardown.lto_priv.154>:
 *   must not change from "not taken".
 * .
 */

static void test_004_006_teardown(void) {
  test_wait_threads();
 8002900:	f006 b84e 	b.w	80089a0 <test_wait_threads>
	...

08002910 <test_004_005_teardown.lto_priv.196>:
 8002910:	f006 b846 	b.w	80089a0 <test_wait_threads>
	...

08002920 <test_004_005_execute.lto_priv.197>:
  return ch.rlist.current;
 8002920:	4b1e      	ldr	r3, [pc, #120]	; (800299c <test_004_005_execute.lto_priv.197+0x7c>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8002922:	4a1f      	ldr	r2, [pc, #124]	; (80029a0 <test_004_005_execute.lto_priv.197+0x80>)
  return chThdGetSelfX()->prio;
 8002924:	699b      	ldr	r3, [r3, #24]
 8002926:	481f      	ldr	r0, [pc, #124]	; (80029a4 <test_004_005_execute.lto_priv.197+0x84>)
 8002928:	6899      	ldr	r1, [r3, #8]
static void test_004_005_execute(void) {
 800292a:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 800292c:	4d1e      	ldr	r5, [pc, #120]	; (80029a8 <test_004_005_execute.lto_priv.197+0x88>)
  return (bool)(tqp->next == (const thread_t *)tqp);
 800292e:	4c1f      	ldr	r4, [pc, #124]	; (80029ac <test_004_005_execute.lto_priv.197+0x8c>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8002930:	3101      	adds	r1, #1
 8002932:	2300      	movs	r3, #0
  test_set_step(1);
 8002934:	2601      	movs	r6, #1
 8002936:	602e      	str	r6, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8002938:	f007 fb1a 	bl	8009f70 <chThdCreateStatic.constprop.72>
 800293c:	4a1c      	ldr	r2, [pc, #112]	; (80029b0 <test_004_005_execute.lto_priv.197+0x90>)
  test_set_step(2);
 800293e:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8002940:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 8002942:	602b      	str	r3, [r5, #0]
    chSemSignalWait(&sem1, &sem1);
 8002944:	f007 fb94 	bl	800a070 <chSemSignalWait.constprop.65>
 8002948:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800294a:	491a      	ldr	r1, [pc, #104]	; (80029b4 <test_004_005_execute.lto_priv.197+0x94>)
 800294c:	1b00      	subs	r0, r0, r4
 800294e:	fab0 f080 	clz	r0, r0
 8002952:	0940      	lsrs	r0, r0, #5
 8002954:	f006 ff3c 	bl	80097d0 <_test_assert>
 8002958:	b100      	cbz	r0, 800295c <test_004_005_execute.lto_priv.197+0x3c>
 800295a:	bd70      	pop	{r4, r5, r6, pc}
    test_assert(sem1.cnt == 0, "counter not zero");
 800295c:	68a0      	ldr	r0, [r4, #8]
 800295e:	4916      	ldr	r1, [pc, #88]	; (80029b8 <test_004_005_execute.lto_priv.197+0x98>)
 8002960:	fab0 f080 	clz	r0, r0
 8002964:	0940      	lsrs	r0, r0, #5
 8002966:	f006 ff33 	bl	80097d0 <_test_assert>
 800296a:	2800      	cmp	r0, #0
 800296c:	d1f5      	bne.n	800295a <test_004_005_execute.lto_priv.197+0x3a>
  test_set_step(3);
 800296e:	2303      	movs	r3, #3
 8002970:	602b      	str	r3, [r5, #0]
    chSemSignalWait(&sem1, &sem1);
 8002972:	f007 fb7d 	bl	800a070 <chSemSignalWait.constprop.65>
 8002976:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8002978:	490e      	ldr	r1, [pc, #56]	; (80029b4 <test_004_005_execute.lto_priv.197+0x94>)
 800297a:	1b00      	subs	r0, r0, r4
 800297c:	fab0 f080 	clz	r0, r0
 8002980:	0940      	lsrs	r0, r0, #5
 8002982:	f006 ff25 	bl	80097d0 <_test_assert>
 8002986:	2800      	cmp	r0, #0
 8002988:	d1e7      	bne.n	800295a <test_004_005_execute.lto_priv.197+0x3a>
    test_assert(sem1.cnt == 0, "counter not zero");
 800298a:	68a0      	ldr	r0, [r4, #8]
 800298c:	490a      	ldr	r1, [pc, #40]	; (80029b8 <test_004_005_execute.lto_priv.197+0x98>)
 800298e:	fab0 f080 	clz	r0, r0
 8002992:	0940      	lsrs	r0, r0, #5
}
 8002994:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert(sem1.cnt == 0, "counter not zero");
 8002998:	f006 bf1a 	b.w	80097d0 <_test_assert>
 800299c:	20001e68 	.word	0x20001e68
 80029a0:	08008831 	.word	0x08008831
 80029a4:	20001710 	.word	0x20001710
 80029a8:	20001df8 	.word	0x20001df8
 80029ac:	2000272c 	.word	0x2000272c
 80029b0:	20001d98 	.word	0x20001d98
 80029b4:	0800aa2c 	.word	0x0800aa2c
 80029b8:	0800aa3c 	.word	0x0800aa3c
 80029bc:	00000000 	.word	0x00000000

080029c0 <test_004_002_execute.lto_priv.190>:
static void test_004_002_execute(void) {
 80029c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 80029c4:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 8002aa8 <test_004_002_execute.lto_priv.190+0xe8>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80029c8:	4f2c      	ldr	r7, [pc, #176]	; (8002a7c <test_004_002_execute.lto_priv.190+0xbc>)
  return chThdGetSelfX()->prio;
 80029ca:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80029ce:	4e2c      	ldr	r6, [pc, #176]	; (8002a80 <test_004_002_execute.lto_priv.190+0xc0>)
 80029d0:	6899      	ldr	r1, [r3, #8]
  test_set_step(1);
 80029d2:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 8002aac <test_004_002_execute.lto_priv.190+0xec>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80029d6:	4b2b      	ldr	r3, [pc, #172]	; (8002a84 <test_004_002_execute.lto_priv.190+0xc4>)
 80029d8:	4d2b      	ldr	r5, [pc, #172]	; (8002a88 <test_004_002_execute.lto_priv.190+0xc8>)
 80029da:	463a      	mov	r2, r7
 80029dc:	3105      	adds	r1, #5
 80029de:	4630      	mov	r0, r6
  test_set_step(1);
 80029e0:	2401      	movs	r4, #1
 80029e2:	f8c9 4000 	str.w	r4, [r9]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80029e6:	f007 fac3 	bl	8009f70 <chThdCreateStatic.constprop.72>
 80029ea:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80029ee:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 80029f0:	6899      	ldr	r1, [r3, #8]
 80029f2:	4b26      	ldr	r3, [pc, #152]	; (8002a8c <test_004_002_execute.lto_priv.190+0xcc>)
    chSemSignal(&sem1);
 80029f4:	4c26      	ldr	r4, [pc, #152]	; (8002a90 <test_004_002_execute.lto_priv.190+0xd0>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 80029f6:	463a      	mov	r2, r7
 80029f8:	3101      	adds	r1, #1
 80029fa:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 80029fe:	f007 fab7 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8002a02:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8002a06:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8002a08:	6899      	ldr	r1, [r3, #8]
 8002a0a:	4b22      	ldr	r3, [pc, #136]	; (8002a94 <test_004_002_execute.lto_priv.190+0xd4>)
 8002a0c:	463a      	mov	r2, r7
 8002a0e:	3103      	adds	r1, #3
 8002a10:	f506 7024 	add.w	r0, r6, #656	; 0x290
 8002a14:	f007 faac 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8002a18:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8002a1c:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002a1e:	6899      	ldr	r1, [r3, #8]
 8002a20:	4b1d      	ldr	r3, [pc, #116]	; (8002a98 <test_004_002_execute.lto_priv.190+0xd8>)
 8002a22:	463a      	mov	r2, r7
 8002a24:	3104      	adds	r1, #4
 8002a26:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 8002a2a:	f007 faa1 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8002a2e:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8002a32:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8002a34:	6899      	ldr	r1, [r3, #8]
 8002a36:	4b19      	ldr	r3, [pc, #100]	; (8002a9c <test_004_002_execute.lto_priv.190+0xdc>)
 8002a38:	3102      	adds	r1, #2
 8002a3a:	463a      	mov	r2, r7
 8002a3c:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
 8002a40:	f007 fa96 	bl	8009f70 <chThdCreateStatic.constprop.72>
  test_set_step(2);
 8002a44:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8002a46:	6128      	str	r0, [r5, #16]
    chSemSignal(&sem1);
 8002a48:	4620      	mov	r0, r4
  test_set_step(2);
 8002a4a:	f8c9 3000 	str.w	r3, [r9]
    chSemSignal(&sem1);
 8002a4e:	f7fe fddf 	bl	8001610 <chSemSignal>
    chSemSignal(&sem1);
 8002a52:	4620      	mov	r0, r4
 8002a54:	f7fe fddc 	bl	8001610 <chSemSignal>
    chSemSignal(&sem1);
 8002a58:	4620      	mov	r0, r4
 8002a5a:	f7fe fdd9 	bl	8001610 <chSemSignal>
    chSemSignal(&sem1);
 8002a5e:	4620      	mov	r0, r4
 8002a60:	f7fe fdd6 	bl	8001610 <chSemSignal>
    chSemSignal(&sem1);
 8002a64:	4620      	mov	r0, r4
 8002a66:	f7fe fdd3 	bl	8001610 <chSemSignal>
    test_wait_threads();
 8002a6a:	f005 ff99 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8002a6e:	490c      	ldr	r1, [pc, #48]	; (8002aa0 <test_004_002_execute.lto_priv.190+0xe0>)
 8002a70:	480c      	ldr	r0, [pc, #48]	; (8002aa4 <test_004_002_execute.lto_priv.190+0xe4>)
}
 8002a72:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8002a76:	f006 be83 	b.w	8009780 <_test_assert_sequence>
 8002a7a:	bf00      	nop
 8002a7c:	08008851 	.word	0x08008851
 8002a80:	20001710 	.word	0x20001710
 8002a84:	0800a9dc 	.word	0x0800a9dc
 8002a88:	20001d98 	.word	0x20001d98
 8002a8c:	0800a9e0 	.word	0x0800a9e0
 8002a90:	2000272c 	.word	0x2000272c
 8002a94:	0800a9e4 	.word	0x0800a9e4
 8002a98:	0800b314 	.word	0x0800b314
 8002a9c:	0800aa00 	.word	0x0800aa00
 8002aa0:	0800a9e8 	.word	0x0800a9e8
 8002aa4:	0800a9fc 	.word	0x0800a9fc
 8002aa8:	20001e68 	.word	0x20001e68
 8002aac:	20001df8 	.word	0x20001df8

08002ab0 <thread6.lto_priv.149>:
  chSchRescheduleS();
  chSysUnlock();
}

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 8002ab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002ab2:	4606      	mov	r6, r0

  chMtxLock(&m1);
 8002ab4:	4821      	ldr	r0, [pc, #132]	; (8002b3c <thread6.lto_priv.149+0x8c>)
 8002ab6:	f7fe fd8b 	bl	80015d0 <chMtxLock>
 8002aba:	2320      	movs	r3, #32
 8002abc:	f383 8811 	msr	BASEPRI, r3
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 8002ac0:	4d1f      	ldr	r5, [pc, #124]	; (8002b40 <thread6.lto_priv.149+0x90>)
  _dbg_check_lock();
 8002ac2:	f7fe fbcd 	bl	8001260 <_dbg_check_lock>
 8002ac6:	69ac      	ldr	r4, [r5, #24]
  mutex_t *mp;
  msg_t msg;

  chDbgCheckClassS();
 8002ac8:	f7fd fec2 	bl	8000850 <chDbgCheckClassS>
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->mtxlist != NULL, "not owning a mutex");
 8002acc:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8002ace:	2f00      	cmp	r7, #0
 8002ad0:	d030      	beq.n	8002b34 <thread6.lto_priv.149+0x84>

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8002ad2:	4638      	mov	r0, r7
 8002ad4:	f7fe f82c 	bl	8000b30 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->u.wtobjp = cp;
 8002ad8:	481a      	ldr	r0, [pc, #104]	; (8002b44 <thread6.lto_priv.149+0x94>)
 8002ada:	6260      	str	r0, [r4, #36]	; 0x24
  thread_t *cp = (thread_t *)tqp;
 8002adc:	4603      	mov	r3, r0
 8002ade:	e003      	b.n	8002ae8 <thread6.lto_priv.149+0x38>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002ae0:	6899      	ldr	r1, [r3, #8]
 8002ae2:	68a2      	ldr	r2, [r4, #8]
 8002ae4:	4291      	cmp	r1, r2
 8002ae6:	d302      	bcc.n	8002aee <thread6.lto_priv.149+0x3e>
    cp = cp->queue.next;
 8002ae8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002aea:	4283      	cmp	r3, r0
 8002aec:	d1f8      	bne.n	8002ae0 <thread6.lto_priv.149+0x30>
  tp->queue.prev             = cp->queue.prev;
 8002aee:	685a      	ldr	r2, [r3, #4]
 8002af0:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 8002af2:	6023      	str	r3, [r4, #0]
  queue_prio_insert(ctp, &cp->queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 8002af4:	2007      	movs	r0, #7
  tp->queue.prev->queue.next = tp;
 8002af6:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8002af8:	605c      	str	r4, [r3, #4]
 8002afa:	f7fd feb9 	bl	8000870 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
  chMtxLockS(mp);
 8002afe:	4638      	mov	r0, r7
 8002b00:	f7fe f85e 	bl	8000bc0 <chMtxLockS>
  _dbg_check_unlock();
 8002b04:	f7fe fb84 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002b08:	682b      	ldr	r3, [r5, #0]
 8002b0a:	42ab      	cmp	r3, r5
 8002b0c:	d004      	beq.n	8002b18 <thread6.lto_priv.149+0x68>
 8002b0e:	69aa      	ldr	r2, [r5, #24]
 8002b10:	689b      	ldr	r3, [r3, #8]
 8002b12:	6892      	ldr	r2, [r2, #8]
 8002b14:	429a      	cmp	r2, r3
 8002b16:	d30a      	bcc.n	8002b2e <thread6.lto_priv.149+0x7e>
 8002b18:	2300      	movs	r3, #0
 8002b1a:	f383 8811 	msr	BASEPRI, r3
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 8002b1e:	7830      	ldrb	r0, [r6, #0]
 8002b20:	f006 ff7e 	bl	8009a20 <test_emit_token>
  chMtxUnlock(&m1);
 8002b24:	4805      	ldr	r0, [pc, #20]	; (8002b3c <thread6.lto_priv.149+0x8c>)
}
 8002b26:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chMtxUnlock(&m1);
 8002b2a:	f7fe bcf1 	b.w	8001510 <chMtxUnlock>
 8002b2e:	4806      	ldr	r0, [pc, #24]	; (8002b48 <thread6.lto_priv.149+0x98>)
 8002b30:	f7fd fe76 	bl	8000820 <chSysHalt>
  chDbgAssert(ctp->mtxlist != NULL, "not owning a mutex");
 8002b34:	4805      	ldr	r0, [pc, #20]	; (8002b4c <thread6.lto_priv.149+0x9c>)
 8002b36:	f7fd fe73 	bl	8000820 <chSysHalt>
 8002b3a:	bf00      	nop
 8002b3c:	20000c50 	.word	0x20000c50
 8002b40:	20001e68 	.word	0x20001e68
 8002b44:	20000c48 	.word	0x20000c48
 8002b48:	0800c52c 	.word	0x0800c52c
 8002b4c:	0800a990 	.word	0x0800a990

08002b50 <thread4B.lto_priv.153>:
static THD_FUNCTION(thread4B, p) {
 8002b50:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(150);
 8002b52:	f240 50dc 	movw	r0, #1500	; 0x5dc
 8002b56:	f7fe fe63 	bl	8001820 <chThdSleep>
 8002b5a:	2320      	movs	r3, #32
 8002b5c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002b60:	f7fe fb7e 	bl	8001260 <_dbg_check_lock>
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 8002b64:	480c      	ldr	r0, [pc, #48]	; (8002b98 <thread4B.lto_priv.153+0x48>)
 8002b66:	f7fe f82b 	bl	8000bc0 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 8002b6a:	480b      	ldr	r0, [pc, #44]	; (8002b98 <thread4B.lto_priv.153+0x48>)
 8002b6c:	f7fd ffe0 	bl	8000b30 <chMtxUnlockS>
  chSchRescheduleS();
 8002b70:	f7fd ff56 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8002b74:	f7fe fb4c 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002b78:	4b08      	ldr	r3, [pc, #32]	; (8002b9c <thread4B.lto_priv.153+0x4c>)
 8002b7a:	681a      	ldr	r2, [r3, #0]
 8002b7c:	429a      	cmp	r2, r3
 8002b7e:	d004      	beq.n	8002b8a <thread4B.lto_priv.153+0x3a>
 8002b80:	6999      	ldr	r1, [r3, #24]
 8002b82:	6893      	ldr	r3, [r2, #8]
 8002b84:	688a      	ldr	r2, [r1, #8]
 8002b86:	429a      	cmp	r2, r3
 8002b88:	d303      	bcc.n	8002b92 <thread4B.lto_priv.153+0x42>
 8002b8a:	2300      	movs	r3, #0
 8002b8c:	f383 8811 	msr	BASEPRI, r3
 8002b90:	bd08      	pop	{r3, pc}
 8002b92:	4803      	ldr	r0, [pc, #12]	; (8002ba0 <thread4B.lto_priv.153+0x50>)
 8002b94:	f7fd fe44 	bl	8000820 <chSysHalt>
 8002b98:	20000c24 	.word	0x20000c24
 8002b9c:	20001e68 	.word	0x20001e68
 8002ba0:	0800ad90 	.word	0x0800ad90
	...

08002bb0 <test_004_006_execute.lto_priv.198>:
}

static void test_004_006_execute(void) {
 8002bb0:	b5f0      	push	{r4, r5, r6, r7, lr}
  binary_semaphore_t bsem;
  msg_t msg;

  /* [4.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8002bb2:	4ea7      	ldr	r6, [pc, #668]	; (8002e50 <test_004_006_execute.lto_priv.198+0x2a0>)
static void test_004_006_execute(void) {
 8002bb4:	b085      	sub	sp, #20
  tqp->next = (thread_t *)tqp;
 8002bb6:	ac01      	add	r4, sp, #4
  test_set_step(1);
 8002bb8:	2201      	movs	r2, #1
 8002bba:	2300      	movs	r3, #0
 8002bbc:	9303      	str	r3, [sp, #12]
 8002bbe:	6032      	str	r2, [r6, #0]
 8002bc0:	9401      	str	r4, [sp, #4]
  tqp->prev = (thread_t *)tqp;
 8002bc2:	9402      	str	r4, [sp, #8]
 8002bc4:	2320      	movs	r3, #32
 8002bc6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002bca:	f7fe fb49 	bl	8001260 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();
 8002bce:	f7fd fe77 	bl	80008c0 <chDbgCheckClassI>

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8002bd2:	9803      	ldr	r0, [sp, #12]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8002bd4:	499f      	ldr	r1, [pc, #636]	; (8002e54 <test_004_006_execute.lto_priv.198+0x2a4>)
 8002bd6:	2800      	cmp	r0, #0
 8002bd8:	bfcc      	ite	gt
 8002bda:	2000      	movgt	r0, #0
 8002bdc:	2001      	movle	r0, #1
 8002bde:	f006 fdf7 	bl	80097d0 <_test_assert>
 8002be2:	b180      	cbz	r0, 8002c06 <test_004_006_execute.lto_priv.198+0x56>
  _dbg_check_unlock();
 8002be4:	f7fe fb14 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002be8:	4b9b      	ldr	r3, [pc, #620]	; (8002e58 <test_004_006_execute.lto_priv.198+0x2a8>)
 8002bea:	681a      	ldr	r2, [r3, #0]
 8002bec:	429a      	cmp	r2, r3
 8002bee:	d005      	beq.n	8002bfc <test_004_006_execute.lto_priv.198+0x4c>
 8002bf0:	6999      	ldr	r1, [r3, #24]
 8002bf2:	6893      	ldr	r3, [r2, #8]
 8002bf4:	688a      	ldr	r2, [r1, #8]
 8002bf6:	429a      	cmp	r2, r3
 8002bf8:	f0c0 811f 	bcc.w	8002e3a <test_004_006_execute.lto_priv.198+0x28a>
 8002bfc:	2300      	movs	r3, #0
 8002bfe:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
 8002c02:	b005      	add	sp, #20
 8002c04:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002c06:	4d94      	ldr	r5, [pc, #592]	; (8002e58 <test_004_006_execute.lto_priv.198+0x2a8>)
  _dbg_check_unlock();
 8002c08:	f7fe fb02 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002c0c:	682b      	ldr	r3, [r5, #0]
 8002c0e:	42ab      	cmp	r3, r5
 8002c10:	d005      	beq.n	8002c1e <test_004_006_execute.lto_priv.198+0x6e>
 8002c12:	69aa      	ldr	r2, [r5, #24]
 8002c14:	689b      	ldr	r3, [r3, #8]
 8002c16:	6892      	ldr	r2, [r2, #8]
 8002c18:	429a      	cmp	r2, r3
 8002c1a:	f0c0 810e 	bcc.w	8002e3a <test_004_006_execute.lto_priv.198+0x28a>
 8002c1e:	2100      	movs	r1, #0
 8002c20:	f381 8811 	msr	BASEPRI, r1
  test_set_step(2);
 8002c24:	2302      	movs	r3, #2
  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8002c26:	4620      	mov	r0, r4
 8002c28:	6033      	str	r3, [r6, #0]
 8002c2a:	f7fe fd69 	bl	8001700 <chSemReset>
 8002c2e:	2320      	movs	r3, #32
 8002c30:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002c34:	f7fe fb14 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8002c38:	f7fd fe42 	bl	80008c0 <chDbgCheckClassI>
  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8002c3c:	9803      	ldr	r0, [sp, #12]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8002c3e:	4985      	ldr	r1, [pc, #532]	; (8002e54 <test_004_006_execute.lto_priv.198+0x2a4>)
 8002c40:	2800      	cmp	r0, #0
 8002c42:	bfcc      	ite	gt
 8002c44:	2000      	movgt	r0, #0
 8002c46:	2001      	movle	r0, #1
 8002c48:	f006 fdc2 	bl	80097d0 <_test_assert>
 8002c4c:	2800      	cmp	r0, #0
 8002c4e:	f040 80e8 	bne.w	8002e22 <test_004_006_execute.lto_priv.198+0x272>
  _dbg_check_unlock();
 8002c52:	f7fe fadd 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002c56:	682b      	ldr	r3, [r5, #0]
 8002c58:	42ab      	cmp	r3, r5
 8002c5a:	d005      	beq.n	8002c68 <test_004_006_execute.lto_priv.198+0xb8>
 8002c5c:	69aa      	ldr	r2, [r5, #24]
 8002c5e:	689b      	ldr	r3, [r3, #8]
 8002c60:	6892      	ldr	r2, [r2, #8]
 8002c62:	429a      	cmp	r2, r3
 8002c64:	f0c0 80e9 	bcc.w	8002e3a <test_004_006_execute.lto_priv.198+0x28a>
 8002c68:	2300      	movs	r3, #0
 8002c6a:	f383 8811 	msr	BASEPRI, r3
 8002c6e:	69ab      	ldr	r3, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8002c70:	4a7a      	ldr	r2, [pc, #488]	; (8002e5c <test_004_006_execute.lto_priv.198+0x2ac>)
 8002c72:	6899      	ldr	r1, [r3, #8]
 8002c74:	487a      	ldr	r0, [pc, #488]	; (8002e60 <test_004_006_execute.lto_priv.198+0x2b0>)
 8002c76:	3901      	subs	r1, #1
 8002c78:	4623      	mov	r3, r4
  test_set_step(3);
 8002c7a:	2703      	movs	r7, #3
 8002c7c:	6037      	str	r7, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8002c7e:	f007 f977 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8002c82:	4a78      	ldr	r2, [pc, #480]	; (8002e64 <test_004_006_execute.lto_priv.198+0x2b4>)
  test_set_step(4);
 8002c84:	2304      	movs	r3, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8002c86:	6010      	str	r0, [r2, #0]
  return chSemWait(&bsp->sem);
 8002c88:	4620      	mov	r0, r4
  test_set_step(4);
 8002c8a:	6033      	str	r3, [r6, #0]
 8002c8c:	f7fe fcf8 	bl	8001680 <chSemWait>
 8002c90:	2320      	movs	r3, #32
 8002c92:	4607      	mov	r7, r0
 8002c94:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002c98:	f7fe fae2 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8002c9c:	f7fd fe10 	bl	80008c0 <chDbgCheckClassI>
  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8002ca0:	9803      	ldr	r0, [sp, #12]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8002ca2:	496c      	ldr	r1, [pc, #432]	; (8002e54 <test_004_006_execute.lto_priv.198+0x2a4>)
 8002ca4:	2800      	cmp	r0, #0
 8002ca6:	bfcc      	ite	gt
 8002ca8:	2000      	movgt	r0, #0
 8002caa:	2001      	movle	r0, #1
 8002cac:	f006 fd90 	bl	80097d0 <_test_assert>
 8002cb0:	2800      	cmp	r0, #0
 8002cb2:	f040 80b6 	bne.w	8002e22 <test_004_006_execute.lto_priv.198+0x272>
  _dbg_check_unlock();
 8002cb6:	f7fe faab 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002cba:	682b      	ldr	r3, [r5, #0]
 8002cbc:	42ab      	cmp	r3, r5
 8002cbe:	d005      	beq.n	8002ccc <test_004_006_execute.lto_priv.198+0x11c>
 8002cc0:	69aa      	ldr	r2, [r5, #24]
 8002cc2:	689b      	ldr	r3, [r3, #8]
 8002cc4:	6892      	ldr	r2, [r2, #8]
 8002cc6:	429a      	cmp	r2, r3
 8002cc8:	f0c0 80b7 	bcc.w	8002e3a <test_004_006_execute.lto_priv.198+0x28a>
 8002ccc:	2300      	movs	r3, #0
 8002cce:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg == MSG_OK, "unexpected message");
 8002cd2:	fab7 f087 	clz	r0, r7
 8002cd6:	0940      	lsrs	r0, r0, #5
 8002cd8:	4963      	ldr	r1, [pc, #396]	; (8002e68 <test_004_006_execute.lto_priv.198+0x2b8>)
 8002cda:	f006 fd79 	bl	80097d0 <_test_assert>
 8002cde:	2800      	cmp	r0, #0
 8002ce0:	d18f      	bne.n	8002c02 <test_004_006_execute.lto_priv.198+0x52>
  test_set_step(5);
 8002ce2:	2305      	movs	r3, #5
 8002ce4:	6033      	str	r3, [r6, #0]
 8002ce6:	2320      	movs	r3, #32
 8002ce8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002cec:	f7fe fab8 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8002cf0:	f7fd fde6 	bl	80008c0 <chDbgCheckClassI>
  if (bsp->sem.cnt < (cnt_t)1) {
 8002cf4:	9b03      	ldr	r3, [sp, #12]
 8002cf6:	2b00      	cmp	r3, #0
 8002cf8:	f340 80a2 	ble.w	8002e40 <test_004_006_execute.lto_priv.198+0x290>
  chSchRescheduleS();
 8002cfc:	f7fd fe90 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8002d00:	f7fe fa86 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002d04:	682b      	ldr	r3, [r5, #0]
 8002d06:	42ab      	cmp	r3, r5
 8002d08:	d005      	beq.n	8002d16 <test_004_006_execute.lto_priv.198+0x166>
 8002d0a:	69aa      	ldr	r2, [r5, #24]
 8002d0c:	689b      	ldr	r3, [r3, #8]
 8002d0e:	6892      	ldr	r2, [r2, #8]
 8002d10:	429a      	cmp	r2, r3
 8002d12:	f0c0 8092 	bcc.w	8002e3a <test_004_006_execute.lto_priv.198+0x28a>
 8002d16:	2300      	movs	r3, #0
 8002d18:	f383 8811 	msr	BASEPRI, r3
 8002d1c:	2320      	movs	r3, #32
 8002d1e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002d22:	f7fe fa9d 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8002d26:	f7fd fdcb 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 8002d2a:	9803      	ldr	r0, [sp, #12]
 8002d2c:	494f      	ldr	r1, [pc, #316]	; (8002e6c <test_004_006_execute.lto_priv.198+0x2bc>)
 8002d2e:	2800      	cmp	r0, #0
 8002d30:	bfd4      	ite	le
 8002d32:	2000      	movle	r0, #0
 8002d34:	2001      	movgt	r0, #1
 8002d36:	f006 fd4b 	bl	80097d0 <_test_assert>
 8002d3a:	2800      	cmp	r0, #0
 8002d3c:	d171      	bne.n	8002e22 <test_004_006_execute.lto_priv.198+0x272>
  _dbg_check_unlock();
 8002d3e:	f7fe fa67 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002d42:	682b      	ldr	r3, [r5, #0]
 8002d44:	42ab      	cmp	r3, r5
 8002d46:	d004      	beq.n	8002d52 <test_004_006_execute.lto_priv.198+0x1a2>
 8002d48:	69aa      	ldr	r2, [r5, #24]
 8002d4a:	689b      	ldr	r3, [r3, #8]
 8002d4c:	6892      	ldr	r2, [r2, #8]
 8002d4e:	429a      	cmp	r2, r3
 8002d50:	d373      	bcc.n	8002e3a <test_004_006_execute.lto_priv.198+0x28a>
 8002d52:	2300      	movs	r3, #0
 8002d54:	f383 8811 	msr	BASEPRI, r3
 8002d58:	2320      	movs	r3, #32
 8002d5a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002d5e:	f7fe fa7f 	bl	8001260 <_dbg_check_lock>
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {

  chDbgCheckClassI();
 8002d62:	f7fd fdad 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8002d66:	9803      	ldr	r0, [sp, #12]
 8002d68:	4941      	ldr	r1, [pc, #260]	; (8002e70 <test_004_006_execute.lto_priv.198+0x2c0>)
 8002d6a:	f1a0 0001 	sub.w	r0, r0, #1
 8002d6e:	fab0 f080 	clz	r0, r0
 8002d72:	0940      	lsrs	r0, r0, #5
 8002d74:	f006 fd2c 	bl	80097d0 <_test_assert>
 8002d78:	2800      	cmp	r0, #0
 8002d7a:	d152      	bne.n	8002e22 <test_004_006_execute.lto_priv.198+0x272>
  _dbg_check_unlock();
 8002d7c:	f7fe fa48 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002d80:	682b      	ldr	r3, [r5, #0]
 8002d82:	42ab      	cmp	r3, r5
 8002d84:	d004      	beq.n	8002d90 <test_004_006_execute.lto_priv.198+0x1e0>
 8002d86:	69aa      	ldr	r2, [r5, #24]
 8002d88:	689b      	ldr	r3, [r3, #8]
 8002d8a:	6892      	ldr	r2, [r2, #8]
 8002d8c:	429a      	cmp	r2, r3
 8002d8e:	d354      	bcc.n	8002e3a <test_004_006_execute.lto_priv.198+0x28a>
 8002d90:	2300      	movs	r3, #0
 8002d92:	f383 8811 	msr	BASEPRI, r3
  test_set_step(6);
 8002d96:	2306      	movs	r3, #6
 8002d98:	6033      	str	r3, [r6, #0]
 8002d9a:	2320      	movs	r3, #32
 8002d9c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002da0:	f7fe fa5e 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8002da4:	f7fd fd8c 	bl	80008c0 <chDbgCheckClassI>
  if (bsp->sem.cnt < (cnt_t)1) {
 8002da8:	9b03      	ldr	r3, [sp, #12]
 8002daa:	2b00      	cmp	r3, #0
 8002dac:	dd4c      	ble.n	8002e48 <test_004_006_execute.lto_priv.198+0x298>
  chSchRescheduleS();
 8002dae:	f7fd fe37 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8002db2:	f7fe fa2d 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002db6:	682b      	ldr	r3, [r5, #0]
 8002db8:	42ab      	cmp	r3, r5
 8002dba:	d004      	beq.n	8002dc6 <test_004_006_execute.lto_priv.198+0x216>
 8002dbc:	69aa      	ldr	r2, [r5, #24]
 8002dbe:	689b      	ldr	r3, [r3, #8]
 8002dc0:	6892      	ldr	r2, [r2, #8]
 8002dc2:	429a      	cmp	r2, r3
 8002dc4:	d339      	bcc.n	8002e3a <test_004_006_execute.lto_priv.198+0x28a>
 8002dc6:	2300      	movs	r3, #0
 8002dc8:	f383 8811 	msr	BASEPRI, r3
 8002dcc:	2320      	movs	r3, #32
 8002dce:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002dd2:	f7fe fa45 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8002dd6:	f7fd fd73 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8002dda:	9803      	ldr	r0, [sp, #12]
 8002ddc:	4925      	ldr	r1, [pc, #148]	; (8002e74 <test_004_006_execute.lto_priv.198+0x2c4>)
 8002dde:	2800      	cmp	r0, #0
 8002de0:	bfd4      	ite	le
 8002de2:	2000      	movle	r0, #0
 8002de4:	2001      	movgt	r0, #1
 8002de6:	f006 fcf3 	bl	80097d0 <_test_assert>
 8002dea:	b9d0      	cbnz	r0, 8002e22 <test_004_006_execute.lto_priv.198+0x272>
  _dbg_check_unlock();
 8002dec:	f7fe fa10 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002df0:	682b      	ldr	r3, [r5, #0]
 8002df2:	42ab      	cmp	r3, r5
 8002df4:	d004      	beq.n	8002e00 <test_004_006_execute.lto_priv.198+0x250>
 8002df6:	69aa      	ldr	r2, [r5, #24]
 8002df8:	689b      	ldr	r3, [r3, #8]
 8002dfa:	6892      	ldr	r2, [r2, #8]
 8002dfc:	429a      	cmp	r2, r3
 8002dfe:	d31c      	bcc.n	8002e3a <test_004_006_execute.lto_priv.198+0x28a>
 8002e00:	2300      	movs	r3, #0
 8002e02:	f383 8811 	msr	BASEPRI, r3
 8002e06:	2320      	movs	r3, #32
 8002e08:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002e0c:	f7fe fa28 	bl	8001260 <_dbg_check_lock>
 8002e10:	f7fd fd56 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8002e14:	9803      	ldr	r0, [sp, #12]
 8002e16:	4916      	ldr	r1, [pc, #88]	; (8002e70 <test_004_006_execute.lto_priv.198+0x2c0>)
 8002e18:	1e43      	subs	r3, r0, #1
 8002e1a:	4258      	negs	r0, r3
 8002e1c:	4158      	adcs	r0, r3
 8002e1e:	f006 fcd7 	bl	80097d0 <_test_assert>
  _dbg_check_unlock();
 8002e22:	f7fe f9f5 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002e26:	682b      	ldr	r3, [r5, #0]
 8002e28:	42ab      	cmp	r3, r5
 8002e2a:	f43f aee7 	beq.w	8002bfc <test_004_006_execute.lto_priv.198+0x4c>
 8002e2e:	69aa      	ldr	r2, [r5, #24]
 8002e30:	689b      	ldr	r3, [r3, #8]
 8002e32:	6892      	ldr	r2, [r2, #8]
 8002e34:	429a      	cmp	r2, r3
 8002e36:	f4bf aee1 	bcs.w	8002bfc <test_004_006_execute.lto_priv.198+0x4c>
 8002e3a:	480f      	ldr	r0, [pc, #60]	; (8002e78 <test_004_006_execute.lto_priv.198+0x2c8>)
 8002e3c:	f7fd fcf0 	bl	8000820 <chSysHalt>
    chSemSignalI(&bsp->sem);
 8002e40:	4620      	mov	r0, r4
 8002e42:	f7fd ff35 	bl	8000cb0 <chSemSignalI>
 8002e46:	e759      	b.n	8002cfc <test_004_006_execute.lto_priv.198+0x14c>
 8002e48:	4620      	mov	r0, r4
 8002e4a:	f7fd ff31 	bl	8000cb0 <chSemSignalI>
 8002e4e:	e7ae      	b.n	8002dae <test_004_006_execute.lto_priv.198+0x1fe>
 8002e50:	20001df8 	.word	0x20001df8
 8002e54:	0800aa50 	.word	0x0800aa50
 8002e58:	20001e68 	.word	0x20001e68
 8002e5c:	080032c1 	.word	0x080032c1
 8002e60:	20001710 	.word	0x20001710
 8002e64:	20001d98 	.word	0x20001d98
 8002e68:	0800aa5c 	.word	0x0800aa5c
 8002e6c:	0800aa70 	.word	0x0800aa70
 8002e70:	0800aa7c 	.word	0x0800aa7c
 8002e74:	0800aa54 	.word	0x0800aa54
 8002e78:	0800a984 	.word	0x0800a984
 8002e7c:	00000000 	.word	0x00000000

08002e80 <test_004_004_execute.lto_priv.194>:
static void test_004_004_execute(void) {
 8002e80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 8002e82:	4e3e      	ldr	r6, [pc, #248]	; (8002f7c <test_004_004_execute.lto_priv.194+0xfc>)
  test_set_step(1);
 8002e84:	4c3e      	ldr	r4, [pc, #248]	; (8002f80 <test_004_004_execute.lto_priv.194+0x100>)
  return chThdGetSelfX()->prio;
 8002e86:	69b2      	ldr	r2, [r6, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8002e88:	4b3e      	ldr	r3, [pc, #248]	; (8002f84 <test_004_004_execute.lto_priv.194+0x104>)
 8002e8a:	6891      	ldr	r1, [r2, #8]
 8002e8c:	483e      	ldr	r0, [pc, #248]	; (8002f88 <test_004_004_execute.lto_priv.194+0x108>)
 8002e8e:	4a3f      	ldr	r2, [pc, #252]	; (8002f8c <test_004_004_execute.lto_priv.194+0x10c>)
 8002e90:	3101      	adds	r1, #1
  test_set_step(1);
 8002e92:	2501      	movs	r5, #1
 8002e94:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8002e96:	f007 f86b 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8002e9a:	4b3d      	ldr	r3, [pc, #244]	; (8002f90 <test_004_004_execute.lto_priv.194+0x110>)
  test_set_step(2);
 8002e9c:	2502      	movs	r5, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8002e9e:	6018      	str	r0, [r3, #0]
  test_set_step(2);
 8002ea0:	6025      	str	r5, [r4, #0]
 8002ea2:	2320      	movs	r3, #32
 8002ea4:	f383 8811 	msr	BASEPRI, r3
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {

  chDbgCheckClassI();
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8002ea8:	4c3a      	ldr	r4, [pc, #232]	; (8002f94 <test_004_004_execute.lto_priv.194+0x114>)
  _dbg_check_lock();
 8002eaa:	f7fe f9d9 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8002eae:	f7fd fd07 	bl	80008c0 <chDbgCheckClassI>
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
 8002eb2:	68a3      	ldr	r3, [r4, #8]
 8002eb4:	6822      	ldr	r2, [r4, #0]
 8002eb6:	2b00      	cmp	r3, #0
 8002eb8:	db04      	blt.n	8002ec4 <test_004_004_execute.lto_priv.194+0x44>
 8002eba:	42a2      	cmp	r2, r4
 8002ebc:	d004      	beq.n	8002ec8 <test_004_004_execute.lto_priv.194+0x48>
 8002ebe:	4836      	ldr	r0, [pc, #216]	; (8002f98 <test_004_004_execute.lto_priv.194+0x118>)
 8002ec0:	f7fd fcae 	bl	8000820 <chSysHalt>
 8002ec4:	42a2      	cmp	r2, r4
 8002ec6:	d0fa      	beq.n	8002ebe <test_004_004_execute.lto_priv.194+0x3e>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8002ec8:	2700      	movs	r7, #0
 8002eca:	e003      	b.n	8002ed4 <test_004_004_execute.lto_priv.194+0x54>
  while (n > (cnt_t)0) {
 8002ecc:	2d01      	cmp	r5, #1
 8002ece:	d00e      	beq.n	8002eee <test_004_004_execute.lto_priv.194+0x6e>
 8002ed0:	68a3      	ldr	r3, [r4, #8]
    }
    n--;
 8002ed2:	2501      	movs	r5, #1
    if (++sp->cnt <= (cnt_t)0) {
 8002ed4:	3301      	adds	r3, #1
 8002ed6:	2b00      	cmp	r3, #0
 8002ed8:	60a3      	str	r3, [r4, #8]
 8002eda:	dcf7      	bgt.n	8002ecc <test_004_004_execute.lto_priv.194+0x4c>
  thread_t *tp = tqp->next;
 8002edc:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 8002ede:	6803      	ldr	r3, [r0, #0]
 8002ee0:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002ee2:	605c      	str	r4, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8002ee4:	f7fd fdb4 	bl	8000a50 <chSchReadyI>
  while (n > (cnt_t)0) {
 8002ee8:	2d01      	cmp	r5, #1
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8002eea:	6247      	str	r7, [r0, #36]	; 0x24
  while (n > (cnt_t)0) {
 8002eec:	d1f0      	bne.n	8002ed0 <test_004_004_execute.lto_priv.194+0x50>
    chSchRescheduleS();
 8002eee:	f7fd fd97 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8002ef2:	f7fe f98d 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002ef6:	6833      	ldr	r3, [r6, #0]
 8002ef8:	42b3      	cmp	r3, r6
 8002efa:	d004      	beq.n	8002f06 <test_004_004_execute.lto_priv.194+0x86>
 8002efc:	69b2      	ldr	r2, [r6, #24]
 8002efe:	689b      	ldr	r3, [r3, #8]
 8002f00:	6892      	ldr	r2, [r2, #8]
 8002f02:	429a      	cmp	r2, r3
 8002f04:	d328      	bcc.n	8002f58 <test_004_004_execute.lto_priv.194+0xd8>
 8002f06:	2300      	movs	r3, #0
 8002f08:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 8002f0c:	f005 fd48 	bl	80089a0 <test_wait_threads>
 8002f10:	2320      	movs	r3, #32
 8002f12:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002f16:	f7fe f9a3 	bl	8001260 <_dbg_check_lock>
 8002f1a:	f7fd fcd1 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 8002f1e:	68a0      	ldr	r0, [r4, #8]
 8002f20:	491e      	ldr	r1, [pc, #120]	; (8002f9c <test_004_004_execute.lto_priv.194+0x11c>)
 8002f22:	f1a0 0001 	sub.w	r0, r0, #1
 8002f26:	fab0 f080 	clz	r0, r0
 8002f2a:	0940      	lsrs	r0, r0, #5
 8002f2c:	f006 fc50 	bl	80097d0 <_test_assert>
 8002f30:	b9a8      	cbnz	r0, 8002f5e <test_004_004_execute.lto_priv.194+0xde>
  _dbg_check_unlock();
 8002f32:	f7fe f96d 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002f36:	6833      	ldr	r3, [r6, #0]
 8002f38:	42b3      	cmp	r3, r6
 8002f3a:	d004      	beq.n	8002f46 <test_004_004_execute.lto_priv.194+0xc6>
 8002f3c:	69b2      	ldr	r2, [r6, #24]
 8002f3e:	689b      	ldr	r3, [r3, #8]
 8002f40:	6892      	ldr	r2, [r2, #8]
 8002f42:	429a      	cmp	r2, r3
 8002f44:	d308      	bcc.n	8002f58 <test_004_004_execute.lto_priv.194+0xd8>
 8002f46:	2300      	movs	r3, #0
 8002f48:	f383 8811 	msr	BASEPRI, r3
    test_assert_sequence("A", "invalid sequence");
 8002f4c:	4914      	ldr	r1, [pc, #80]	; (8002fa0 <test_004_004_execute.lto_priv.194+0x120>)
 8002f4e:	480d      	ldr	r0, [pc, #52]	; (8002f84 <test_004_004_execute.lto_priv.194+0x104>)
}
 8002f50:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("A", "invalid sequence");
 8002f54:	f006 bc14 	b.w	8009780 <_test_assert_sequence>
 8002f58:	4812      	ldr	r0, [pc, #72]	; (8002fa4 <test_004_004_execute.lto_priv.194+0x124>)
 8002f5a:	f7fd fc61 	bl	8000820 <chSysHalt>
  _dbg_check_unlock();
 8002f5e:	f7fe f957 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002f62:	6833      	ldr	r3, [r6, #0]
 8002f64:	42b3      	cmp	r3, r6
 8002f66:	d004      	beq.n	8002f72 <test_004_004_execute.lto_priv.194+0xf2>
 8002f68:	69b2      	ldr	r2, [r6, #24]
 8002f6a:	689b      	ldr	r3, [r3, #8]
 8002f6c:	6892      	ldr	r2, [r2, #8]
 8002f6e:	429a      	cmp	r2, r3
 8002f70:	d3f2      	bcc.n	8002f58 <test_004_004_execute.lto_priv.194+0xd8>
 8002f72:	2300      	movs	r3, #0
 8002f74:	f383 8811 	msr	BASEPRI, r3
 8002f78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002f7a:	bf00      	nop
 8002f7c:	20001e68 	.word	0x20001e68
 8002f80:	20001df8 	.word	0x20001df8
 8002f84:	0800a9dc 	.word	0x0800a9dc
 8002f88:	20001710 	.word	0x20001710
 8002f8c:	08008851 	.word	0x08008851
 8002f90:	20001d98 	.word	0x20001d98
 8002f94:	2000272c 	.word	0x2000272c
 8002f98:	0800a99c 	.word	0x0800a99c
 8002f9c:	0800aa1c 	.word	0x0800aa1c
 8002fa0:	0800a9e8 	.word	0x0800a9e8
 8002fa4:	0800a984 	.word	0x0800a984
	...

08002fb0 <test_004_003_execute.lto_priv.192>:
static void test_004_003_execute(void) {
 8002fb0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_set_step(1);
 8002fb4:	4d6b      	ldr	r5, [pc, #428]	; (8003164 <test_004_003_execute.lto_priv.192+0x1b4>)
 8002fb6:	2301      	movs	r3, #1
 8002fb8:	602b      	str	r3, [r5, #0]
 8002fba:	2320      	movs	r3, #32
 8002fbc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002fc0:	f7fe f94e 	bl	8001260 <_dbg_check_lock>
  msg = chSemWaitTimeoutS(sp, time);
 8002fc4:	2100      	movs	r1, #0
 8002fc6:	4868      	ldr	r0, [pc, #416]	; (8003168 <test_004_003_execute.lto_priv.192+0x1b8>)
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002fc8:	4c68      	ldr	r4, [pc, #416]	; (800316c <test_004_003_execute.lto_priv.192+0x1bc>)
 8002fca:	f7fd ffe1 	bl	8000f90 <chSemWaitTimeoutS>
 8002fce:	4606      	mov	r6, r0
  _dbg_check_unlock();
 8002fd0:	f7fe f91e 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002fd4:	6823      	ldr	r3, [r4, #0]
 8002fd6:	42a3      	cmp	r3, r4
 8002fd8:	d005      	beq.n	8002fe6 <test_004_003_execute.lto_priv.192+0x36>
 8002fda:	69a2      	ldr	r2, [r4, #24]
 8002fdc:	689b      	ldr	r3, [r3, #8]
 8002fde:	6892      	ldr	r2, [r2, #8]
 8002fe0:	429a      	cmp	r2, r3
 8002fe2:	f0c0 80bc 	bcc.w	800315e <test_004_003_execute.lto_priv.192+0x1ae>
 8002fe6:	2300      	movs	r3, #0
 8002fe8:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8002fec:	f1a6 30ff 	sub.w	r0, r6, #4294967295
 8002ff0:	fab0 f080 	clz	r0, r0
 8002ff4:	495e      	ldr	r1, [pc, #376]	; (8003170 <test_004_003_execute.lto_priv.192+0x1c0>)
 8002ff6:	0940      	lsrs	r0, r0, #5
 8002ff8:	f006 fbea 	bl	80097d0 <_test_assert>
 8002ffc:	b108      	cbz	r0, 8003002 <test_004_003_execute.lto_priv.192+0x52>
 8002ffe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return (bool)(tqp->next == (const thread_t *)tqp);
 8003002:	4e59      	ldr	r6, [pc, #356]	; (8003168 <test_004_003_execute.lto_priv.192+0x1b8>)
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8003004:	495b      	ldr	r1, [pc, #364]	; (8003174 <test_004_003_execute.lto_priv.192+0x1c4>)
 8003006:	6830      	ldr	r0, [r6, #0]
 8003008:	1b80      	subs	r0, r0, r6
 800300a:	fab0 f080 	clz	r0, r0
 800300e:	0940      	lsrs	r0, r0, #5
 8003010:	f006 fbde 	bl	80097d0 <_test_assert>
 8003014:	2800      	cmp	r0, #0
 8003016:	d1f2      	bne.n	8002ffe <test_004_003_execute.lto_priv.192+0x4e>
    test_assert(sem1.cnt == 0, "counter not zero");
 8003018:	68b0      	ldr	r0, [r6, #8]
 800301a:	4957      	ldr	r1, [pc, #348]	; (8003178 <test_004_003_execute.lto_priv.192+0x1c8>)
 800301c:	fab0 f080 	clz	r0, r0
 8003020:	0940      	lsrs	r0, r0, #5
 8003022:	f006 fbd5 	bl	80097d0 <_test_assert>
 8003026:	4603      	mov	r3, r0
 8003028:	2800      	cmp	r0, #0
 800302a:	d1e8      	bne.n	8002ffe <test_004_003_execute.lto_priv.192+0x4e>
 800302c:	69a1      	ldr	r1, [r4, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800302e:	4a53      	ldr	r2, [pc, #332]	; (800317c <test_004_003_execute.lto_priv.192+0x1cc>)
 8003030:	6889      	ldr	r1, [r1, #8]
 8003032:	4853      	ldr	r0, [pc, #332]	; (8003180 <test_004_003_execute.lto_priv.192+0x1d0>)
 8003034:	3901      	subs	r1, #1
  test_set_step(2);
 8003036:	2702      	movs	r7, #2
 8003038:	602f      	str	r7, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800303a:	f006 ff99 	bl	8009f70 <chThdCreateStatic.constprop.72>
 800303e:	4a51      	ldr	r2, [pc, #324]	; (8003184 <test_004_003_execute.lto_priv.192+0x1d4>)
 8003040:	2320      	movs	r3, #32
 8003042:	6010      	str	r0, [r2, #0]
 8003044:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003048:	f7fe f90a 	bl	8001260 <_dbg_check_lock>
 800304c:	f241 3188 	movw	r1, #5000	; 0x1388
 8003050:	4630      	mov	r0, r6
 8003052:	f7fd ff9d 	bl	8000f90 <chSemWaitTimeoutS>
 8003056:	4607      	mov	r7, r0
  _dbg_check_unlock();
 8003058:	f7fe f8da 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800305c:	6823      	ldr	r3, [r4, #0]
 800305e:	42a3      	cmp	r3, r4
 8003060:	d004      	beq.n	800306c <test_004_003_execute.lto_priv.192+0xbc>
 8003062:	69a2      	ldr	r2, [r4, #24]
 8003064:	689b      	ldr	r3, [r3, #8]
 8003066:	6892      	ldr	r2, [r2, #8]
 8003068:	429a      	cmp	r2, r3
 800306a:	d378      	bcc.n	800315e <test_004_003_execute.lto_priv.192+0x1ae>
 800306c:	2300      	movs	r3, #0
 800306e:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 8003072:	f005 fc95 	bl	80089a0 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 8003076:	fab7 f087 	clz	r0, r7
 800307a:	0940      	lsrs	r0, r0, #5
 800307c:	493c      	ldr	r1, [pc, #240]	; (8003170 <test_004_003_execute.lto_priv.192+0x1c0>)
 800307e:	f006 fba7 	bl	80097d0 <_test_assert>
 8003082:	2800      	cmp	r0, #0
 8003084:	d1bb      	bne.n	8002ffe <test_004_003_execute.lto_priv.192+0x4e>
 8003086:	6830      	ldr	r0, [r6, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8003088:	493a      	ldr	r1, [pc, #232]	; (8003174 <test_004_003_execute.lto_priv.192+0x1c4>)
 800308a:	1b80      	subs	r0, r0, r6
 800308c:	fab0 f080 	clz	r0, r0
 8003090:	0940      	lsrs	r0, r0, #5
 8003092:	f006 fb9d 	bl	80097d0 <_test_assert>
 8003096:	2800      	cmp	r0, #0
 8003098:	d1b1      	bne.n	8002ffe <test_004_003_execute.lto_priv.192+0x4e>
    test_assert(sem1.cnt == 0, "counter not zero");
 800309a:	68b0      	ldr	r0, [r6, #8]
 800309c:	4936      	ldr	r1, [pc, #216]	; (8003178 <test_004_003_execute.lto_priv.192+0x1c8>)
 800309e:	fab0 f080 	clz	r0, r0
 80030a2:	0940      	lsrs	r0, r0, #5
 80030a4:	f006 fb94 	bl	80097d0 <_test_assert>
 80030a8:	2800      	cmp	r0, #0
 80030aa:	d1a8      	bne.n	8002ffe <test_004_003_execute.lto_priv.192+0x4e>
  test_set_step(3);
 80030ac:	2303      	movs	r3, #3
 80030ae:	602b      	str	r3, [r5, #0]
    target_time = test_wait_tick() + MS2ST(5 * 50);
 80030b0:	f006 f89e 	bl	80091f0 <test_wait_tick>
 80030b4:	4f2c      	ldr	r7, [pc, #176]	; (8003168 <test_004_003_execute.lto_priv.192+0x1b8>)
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 80030b6:	f8df 90b8 	ldr.w	r9, [pc, #184]	; 8003170 <test_004_003_execute.lto_priv.192+0x1c0>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80030ba:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 8003174 <test_004_003_execute.lto_priv.192+0x1c4>
    target_time = test_wait_tick() + MS2ST(5 * 50);
 80030be:	2541      	movs	r5, #65	; 0x41
 80030c0:	4682      	mov	sl, r0
      test_emit_token('A' + i);
 80030c2:	4628      	mov	r0, r5
 80030c4:	f006 fcac 	bl	8009a20 <test_emit_token>
 80030c8:	2320      	movs	r3, #32
 80030ca:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80030ce:	f7fe f8c7 	bl	8001260 <_dbg_check_lock>
 80030d2:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80030d6:	4638      	mov	r0, r7
 80030d8:	f7fd ff5a 	bl	8000f90 <chSemWaitTimeoutS>
 80030dc:	4683      	mov	fp, r0
  _dbg_check_unlock();
 80030de:	f7fe f897 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80030e2:	6823      	ldr	r3, [r4, #0]
 80030e4:	42a3      	cmp	r3, r4
 80030e6:	d004      	beq.n	80030f2 <test_004_003_execute.lto_priv.192+0x142>
 80030e8:	69a2      	ldr	r2, [r4, #24]
 80030ea:	689b      	ldr	r3, [r3, #8]
 80030ec:	6892      	ldr	r2, [r2, #8]
 80030ee:	429a      	cmp	r2, r3
 80030f0:	d335      	bcc.n	800315e <test_004_003_execute.lto_priv.192+0x1ae>
 80030f2:	2300      	movs	r3, #0
 80030f4:	f383 8811 	msr	BASEPRI, r3
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 80030f8:	f1ab 30ff 	sub.w	r0, fp, #4294967295
 80030fc:	fab0 f080 	clz	r0, r0
 8003100:	0940      	lsrs	r0, r0, #5
 8003102:	4649      	mov	r1, r9
 8003104:	f006 fb64 	bl	80097d0 <_test_assert>
 8003108:	2800      	cmp	r0, #0
 800310a:	f47f af78 	bne.w	8002ffe <test_004_003_execute.lto_priv.192+0x4e>
 800310e:	6830      	ldr	r0, [r6, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8003110:	1b80      	subs	r0, r0, r6
 8003112:	fab0 f080 	clz	r0, r0
 8003116:	4641      	mov	r1, r8
 8003118:	0940      	lsrs	r0, r0, #5
 800311a:	f006 fb59 	bl	80097d0 <_test_assert>
 800311e:	2800      	cmp	r0, #0
 8003120:	f47f af6d 	bne.w	8002ffe <test_004_003_execute.lto_priv.192+0x4e>
      test_assert(sem1.cnt == 0, "counter not zero");
 8003124:	68b0      	ldr	r0, [r6, #8]
 8003126:	4914      	ldr	r1, [pc, #80]	; (8003178 <test_004_003_execute.lto_priv.192+0x1c8>)
 8003128:	fab0 f080 	clz	r0, r0
 800312c:	0940      	lsrs	r0, r0, #5
 800312e:	f006 fb4f 	bl	80097d0 <_test_assert>
 8003132:	2800      	cmp	r0, #0
 8003134:	f47f af63 	bne.w	8002ffe <test_004_003_execute.lto_priv.192+0x4e>
 8003138:	3501      	adds	r5, #1
 800313a:	b2ed      	uxtb	r5, r5
    for (i = 0; i < 5; i++) {
 800313c:	2d46      	cmp	r5, #70	; 0x46
 800313e:	d1c0      	bne.n	80030c2 <test_004_003_execute.lto_priv.192+0x112>
    test_assert_sequence("ABCDE", "invalid sequence");
 8003140:	4911      	ldr	r1, [pc, #68]	; (8003188 <test_004_003_execute.lto_priv.192+0x1d8>)
 8003142:	4812      	ldr	r0, [pc, #72]	; (800318c <test_004_003_execute.lto_priv.192+0x1dc>)
 8003144:	f006 fb1c 	bl	8009780 <_test_assert_sequence>
 8003148:	2800      	cmp	r0, #0
 800314a:	f47f af58 	bne.w	8002ffe <test_004_003_execute.lto_priv.192+0x4e>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800314e:	f60a 11d8 	addw	r1, sl, #2520	; 0x9d8
 8003152:	f60a 10c4 	addw	r0, sl, #2500	; 0x9c4
}
 8003156:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800315a:	f7fe be59 	b.w	8001e10 <_test_assert_time_window.constprop.3>
 800315e:	480c      	ldr	r0, [pc, #48]	; (8003190 <test_004_003_execute.lto_priv.192+0x1e0>)
 8003160:	f7fd fb5e 	bl	8000820 <chSysHalt>
 8003164:	20001df8 	.word	0x20001df8
 8003168:	2000272c 	.word	0x2000272c
 800316c:	20001e68 	.word	0x20001e68
 8003170:	0800aa04 	.word	0x0800aa04
 8003174:	0800aa2c 	.word	0x0800aa2c
 8003178:	0800aa3c 	.word	0x0800aa3c
 800317c:	08008b61 	.word	0x08008b61
 8003180:	20001710 	.word	0x20001710
 8003184:	20001d98 	.word	0x20001d98
 8003188:	0800a9e8 	.word	0x0800a9e8
 800318c:	0800a9fc 	.word	0x0800a9fc
 8003190:	0800c514 	.word	0x0800c514
	...

080031a0 <test_004_001_execute.lto_priv.188>:
static void test_004_001_execute(void) {
 80031a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    msg = chSemWait(&sem1);
 80031a2:	4c41      	ldr	r4, [pc, #260]	; (80032a8 <test_004_001_execute.lto_priv.188+0x108>)
  test_set_step(1);
 80031a4:	4e41      	ldr	r6, [pc, #260]	; (80032ac <test_004_001_execute.lto_priv.188+0x10c>)
 80031a6:	2301      	movs	r3, #1
    msg = chSemWait(&sem1);
 80031a8:	4620      	mov	r0, r4
  test_set_step(1);
 80031aa:	6033      	str	r3, [r6, #0]
    msg = chSemWait(&sem1);
 80031ac:	f7fe fa68 	bl	8001680 <chSemWait>
 80031b0:	2320      	movs	r3, #32
 80031b2:	4607      	mov	r7, r0
 80031b4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80031b8:	f7fe f852 	bl	8001260 <_dbg_check_lock>
 80031bc:	f7fd fb80 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 80031c0:	68a0      	ldr	r0, [r4, #8]
 80031c2:	493b      	ldr	r1, [pc, #236]	; (80032b0 <test_004_001_execute.lto_priv.188+0x110>)
 80031c4:	fab0 f080 	clz	r0, r0
 80031c8:	0940      	lsrs	r0, r0, #5
 80031ca:	f006 fb01 	bl	80097d0 <_test_assert>
 80031ce:	2800      	cmp	r0, #0
 80031d0:	d15b      	bne.n	800328a <test_004_001_execute.lto_priv.188+0xea>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80031d2:	4d38      	ldr	r5, [pc, #224]	; (80032b4 <test_004_001_execute.lto_priv.188+0x114>)
  _dbg_check_unlock();
 80031d4:	f7fe f81c 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80031d8:	682b      	ldr	r3, [r5, #0]
 80031da:	42ab      	cmp	r3, r5
 80031dc:	d004      	beq.n	80031e8 <test_004_001_execute.lto_priv.188+0x48>
 80031de:	69aa      	ldr	r2, [r5, #24]
 80031e0:	689b      	ldr	r3, [r3, #8]
 80031e2:	6892      	ldr	r2, [r2, #8]
 80031e4:	429a      	cmp	r2, r3
 80031e6:	d34d      	bcc.n	8003284 <test_004_001_execute.lto_priv.188+0xe4>
 80031e8:	2300      	movs	r3, #0
 80031ea:	f383 8811 	msr	BASEPRI, r3
    test_assert(MSG_OK == msg, "wrong returned message");
 80031ee:	fab7 f087 	clz	r0, r7
 80031f2:	0940      	lsrs	r0, r0, #5
 80031f4:	4930      	ldr	r1, [pc, #192]	; (80032b8 <test_004_001_execute.lto_priv.188+0x118>)
 80031f6:	f006 faeb 	bl	80097d0 <_test_assert>
 80031fa:	b100      	cbz	r0, 80031fe <test_004_001_execute.lto_priv.188+0x5e>
 80031fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(2);
 80031fe:	2302      	movs	r3, #2
    chSemSignal(&sem1);
 8003200:	4829      	ldr	r0, [pc, #164]	; (80032a8 <test_004_001_execute.lto_priv.188+0x108>)
  test_set_step(2);
 8003202:	6033      	str	r3, [r6, #0]
    chSemSignal(&sem1);
 8003204:	f7fe fa04 	bl	8001610 <chSemSignal>
 8003208:	2320      	movs	r3, #32
 800320a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800320e:	f7fe f827 	bl	8001260 <_dbg_check_lock>
 8003212:	f7fd fb55 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 8003216:	68a0      	ldr	r0, [r4, #8]
 8003218:	4925      	ldr	r1, [pc, #148]	; (80032b0 <test_004_001_execute.lto_priv.188+0x110>)
 800321a:	f1a0 0001 	sub.w	r0, r0, #1
 800321e:	fab0 f080 	clz	r0, r0
 8003222:	0940      	lsrs	r0, r0, #5
 8003224:	f006 fad4 	bl	80097d0 <_test_assert>
 8003228:	bb10      	cbnz	r0, 8003270 <test_004_001_execute.lto_priv.188+0xd0>
  _dbg_check_unlock();
 800322a:	f7fd fff1 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800322e:	682b      	ldr	r3, [r5, #0]
 8003230:	42ab      	cmp	r3, r5
 8003232:	d004      	beq.n	800323e <test_004_001_execute.lto_priv.188+0x9e>
 8003234:	69aa      	ldr	r2, [r5, #24]
 8003236:	689b      	ldr	r3, [r3, #8]
 8003238:	6892      	ldr	r2, [r2, #8]
 800323a:	429a      	cmp	r2, r3
 800323c:	d322      	bcc.n	8003284 <test_004_001_execute.lto_priv.188+0xe4>
 800323e:	2300      	movs	r3, #0
 8003240:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 8003244:	2303      	movs	r3, #3
    chSemReset(&sem1, 2);
 8003246:	2102      	movs	r1, #2
 8003248:	4817      	ldr	r0, [pc, #92]	; (80032a8 <test_004_001_execute.lto_priv.188+0x108>)
  test_set_step(3);
 800324a:	6033      	str	r3, [r6, #0]
    chSemReset(&sem1, 2);
 800324c:	f7fe fa58 	bl	8001700 <chSemReset>
 8003250:	2320      	movs	r3, #32
 8003252:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003256:	f7fe f803 	bl	8001260 <_dbg_check_lock>
 800325a:	f7fd fb31 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 800325e:	68a0      	ldr	r0, [r4, #8]
 8003260:	4913      	ldr	r1, [pc, #76]	; (80032b0 <test_004_001_execute.lto_priv.188+0x110>)
 8003262:	f1a0 0002 	sub.w	r0, r0, #2
 8003266:	fab0 f080 	clz	r0, r0
 800326a:	0940      	lsrs	r0, r0, #5
 800326c:	f006 fab0 	bl	80097d0 <_test_assert>
  _dbg_check_unlock();
 8003270:	f7fd ffce 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003274:	682b      	ldr	r3, [r5, #0]
 8003276:	42ab      	cmp	r3, r5
 8003278:	d012      	beq.n	80032a0 <test_004_001_execute.lto_priv.188+0x100>
 800327a:	69aa      	ldr	r2, [r5, #24]
 800327c:	689b      	ldr	r3, [r3, #8]
 800327e:	6892      	ldr	r2, [r2, #8]
 8003280:	429a      	cmp	r2, r3
 8003282:	d20d      	bcs.n	80032a0 <test_004_001_execute.lto_priv.188+0x100>
 8003284:	480d      	ldr	r0, [pc, #52]	; (80032bc <test_004_001_execute.lto_priv.188+0x11c>)
 8003286:	f7fd facb 	bl	8000820 <chSysHalt>
  _dbg_check_unlock();
 800328a:	f7fd ffc1 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800328e:	4b09      	ldr	r3, [pc, #36]	; (80032b4 <test_004_001_execute.lto_priv.188+0x114>)
 8003290:	681a      	ldr	r2, [r3, #0]
 8003292:	429a      	cmp	r2, r3
 8003294:	d004      	beq.n	80032a0 <test_004_001_execute.lto_priv.188+0x100>
 8003296:	6999      	ldr	r1, [r3, #24]
 8003298:	6893      	ldr	r3, [r2, #8]
 800329a:	688a      	ldr	r2, [r1, #8]
 800329c:	429a      	cmp	r2, r3
 800329e:	d3f1      	bcc.n	8003284 <test_004_001_execute.lto_priv.188+0xe4>
 80032a0:	2300      	movs	r3, #0
 80032a2:	f383 8811 	msr	BASEPRI, r3
 80032a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80032a8:	2000272c 	.word	0x2000272c
 80032ac:	20001df8 	.word	0x20001df8
 80032b0:	0800a9b0 	.word	0x0800a9b0
 80032b4:	20001e68 	.word	0x20001e68
 80032b8:	0800a9c4 	.word	0x0800a9c4
 80032bc:	0800a984 	.word	0x0800a984

080032c0 <thread4>:
static THD_FUNCTION(thread4, p) {
 80032c0:	b510      	push	{r4, lr}
 80032c2:	2320      	movs	r3, #32
 80032c4:	4604      	mov	r4, r0
 80032c6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80032ca:	f7fd ffc9 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 80032ce:	f7fd faf7 	bl	80008c0 <chDbgCheckClassI>
  if (bsp->sem.cnt < (cnt_t)1) {
 80032d2:	68a3      	ldr	r3, [r4, #8]
 80032d4:	2b00      	cmp	r3, #0
 80032d6:	dd13      	ble.n	8003300 <thread4+0x40>
  chSchRescheduleS();
 80032d8:	f7fd fba2 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 80032dc:	f7fd ff98 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80032e0:	4b09      	ldr	r3, [pc, #36]	; (8003308 <thread4+0x48>)
 80032e2:	681a      	ldr	r2, [r3, #0]
 80032e4:	429a      	cmp	r2, r3
 80032e6:	d004      	beq.n	80032f2 <thread4+0x32>
 80032e8:	6999      	ldr	r1, [r3, #24]
 80032ea:	6893      	ldr	r3, [r2, #8]
 80032ec:	688a      	ldr	r2, [r1, #8]
 80032ee:	429a      	cmp	r2, r3
 80032f0:	d303      	bcc.n	80032fa <thread4+0x3a>
 80032f2:	2300      	movs	r3, #0
 80032f4:	f383 8811 	msr	BASEPRI, r3
 80032f8:	bd10      	pop	{r4, pc}
 80032fa:	4804      	ldr	r0, [pc, #16]	; (800330c <thread4+0x4c>)
 80032fc:	f7fd fa90 	bl	8000820 <chSysHalt>
    chSemSignalI(&bsp->sem);
 8003300:	4620      	mov	r0, r4
 8003302:	f7fd fcd5 	bl	8000cb0 <chSemSignalI>
 8003306:	e7e7      	b.n	80032d8 <thread4+0x18>
 8003308:	20001e68 	.word	0x20001e68
 800330c:	0800a984 	.word	0x0800a984

08003310 <tmo.lto_priv.124>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
 8003310:	4770      	bx	lr
 8003312:	bf00      	nop
	...

08003320 <test_012_008_execute.lto_priv.253>:
 * - [12.8.2] Waiting one second then terminating the 5 threads.
 * - [12.8.3] The score is printed.
 * .
 */

static void test_012_008_execute(void) {
 8003320:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003324:	b083      	sub	sp, #12
  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
  {
    n = 0;
 8003326:	ac02      	add	r4, sp, #8
  return ch.rlist.current;
 8003328:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 80033fc <test_012_008_execute.lto_priv.253+0xdc>
  test_set_step(1);
 800332c:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8003400 <test_012_008_execute.lto_priv.253+0xe0>
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003330:	4f2d      	ldr	r7, [pc, #180]	; (80033e8 <test_012_008_execute.lto_priv.253+0xc8>)
 8003332:	4e2e      	ldr	r6, [pc, #184]	; (80033ec <test_012_008_execute.lto_priv.253+0xcc>)
 8003334:	4d2e      	ldr	r5, [pc, #184]	; (80033f0 <test_012_008_execute.lto_priv.253+0xd0>)
  test_set_step(1);
 8003336:	2201      	movs	r2, #1
    n = 0;
 8003338:	2300      	movs	r3, #0
 800333a:	f844 3d04 	str.w	r3, [r4, #-4]!
  test_set_step(1);
 800333e:	f8c9 2000 	str.w	r2, [r9]
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003342:	f005 ff55 	bl	80091f0 <test_wait_tick>
  return chThdGetSelfX()->prio;
 8003346:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800334a:	6899      	ldr	r1, [r3, #8]
 800334c:	463a      	mov	r2, r7
 800334e:	4623      	mov	r3, r4
 8003350:	3901      	subs	r1, #1
 8003352:	4630      	mov	r0, r6
 8003354:	f006 fe0c 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8003358:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800335c:	6028      	str	r0, [r5, #0]

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800335e:	6899      	ldr	r1, [r3, #8]
 8003360:	463a      	mov	r2, r7
 8003362:	4623      	mov	r3, r4
 8003364:	3901      	subs	r1, #1
 8003366:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 800336a:	f006 fe01 	bl	8009f70 <chThdCreateStatic.constprop.72>
 800336e:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8003372:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003374:	6899      	ldr	r1, [r3, #8]
 8003376:	463a      	mov	r2, r7
 8003378:	4623      	mov	r3, r4
 800337a:	3901      	subs	r1, #1
 800337c:	f506 7024 	add.w	r0, r6, #656	; 0x290
 8003380:	f006 fdf6 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8003384:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8003388:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800338a:	6899      	ldr	r1, [r3, #8]
 800338c:	463a      	mov	r2, r7
 800338e:	4623      	mov	r3, r4
 8003390:	3901      	subs	r1, #1
 8003392:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 8003396:	f006 fdeb 	bl	8009f70 <chThdCreateStatic.constprop.72>
 800339a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800339e:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80033a0:	6899      	ldr	r1, [r3, #8]
 80033a2:	463a      	mov	r2, r7
 80033a4:	3901      	subs	r1, #1
 80033a6:	4623      	mov	r3, r4
 80033a8:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
 80033ac:	f006 fde0 	bl	8009f70 <chThdCreateStatic.constprop.72>
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 80033b0:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80033b2:	6128      	str	r0, [r5, #16]
  {
    chThdSleepSeconds(1);
 80033b4:	f242 7010 	movw	r0, #10000	; 0x2710
  test_set_step(2);
 80033b8:	f8c9 3000 	str.w	r3, [r9]
    chThdSleepSeconds(1);
 80033bc:	f7fe fa30 	bl	8001820 <chThdSleep>
    test_terminate_threads();
 80033c0:	f005 ff3e 	bl	8009240 <test_terminate_threads>
    test_wait_threads();
 80033c4:	f005 faec 	bl	80089a0 <test_wait_threads>
  }

  /* [12.8.3] The score is printed.*/
  test_set_step(3);
 80033c8:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 80033ca:	480a      	ldr	r0, [pc, #40]	; (80033f4 <test_012_008_execute.lto_priv.253+0xd4>)
  test_set_step(3);
 80033cc:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 80033d0:	f006 f83e 	bl	8009450 <test_print>
    test_printn(n);
 80033d4:	9801      	ldr	r0, [sp, #4]
 80033d6:	f006 f853 	bl	8009480 <test_printn>
    test_println(" ctxswc/S");
 80033da:	4807      	ldr	r0, [pc, #28]	; (80033f8 <test_012_008_execute.lto_priv.253+0xd8>)
 80033dc:	f006 f818 	bl	8009410 <test_println>
  }
}
 80033e0:	b003      	add	sp, #12
 80033e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80033e6:	bf00      	nop
 80033e8:	08003411 	.word	0x08003411
 80033ec:	20001710 	.word	0x20001710
 80033f0:	20001d98 	.word	0x20001d98
 80033f4:	0800ac3c 	.word	0x0800ac3c
 80033f8:	0800ac4c 	.word	0x0800ac4c
 80033fc:	20001e68 	.word	0x20001e68
 8003400:	20001df8 	.word	0x20001df8
	...

08003410 <bmk_thread8>:
static THD_FUNCTION(bmk_thread8, p) {
 8003410:	b538      	push	{r3, r4, r5, lr}
 8003412:	4d09      	ldr	r5, [pc, #36]	; (8003438 <bmk_thread8+0x28>)
 8003414:	4604      	mov	r4, r0
    chThdYield();
 8003416:	f7fe f9bb 	bl	8001790 <chThdYield>
    chThdYield();
 800341a:	f7fe f9b9 	bl	8001790 <chThdYield>
    chThdYield();
 800341e:	f7fe f9b7 	bl	8001790 <chThdYield>
    chThdYield();
 8003422:	f7fe f9b5 	bl	8001790 <chThdYield>
    (*(uint32_t *)p) += 4;
 8003426:	6823      	ldr	r3, [r4, #0]
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8003428:	69aa      	ldr	r2, [r5, #24]
 800342a:	3304      	adds	r3, #4
 800342c:	6023      	str	r3, [r4, #0]
  } while(!chThdShouldTerminateX());
 800342e:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 8003432:	075b      	lsls	r3, r3, #29
 8003434:	d5ef      	bpl.n	8003416 <bmk_thread8+0x6>
}
 8003436:	bd38      	pop	{r3, r4, r5, pc}
 8003438:	20001e68 	.word	0x20001e68
 800343c:	00000000 	.word	0x00000000

08003440 <test_012_007_execute.lto_priv.252>:
static void test_012_007_execute(void) {
 8003440:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 8003444:	4d35      	ldr	r5, [pc, #212]	; (800351c <test_012_007_execute.lto_priv.252+0xdc>)
  test_set_step(1);
 8003446:	f8df 8104 	ldr.w	r8, [pc, #260]	; 800354c <test_012_007_execute.lto_priv.252+0x10c>
  return chThdGetSelfX()->prio;
 800344a:	69ab      	ldr	r3, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 800344c:	4a34      	ldr	r2, [pc, #208]	; (8003520 <test_012_007_execute.lto_priv.252+0xe0>)
 800344e:	6899      	ldr	r1, [r3, #8]
 8003450:	4834      	ldr	r0, [pc, #208]	; (8003524 <test_012_007_execute.lto_priv.252+0xe4>)
 8003452:	4c35      	ldr	r4, [pc, #212]	; (8003528 <test_012_007_execute.lto_priv.252+0xe8>)
      chSemReset(&sem1, 0);
 8003454:	4f35      	ldr	r7, [pc, #212]	; (800352c <test_012_007_execute.lto_priv.252+0xec>)
  test_set_step(1);
 8003456:	2301      	movs	r3, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8003458:	3105      	adds	r1, #5
  test_set_step(1);
 800345a:	f8c8 3000 	str.w	r3, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 800345e:	2300      	movs	r3, #0
 8003460:	f006 fd86 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8003464:	69ab      	ldr	r3, [r5, #24]
 8003466:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8003468:	6899      	ldr	r1, [r3, #8]
 800346a:	4a2d      	ldr	r2, [pc, #180]	; (8003520 <test_012_007_execute.lto_priv.252+0xe0>)
 800346c:	4830      	ldr	r0, [pc, #192]	; (8003530 <test_012_007_execute.lto_priv.252+0xf0>)
 800346e:	3104      	adds	r1, #4
 8003470:	2300      	movs	r3, #0
 8003472:	f006 fd7d 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8003476:	69ab      	ldr	r3, [r5, #24]
 8003478:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 800347a:	6899      	ldr	r1, [r3, #8]
 800347c:	4a28      	ldr	r2, [pc, #160]	; (8003520 <test_012_007_execute.lto_priv.252+0xe0>)
 800347e:	482d      	ldr	r0, [pc, #180]	; (8003534 <test_012_007_execute.lto_priv.252+0xf4>)
 8003480:	3103      	adds	r1, #3
 8003482:	2300      	movs	r3, #0
 8003484:	f006 fd74 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8003488:	69ab      	ldr	r3, [r5, #24]
 800348a:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 800348c:	6899      	ldr	r1, [r3, #8]
 800348e:	4a24      	ldr	r2, [pc, #144]	; (8003520 <test_012_007_execute.lto_priv.252+0xe0>)
 8003490:	4829      	ldr	r0, [pc, #164]	; (8003538 <test_012_007_execute.lto_priv.252+0xf8>)
 8003492:	3102      	adds	r1, #2
 8003494:	2300      	movs	r3, #0
 8003496:	f006 fd6b 	bl	8009f70 <chThdCreateStatic.constprop.72>
 800349a:	69ab      	ldr	r3, [r5, #24]
 800349c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 800349e:	6899      	ldr	r1, [r3, #8]
 80034a0:	4a1f      	ldr	r2, [pc, #124]	; (8003520 <test_012_007_execute.lto_priv.252+0xe0>)
 80034a2:	4826      	ldr	r0, [pc, #152]	; (800353c <test_012_007_execute.lto_priv.252+0xfc>)
 80034a4:	3101      	adds	r1, #1
 80034a6:	2300      	movs	r3, #0
 80034a8:	f006 fd62 	bl	8009f70 <chThdCreateStatic.constprop.72>
  test_set_step(2);
 80034ac:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 80034ae:	6120      	str	r0, [r4, #16]
  test_set_step(2);
 80034b0:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
 80034b4:	f005 fe9c 	bl	80091f0 <test_wait_tick>
    n = 0;
 80034b8:	2400      	movs	r4, #0
    start = test_wait_tick();
 80034ba:	4606      	mov	r6, r0
 80034bc:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
      chSemReset(&sem1, 0);
 80034c0:	2100      	movs	r1, #0
 80034c2:	4638      	mov	r0, r7
 80034c4:	f7fe f91c 	bl	8001700 <chSemReset>
 80034c8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    } while (chVTIsSystemTimeWithinX(start, end));
 80034ca:	f242 720f 	movw	r2, #9999	; 0x270f
 80034ce:	1b9b      	subs	r3, r3, r6
 80034d0:	4293      	cmp	r3, r2
      n++;
 80034d2:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 80034d6:	d9f3      	bls.n	80034c0 <test_012_007_execute.lto_priv.252+0x80>
  test_set_step(3);
 80034d8:	2303      	movs	r3, #3
 80034da:	f8c8 3000 	str.w	r3, [r8]
    test_terminate_threads();
 80034de:	f005 feaf 	bl	8009240 <test_terminate_threads>
    chSemReset(&sem1, 0);
 80034e2:	2100      	movs	r1, #0
 80034e4:	4811      	ldr	r0, [pc, #68]	; (800352c <test_012_007_execute.lto_priv.252+0xec>)
 80034e6:	f7fe f90b 	bl	8001700 <chSemReset>
    test_wait_threads();
 80034ea:	f005 fa59 	bl	80089a0 <test_wait_threads>
  test_set_step(4);
 80034ee:	2304      	movs	r3, #4
    test_print("--- Score : ");
 80034f0:	4813      	ldr	r0, [pc, #76]	; (8003540 <test_012_007_execute.lto_priv.252+0x100>)
  test_set_step(4);
 80034f2:	f8c8 3000 	str.w	r3, [r8]
    test_print("--- Score : ");
 80034f6:	f005 ffab 	bl	8009450 <test_print>
    test_printn(n);
 80034fa:	4620      	mov	r0, r4
 80034fc:	f005 ffc0 	bl	8009480 <test_printn>
    test_printn(n * 6);
 8003500:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    test_print(" reschedules/S, ");
 8003504:	480f      	ldr	r0, [pc, #60]	; (8003544 <test_012_007_execute.lto_priv.252+0x104>)
 8003506:	f005 ffa3 	bl	8009450 <test_print>
    test_printn(n * 6);
 800350a:	0060      	lsls	r0, r4, #1
 800350c:	f005 ffb8 	bl	8009480 <test_printn>
    test_println(" ctxswc/S");
 8003510:	480d      	ldr	r0, [pc, #52]	; (8003548 <test_012_007_execute.lto_priv.252+0x108>)
}
 8003512:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" ctxswc/S");
 8003516:	f005 bf7b 	b.w	8009410 <test_println>
 800351a:	bf00      	nop
 800351c:	20001e68 	.word	0x20001e68
 8003520:	08003551 	.word	0x08003551
 8003524:	20001710 	.word	0x20001710
 8003528:	20001d98 	.word	0x20001d98
 800352c:	20001dec 	.word	0x20001dec
 8003530:	20001858 	.word	0x20001858
 8003534:	200019a0 	.word	0x200019a0
 8003538:	20001ae8 	.word	0x20001ae8
 800353c:	20001c30 	.word	0x20001c30
 8003540:	0800ac3c 	.word	0x0800ac3c
 8003544:	0800ac28 	.word	0x0800ac28
 8003548:	0800ac4c 	.word	0x0800ac4c
 800354c:	20001df8 	.word	0x20001df8

08003550 <bmk_thread7>:
static THD_FUNCTION(bmk_thread7, p) {
 8003550:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 8003552:	4c08      	ldr	r4, [pc, #32]	; (8003574 <bmk_thread7+0x24>)
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8003554:	69a3      	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
 8003556:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800355a:	075a      	lsls	r2, r3, #29
 800355c:	d408      	bmi.n	8003570 <bmk_thread7+0x20>
    chSemWait(&sem1);
 800355e:	4d06      	ldr	r5, [pc, #24]	; (8003578 <bmk_thread7+0x28>)
 8003560:	4628      	mov	r0, r5
 8003562:	f7fe f88d 	bl	8001680 <chSemWait>
 8003566:	69a3      	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
 8003568:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800356c:	075b      	lsls	r3, r3, #29
 800356e:	d5f7      	bpl.n	8003560 <bmk_thread7+0x10>
 8003570:	bd38      	pop	{r3, r4, r5, pc}
 8003572:	bf00      	nop
 8003574:	20001e68 	.word	0x20001e68
 8003578:	20001dec 	.word	0x20001dec
 800357c:	00000000 	.word	0x00000000

08003580 <test_012_007_setup.lto_priv.251>:
  tqp->next = (thread_t *)tqp;
 8003580:	4b02      	ldr	r3, [pc, #8]	; (800358c <test_012_007_setup.lto_priv.251+0xc>)
  sp->cnt = n;
 8003582:	2200      	movs	r2, #0
 8003584:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8003586:	605b      	str	r3, [r3, #4]
 8003588:	609a      	str	r2, [r3, #8]
 800358a:	4770      	bx	lr
 800358c:	20001dec 	.word	0x20001dec

08003590 <test_011_002_setup.lto_priv.243>:
  mp->next = NULL;
 8003590:	4b03      	ldr	r3, [pc, #12]	; (80035a0 <test_011_002_setup.lto_priv.243+0x10>)
 8003592:	2200      	movs	r2, #0
  mp->object_size = size;
 8003594:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003598:	6059      	str	r1, [r3, #4]
  mp->next = NULL;
 800359a:	601a      	str	r2, [r3, #0]
  mp->provider = provider;
 800359c:	609a      	str	r2, [r3, #8]
 800359e:	4770      	bx	lr
 80035a0:	20002720 	.word	0x20002720
	...

080035b0 <test_012_006_execute.lto_priv.250>:
static void test_012_006_execute(void) {
 80035b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 80035b4:	4b17      	ldr	r3, [pc, #92]	; (8003614 <test_012_006_execute.lto_priv.250+0x64>)
  test_set_step(1);
 80035b6:	f8df 906c 	ldr.w	r9, [pc, #108]	; 8003624 <test_012_006_execute.lto_priv.250+0x74>
  return chThdGetSelfX()->prio;
 80035ba:	699b      	ldr	r3, [r3, #24]
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80035bc:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8003628 <test_012_006_execute.lto_priv.250+0x78>
  tprio_t prio = chThdGetPriorityX() + 1;
 80035c0:	689d      	ldr	r5, [r3, #8]
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80035c2:	4f15      	ldr	r7, [pc, #84]	; (8003618 <test_012_006_execute.lto_priv.250+0x68>)
  test_set_step(1);
 80035c4:	2301      	movs	r3, #1
  tprio_t prio = chThdGetPriorityX() + 1;
 80035c6:	441d      	add	r5, r3
  test_set_step(1);
 80035c8:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 80035cc:	f005 fe10 	bl	80091f0 <test_wait_tick>
    n = 0;
 80035d0:	2400      	movs	r4, #0
    start = test_wait_tick();
 80035d2:	4606      	mov	r6, r0
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80035d4:	2300      	movs	r3, #0
 80035d6:	4642      	mov	r2, r8
 80035d8:	4629      	mov	r1, r5
 80035da:	4638      	mov	r0, r7
 80035dc:	f006 fcc8 	bl	8009f70 <chThdCreateStatic.constprop.72>
 80035e0:	f7fe f986 	bl	80018f0 <chThdRelease>
 80035e4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 80035e8:	f242 720f 	movw	r2, #9999	; 0x270f
 80035ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80035ee:	1b9b      	subs	r3, r3, r6
 80035f0:	4293      	cmp	r3, r2
      n++;
 80035f2:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 80035f6:	d9ed      	bls.n	80035d4 <test_012_006_execute.lto_priv.250+0x24>
  test_set_step(2);
 80035f8:	2302      	movs	r3, #2
    test_print("--- Score : ");
 80035fa:	4808      	ldr	r0, [pc, #32]	; (800361c <test_012_006_execute.lto_priv.250+0x6c>)
  test_set_step(2);
 80035fc:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8003600:	f005 ff26 	bl	8009450 <test_print>
    test_printn(n);
 8003604:	4620      	mov	r0, r4
 8003606:	f005 ff3b 	bl	8009480 <test_printn>
    test_println(" threads/S");
 800360a:	4805      	ldr	r0, [pc, #20]	; (8003620 <test_012_006_execute.lto_priv.250+0x70>)
}
 800360c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" threads/S");
 8003610:	f005 befe 	b.w	8009410 <test_println>
 8003614:	20001e68 	.word	0x20001e68
 8003618:	20001710 	.word	0x20001710
 800361c:	0800ac3c 	.word	0x0800ac3c
 8003620:	0800ac1c 	.word	0x0800ac1c
 8003624:	20001df8 	.word	0x20001df8
 8003628:	08003e51 	.word	0x08003e51
 800362c:	00000000 	.word	0x00000000

08003630 <test_012_005_execute.lto_priv.249>:
static void test_012_005_execute(void) {
 8003630:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 8003634:	4b17      	ldr	r3, [pc, #92]	; (8003694 <test_012_005_execute.lto_priv.249+0x64>)
  test_set_step(1);
 8003636:	f8df 906c 	ldr.w	r9, [pc, #108]	; 80036a4 <test_012_005_execute.lto_priv.249+0x74>
  return chThdGetSelfX()->prio;
 800363a:	699b      	ldr	r3, [r3, #24]
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 800363c:	f8df 8068 	ldr.w	r8, [pc, #104]	; 80036a8 <test_012_005_execute.lto_priv.249+0x78>
  tprio_t prio = chThdGetPriorityX() - 1;
 8003640:	689d      	ldr	r5, [r3, #8]
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8003642:	4f15      	ldr	r7, [pc, #84]	; (8003698 <test_012_005_execute.lto_priv.249+0x68>)
  test_set_step(1);
 8003644:	2301      	movs	r3, #1
 8003646:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 800364a:	f005 fdd1 	bl	80091f0 <test_wait_tick>
  tprio_t prio = chThdGetPriorityX() - 1;
 800364e:	3d01      	subs	r5, #1
    n = 0;
 8003650:	2400      	movs	r4, #0
    start = test_wait_tick();
 8003652:	4606      	mov	r6, r0
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8003654:	2300      	movs	r3, #0
 8003656:	4642      	mov	r2, r8
 8003658:	4629      	mov	r1, r5
 800365a:	4638      	mov	r0, r7
 800365c:	f006 fc88 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8003660:	f7fe fa16 	bl	8001a90 <chThdWait>
 8003664:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 8003668:	f242 720f 	movw	r2, #9999	; 0x270f
 800366c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800366e:	1b9b      	subs	r3, r3, r6
 8003670:	4293      	cmp	r3, r2
      n++;
 8003672:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8003676:	d9ed      	bls.n	8003654 <test_012_005_execute.lto_priv.249+0x24>
  test_set_step(2);
 8003678:	2302      	movs	r3, #2
    test_print("--- Score : ");
 800367a:	4808      	ldr	r0, [pc, #32]	; (800369c <test_012_005_execute.lto_priv.249+0x6c>)
  test_set_step(2);
 800367c:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8003680:	f005 fee6 	bl	8009450 <test_print>
    test_printn(n);
 8003684:	4620      	mov	r0, r4
 8003686:	f005 fefb 	bl	8009480 <test_printn>
    test_println(" threads/S");
 800368a:	4805      	ldr	r0, [pc, #20]	; (80036a0 <test_012_005_execute.lto_priv.249+0x70>)
}
 800368c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" threads/S");
 8003690:	f005 bebe 	b.w	8009410 <test_println>
 8003694:	20001e68 	.word	0x20001e68
 8003698:	20001710 	.word	0x20001710
 800369c:	0800ac3c 	.word	0x0800ac3c
 80036a0:	0800ac1c 	.word	0x0800ac1c
 80036a4:	20001df8 	.word	0x20001df8
 80036a8:	08003e51 	.word	0x08003e51
 80036ac:	00000000 	.word	0x00000000

080036b0 <test_011_001_setup.lto_priv.241>:
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 80036b0:	4908      	ldr	r1, [pc, #32]	; (80036d4 <test_011_001_setup.lto_priv.241+0x24>)
  heapp->provider = NULL;
 80036b2:	4b09      	ldr	r3, [pc, #36]	; (80036d8 <test_011_001_setup.lto_priv.241+0x28>)
 *   freeing memory.
 * - [11.1.7] Getting heap info again for verification.
 * .
 */

static void test_011_001_setup(void) {
 80036b4:	b410      	push	{r4}
 80036b6:	2200      	movs	r2, #0
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 80036b8:	24cc      	movs	r4, #204	; 0xcc
 80036ba:	e881 0014 	stmia.w	r1, {r2, r4}
  tqp->next = (thread_t *)tqp;
 80036be:	f103 0010 	add.w	r0, r3, #16
  H_NEXT(&heapp->header) = hp;
 80036c2:	6099      	str	r1, [r3, #8]
  H_PAGES(&heapp->header) = 0;
 80036c4:	60da      	str	r2, [r3, #12]
 80036c6:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 80036c8:	6158      	str	r0, [r3, #20]
  heapp->provider = NULL;
 80036ca:	601a      	str	r2, [r3, #0]
 80036cc:	619a      	str	r2, [r3, #24]
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}
 80036ce:	bc10      	pop	{r4}
 80036d0:	4770      	bx	lr
 80036d2:	bf00      	nop
 80036d4:	20001710 	.word	0x20001710
 80036d8:	200016f0 	.word	0x200016f0
 80036dc:	00000000 	.word	0x00000000

080036e0 <bmk_thread1>:
static THD_FUNCTION(bmk_thread1, p) {
 80036e0:	b510      	push	{r4, lr}
    tp = chMsgWait();
 80036e2:	f7fd fe45 	bl	8001370 <chMsgWait>
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
 80036e6:	f890 2020 	ldrb.w	r2, [r0, #32]
 80036ea:	2a0d      	cmp	r2, #13
 80036ec:	d002      	beq.n	80036f4 <bmk_thread1+0x14>
 80036ee:	4805      	ldr	r0, [pc, #20]	; (8003704 <bmk_thread1+0x24>)
 80036f0:	f7fd f896 	bl	8000820 <chSysHalt>
  return tp->u.sentmsg;
 80036f4:	6a44      	ldr	r4, [r0, #36]	; 0x24
    chMsgRelease(tp, msg);
 80036f6:	4621      	mov	r1, r4
 80036f8:	f7fd fe0a 	bl	8001310 <chMsgRelease>
  } while (msg);
 80036fc:	2c00      	cmp	r4, #0
 80036fe:	d1f0      	bne.n	80036e2 <bmk_thread1+0x2>
}
 8003700:	bd10      	pop	{r4, pc}
 8003702:	bf00      	nop
 8003704:	0800aa90 	.word	0x0800aa90
	...

08003710 <msg_loop_test>:
NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 8003710:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003714:	4605      	mov	r5, r0
  start = test_wait_tick();
 8003716:	f005 fd6b 	bl	80091f0 <test_wait_tick>
  uint32_t n = 0;
 800371a:	2400      	movs	r4, #0
  start = test_wait_tick();
 800371c:	4680      	mov	r8, r0
 800371e:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
  } while (chVTIsSystemTimeWithinX(start, end));
 8003722:	f242 760f 	movw	r6, #9999	; 0x270f
    (void)chMsgSend(tp, 1);
 8003726:	2101      	movs	r1, #1
 8003728:	4628      	mov	r0, r5
 800372a:	f7fd fe59 	bl	80013e0 <chMsgSend>
 800372e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003730:	eba3 0308 	sub.w	r3, r3, r8
  } while (chVTIsSystemTimeWithinX(start, end));
 8003734:	42b3      	cmp	r3, r6
    n++;
 8003736:	f104 0401 	add.w	r4, r4, #1
  } while (chVTIsSystemTimeWithinX(start, end));
 800373a:	d9f4      	bls.n	8003726 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
 800373c:	4628      	mov	r0, r5
 800373e:	2100      	movs	r1, #0
 8003740:	f7fd fe4e 	bl	80013e0 <chMsgSend>
}
 8003744:	4620      	mov	r0, r4
 8003746:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800374a:	bf00      	nop
 800374c:	0000      	movs	r0, r0
	...

08003750 <test_012_003_execute.lto_priv.247>:
static void test_012_003_execute(void) {
 8003750:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 8003754:	4e2c      	ldr	r6, [pc, #176]	; (8003808 <test_012_003_execute.lto_priv.247+0xb8>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003756:	4d2d      	ldr	r5, [pc, #180]	; (800380c <test_012_003_execute.lto_priv.247+0xbc>)
  return chThdGetSelfX()->prio;
 8003758:	69b3      	ldr	r3, [r6, #24]
  test_set_step(1);
 800375a:	4f2d      	ldr	r7, [pc, #180]	; (8003810 <test_012_003_execute.lto_priv.247+0xc0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800375c:	6899      	ldr	r1, [r3, #8]
 800375e:	4a2d      	ldr	r2, [pc, #180]	; (8003814 <test_012_003_execute.lto_priv.247+0xc4>)
 8003760:	4c2d      	ldr	r4, [pc, #180]	; (8003818 <test_012_003_execute.lto_priv.247+0xc8>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8003762:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 8003828 <test_012_003_execute.lto_priv.247+0xd8>
  test_set_step(1);
 8003766:	f04f 0e01 	mov.w	lr, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800376a:	3101      	adds	r1, #1
 800376c:	4628      	mov	r0, r5
 800376e:	2300      	movs	r3, #0
  test_set_step(1);
 8003770:	f8c7 e000 	str.w	lr, [r7]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003774:	f006 fbfc 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8003778:	69b3      	ldr	r3, [r6, #24]
 800377a:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 800377c:	6899      	ldr	r1, [r3, #8]
  test_set_step(2);
 800377e:	f04f 0e02 	mov.w	lr, #2
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8003782:	4642      	mov	r2, r8
 8003784:	3902      	subs	r1, #2
 8003786:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 800378a:	2300      	movs	r3, #0
  test_set_step(2);
 800378c:	f8c7 e000 	str.w	lr, [r7]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8003790:	f006 fbee 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8003794:	69b3      	ldr	r3, [r6, #24]
 8003796:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8003798:	6899      	ldr	r1, [r3, #8]
 800379a:	4642      	mov	r2, r8
 800379c:	3903      	subs	r1, #3
 800379e:	f505 7024 	add.w	r0, r5, #656	; 0x290
 80037a2:	2300      	movs	r3, #0
 80037a4:	f006 fbe4 	bl	8009f70 <chThdCreateStatic.constprop.72>
 80037a8:	69b3      	ldr	r3, [r6, #24]
 80037aa:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 80037ac:	6899      	ldr	r1, [r3, #8]
 80037ae:	4642      	mov	r2, r8
 80037b0:	3904      	subs	r1, #4
 80037b2:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 80037b6:	2300      	movs	r3, #0
 80037b8:	f006 fbda 	bl	8009f70 <chThdCreateStatic.constprop.72>
 80037bc:	69b3      	ldr	r3, [r6, #24]
 80037be:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 80037c0:	6899      	ldr	r1, [r3, #8]
 80037c2:	4642      	mov	r2, r8
 80037c4:	3905      	subs	r1, #5
 80037c6:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 80037ca:	2300      	movs	r3, #0
 80037cc:	f006 fbd0 	bl	8009f70 <chThdCreateStatic.constprop.72>
  test_set_step(3);
 80037d0:	2303      	movs	r3, #3
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 80037d2:	6120      	str	r0, [r4, #16]
    n = msg_loop_test(threads[0]);
 80037d4:	6820      	ldr	r0, [r4, #0]
  test_set_step(3);
 80037d6:	603b      	str	r3, [r7, #0]
    n = msg_loop_test(threads[0]);
 80037d8:	f7ff ff9a 	bl	8003710 <msg_loop_test>
 80037dc:	4604      	mov	r4, r0
    test_wait_threads();
 80037de:	f005 f8df 	bl	80089a0 <test_wait_threads>
  test_set_step(4);
 80037e2:	2304      	movs	r3, #4
    test_print("--- Score : ");
 80037e4:	480d      	ldr	r0, [pc, #52]	; (800381c <test_012_003_execute.lto_priv.247+0xcc>)
  test_set_step(4);
 80037e6:	603b      	str	r3, [r7, #0]
    test_print("--- Score : ");
 80037e8:	f005 fe32 	bl	8009450 <test_print>
    test_printn(n);
 80037ec:	4620      	mov	r0, r4
 80037ee:	f005 fe47 	bl	8009480 <test_printn>
    test_print(" msgs/S, ");
 80037f2:	480b      	ldr	r0, [pc, #44]	; (8003820 <test_012_003_execute.lto_priv.247+0xd0>)
 80037f4:	f005 fe2c 	bl	8009450 <test_print>
    test_printn(n << 1);
 80037f8:	0060      	lsls	r0, r4, #1
 80037fa:	f005 fe41 	bl	8009480 <test_printn>
    test_println(" ctxswc/S");
 80037fe:	4809      	ldr	r0, [pc, #36]	; (8003824 <test_012_003_execute.lto_priv.247+0xd4>)
}
 8003800:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_println(" ctxswc/S");
 8003804:	f005 be04 	b.w	8009410 <test_println>
 8003808:	20001e68 	.word	0x20001e68
 800380c:	20001710 	.word	0x20001710
 8003810:	20001df8 	.word	0x20001df8
 8003814:	080036e1 	.word	0x080036e1
 8003818:	20001d98 	.word	0x20001d98
 800381c:	0800ac3c 	.word	0x0800ac3c
 8003820:	0800ac10 	.word	0x0800ac10
 8003824:	0800ac4c 	.word	0x0800ac4c
 8003828:	08003e51 	.word	0x08003e51
 800382c:	00000000 	.word	0x00000000

08003830 <test_012_002_execute.lto_priv.246>:
static void test_012_002_execute(void) {
 8003830:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 8003832:	4b14      	ldr	r3, [pc, #80]	; (8003884 <test_012_002_execute.lto_priv.246+0x54>)
  test_set_step(1);
 8003834:	4c14      	ldr	r4, [pc, #80]	; (8003888 <test_012_002_execute.lto_priv.246+0x58>)
  return chThdGetSelfX()->prio;
 8003836:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003838:	4a14      	ldr	r2, [pc, #80]	; (800388c <test_012_002_execute.lto_priv.246+0x5c>)
 800383a:	6899      	ldr	r1, [r3, #8]
 800383c:	4814      	ldr	r0, [pc, #80]	; (8003890 <test_012_002_execute.lto_priv.246+0x60>)
 800383e:	3101      	adds	r1, #1
  test_set_step(1);
 8003840:	2501      	movs	r5, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003842:	2300      	movs	r3, #0
  test_set_step(1);
 8003844:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003846:	f006 fb93 	bl	8009f70 <chThdCreateStatic.constprop.72>
 800384a:	4a12      	ldr	r2, [pc, #72]	; (8003894 <test_012_002_execute.lto_priv.246+0x64>)
  test_set_step(2);
 800384c:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800384e:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 8003850:	6023      	str	r3, [r4, #0]
    n = msg_loop_test(threads[0]);
 8003852:	f7ff ff5d 	bl	8003710 <msg_loop_test>
 8003856:	4605      	mov	r5, r0
    test_wait_threads();
 8003858:	f005 f8a2 	bl	80089a0 <test_wait_threads>
  test_set_step(3);
 800385c:	2303      	movs	r3, #3
    test_print("--- Score : ");
 800385e:	480e      	ldr	r0, [pc, #56]	; (8003898 <test_012_002_execute.lto_priv.246+0x68>)
  test_set_step(3);
 8003860:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
 8003862:	f005 fdf5 	bl	8009450 <test_print>
    test_printn(n);
 8003866:	4628      	mov	r0, r5
 8003868:	f005 fe0a 	bl	8009480 <test_printn>
    test_print(" msgs/S, ");
 800386c:	480b      	ldr	r0, [pc, #44]	; (800389c <test_012_002_execute.lto_priv.246+0x6c>)
 800386e:	f005 fdef 	bl	8009450 <test_print>
    test_printn(n << 1);
 8003872:	0068      	lsls	r0, r5, #1
 8003874:	f005 fe04 	bl	8009480 <test_printn>
    test_println(" ctxswc/S");
 8003878:	4809      	ldr	r0, [pc, #36]	; (80038a0 <test_012_002_execute.lto_priv.246+0x70>)
}
 800387a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println(" ctxswc/S");
 800387e:	f005 bdc7 	b.w	8009410 <test_println>
 8003882:	bf00      	nop
 8003884:	20001e68 	.word	0x20001e68
 8003888:	20001df8 	.word	0x20001df8
 800388c:	080036e1 	.word	0x080036e1
 8003890:	20001710 	.word	0x20001710
 8003894:	20001d98 	.word	0x20001d98
 8003898:	0800ac3c 	.word	0x0800ac3c
 800389c:	0800ac10 	.word	0x0800ac10
 80038a0:	0800ac4c 	.word	0x0800ac4c
	...

080038b0 <test_012_001_execute.lto_priv.245>:
static void test_012_001_execute(void) {
 80038b0:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 80038b2:	4b14      	ldr	r3, [pc, #80]	; (8003904 <test_012_001_execute.lto_priv.245+0x54>)
  test_set_step(1);
 80038b4:	4c14      	ldr	r4, [pc, #80]	; (8003908 <test_012_001_execute.lto_priv.245+0x58>)
  return chThdGetSelfX()->prio;
 80038b6:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80038b8:	4a14      	ldr	r2, [pc, #80]	; (800390c <test_012_001_execute.lto_priv.245+0x5c>)
 80038ba:	6899      	ldr	r1, [r3, #8]
 80038bc:	4814      	ldr	r0, [pc, #80]	; (8003910 <test_012_001_execute.lto_priv.245+0x60>)
 80038be:	3901      	subs	r1, #1
  test_set_step(1);
 80038c0:	2501      	movs	r5, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80038c2:	2300      	movs	r3, #0
  test_set_step(1);
 80038c4:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80038c6:	f006 fb53 	bl	8009f70 <chThdCreateStatic.constprop.72>
 80038ca:	4a12      	ldr	r2, [pc, #72]	; (8003914 <test_012_001_execute.lto_priv.245+0x64>)
  test_set_step(2);
 80038cc:	2302      	movs	r3, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80038ce:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 80038d0:	6023      	str	r3, [r4, #0]
    n = msg_loop_test(threads[0]);
 80038d2:	f7ff ff1d 	bl	8003710 <msg_loop_test>
 80038d6:	4605      	mov	r5, r0
    test_wait_threads();
 80038d8:	f005 f862 	bl	80089a0 <test_wait_threads>
  test_set_step(3);
 80038dc:	2303      	movs	r3, #3
    test_print("--- Score : ");
 80038de:	480e      	ldr	r0, [pc, #56]	; (8003918 <test_012_001_execute.lto_priv.245+0x68>)
  test_set_step(3);
 80038e0:	6023      	str	r3, [r4, #0]
    test_print("--- Score : ");
 80038e2:	f005 fdb5 	bl	8009450 <test_print>
    test_printn(n);
 80038e6:	4628      	mov	r0, r5
 80038e8:	f005 fdca 	bl	8009480 <test_printn>
    test_print(" msgs/S, ");
 80038ec:	480b      	ldr	r0, [pc, #44]	; (800391c <test_012_001_execute.lto_priv.245+0x6c>)
 80038ee:	f005 fdaf 	bl	8009450 <test_print>
    test_printn(n << 1);
 80038f2:	0068      	lsls	r0, r5, #1
 80038f4:	f005 fdc4 	bl	8009480 <test_printn>
    test_println(" ctxswc/S");
 80038f8:	4809      	ldr	r0, [pc, #36]	; (8003920 <test_012_001_execute.lto_priv.245+0x70>)
}
 80038fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_println(" ctxswc/S");
 80038fe:	f005 bd87 	b.w	8009410 <test_println>
 8003902:	bf00      	nop
 8003904:	20001e68 	.word	0x20001e68
 8003908:	20001df8 	.word	0x20001df8
 800390c:	080036e1 	.word	0x080036e1
 8003910:	20001710 	.word	0x20001710
 8003914:	20001d98 	.word	0x20001d98
 8003918:	0800ac3c 	.word	0x0800ac3c
 800391c:	0800ac10 	.word	0x0800ac10
 8003920:	0800ac4c 	.word	0x0800ac4c
	...

08003930 <dyn_thread1.lto_priv.91>:
 8003930:	f004 bf9e 	b.w	8008870 <thread.lto_priv.130>
	...

08003940 <test_011_001_execute.lto_priv.242>:

static void test_011_001_execute(void) {
 8003940:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 8003944:	4b46      	ldr	r3, [pc, #280]	; (8003a60 <test_011_001_execute.lto_priv.242+0x120>)
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8003946:	4c47      	ldr	r4, [pc, #284]	; (8003a64 <test_011_001_execute.lto_priv.242+0x124>)
  return chThdGetSelfX()->prio;
 8003948:	699b      	ldr	r3, [r3, #24]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 800394a:	4847      	ldr	r0, [pc, #284]	; (8003a68 <test_011_001_execute.lto_priv.242+0x128>)
 800394c:	689e      	ldr	r6, [r3, #8]
static void test_011_001_execute(void) {
 800394e:	b086      	sub	sp, #24
  test_set_step(2);
 8003950:	2302      	movs	r3, #2
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8003952:	a905      	add	r1, sp, #20
 8003954:	aa04      	add	r2, sp, #16
  test_set_step(2);
 8003956:	6023      	str	r3, [r4, #0]
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8003958:	f000 ff22 	bl	80047a0 <chHeapStatus>
 800395c:	4605      	mov	r5, r0
    test_assert(n1 == 1, "heap fragmented");
 800395e:	f1a0 0001 	sub.w	r0, r0, #1
 8003962:	fab0 f080 	clz	r0, r0
 8003966:	0940      	lsrs	r0, r0, #5
 8003968:	4940      	ldr	r1, [pc, #256]	; (8003a6c <test_011_001_execute.lto_priv.242+0x12c>)
 800396a:	f005 ff31 	bl	80097d0 <_test_assert>
 800396e:	b110      	cbz	r0, 8003976 <test_011_001_execute.lto_priv.242+0x36>
    n2 = chHeapStatus(&heap1, &total2, &largest2);
    test_assert(n1 == n2, "fragmentation changed");
    test_assert(total1 == total2, "total free space changed");
    test_assert(largest1 == largest2, "largest fragment size changed");
  }
}
 8003970:	b006      	add	sp, #24
 8003972:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    threads[0] = chThdCreateFromHeap(&heap1,
 8003976:	4b3e      	ldr	r3, [pc, #248]	; (8003a70 <test_011_001_execute.lto_priv.242+0x130>)
 8003978:	f8df 8130 	ldr.w	r8, [pc, #304]	; 8003aac <test_011_001_execute.lto_priv.242+0x16c>
 800397c:	9301      	str	r3, [sp, #4]
  test_set_step(3);
 800397e:	2103      	movs	r1, #3
 8003980:	6021      	str	r1, [r4, #0]
    threads[0] = chThdCreateFromHeap(&heap1,
 8003982:	f8cd 8000 	str.w	r8, [sp]
 8003986:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800398a:	1e73      	subs	r3, r6, #1
 800398c:	4a39      	ldr	r2, [pc, #228]	; (8003a74 <test_011_001_execute.lto_priv.242+0x134>)
 800398e:	4836      	ldr	r0, [pc, #216]	; (8003a68 <test_011_001_execute.lto_priv.242+0x128>)
 8003990:	4f39      	ldr	r7, [pc, #228]	; (8003a78 <test_011_001_execute.lto_priv.242+0x138>)
 8003992:	f7fd fc75 	bl	8001280 <chThdCreateFromHeap>
 8003996:	6038      	str	r0, [r7, #0]
    test_assert(threads[0] != NULL, "thread creation failed");
 8003998:	3000      	adds	r0, #0
 800399a:	bf18      	it	ne
 800399c:	2001      	movne	r0, #1
 800399e:	4937      	ldr	r1, [pc, #220]	; (8003a7c <test_011_001_execute.lto_priv.242+0x13c>)
 80039a0:	f005 ff16 	bl	80097d0 <_test_assert>
 80039a4:	2800      	cmp	r0, #0
 80039a6:	d1e3      	bne.n	8003970 <test_011_001_execute.lto_priv.242+0x30>
    threads[1] = chThdCreateFromHeap(&heap1,
 80039a8:	4b35      	ldr	r3, [pc, #212]	; (8003a80 <test_011_001_execute.lto_priv.242+0x140>)
 80039aa:	9301      	str	r3, [sp, #4]
  test_set_step(4);
 80039ac:	2104      	movs	r1, #4
    threads[1] = chThdCreateFromHeap(&heap1,
 80039ae:	1eb3      	subs	r3, r6, #2
  test_set_step(4);
 80039b0:	6021      	str	r1, [r4, #0]
    threads[1] = chThdCreateFromHeap(&heap1,
 80039b2:	f8cd 8000 	str.w	r8, [sp]
 80039b6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80039ba:	4a32      	ldr	r2, [pc, #200]	; (8003a84 <test_011_001_execute.lto_priv.242+0x144>)
 80039bc:	482a      	ldr	r0, [pc, #168]	; (8003a68 <test_011_001_execute.lto_priv.242+0x128>)
 80039be:	f7fd fc5f 	bl	8001280 <chThdCreateFromHeap>
 80039c2:	4603      	mov	r3, r0
    test_assert(threads[1] != NULL, "thread creation failed");
 80039c4:	3000      	adds	r0, #0
 80039c6:	bf18      	it	ne
 80039c8:	2001      	movne	r0, #1
 80039ca:	492c      	ldr	r1, [pc, #176]	; (8003a7c <test_011_001_execute.lto_priv.242+0x13c>)
    threads[1] = chThdCreateFromHeap(&heap1,
 80039cc:	607b      	str	r3, [r7, #4]
    test_assert(threads[1] != NULL, "thread creation failed");
 80039ce:	f005 feff 	bl	80097d0 <_test_assert>
 80039d2:	2800      	cmp	r0, #0
 80039d4:	d1cc      	bne.n	8003970 <test_011_001_execute.lto_priv.242+0x30>
    threads[2] = chThdCreateFromHeap(&heap1,
 80039d6:	4a2c      	ldr	r2, [pc, #176]	; (8003a88 <test_011_001_execute.lto_priv.242+0x148>)
 80039d8:	9201      	str	r2, [sp, #4]
 80039da:	1ef3      	subs	r3, r6, #3
 80039dc:	492b      	ldr	r1, [pc, #172]	; (8003a8c <test_011_001_execute.lto_priv.242+0x14c>)
 80039de:	f8cd 8000 	str.w	r8, [sp]
  test_set_step(5);
 80039e2:	2605      	movs	r6, #5
    threads[2] = chThdCreateFromHeap(&heap1,
 80039e4:	4a2a      	ldr	r2, [pc, #168]	; (8003a90 <test_011_001_execute.lto_priv.242+0x150>)
 80039e6:	4820      	ldr	r0, [pc, #128]	; (8003a68 <test_011_001_execute.lto_priv.242+0x128>)
  test_set_step(5);
 80039e8:	6026      	str	r6, [r4, #0]
    threads[2] = chThdCreateFromHeap(&heap1,
 80039ea:	f7fd fc49 	bl	8001280 <chThdCreateFromHeap>
 80039ee:	4603      	mov	r3, r0
    test_assert(threads[2] == NULL, "thread creation not failed");
 80039f0:	fab0 f080 	clz	r0, r0
 80039f4:	40f0      	lsrs	r0, r6
 80039f6:	4927      	ldr	r1, [pc, #156]	; (8003a94 <test_011_001_execute.lto_priv.242+0x154>)
    threads[2] = chThdCreateFromHeap(&heap1,
 80039f8:	60bb      	str	r3, [r7, #8]
    test_assert(threads[2] == NULL, "thread creation not failed");
 80039fa:	f005 fee9 	bl	80097d0 <_test_assert>
 80039fe:	2800      	cmp	r0, #0
 8003a00:	d1b6      	bne.n	8003970 <test_011_001_execute.lto_priv.242+0x30>
  test_set_step(6);
 8003a02:	2306      	movs	r3, #6
 8003a04:	6023      	str	r3, [r4, #0]
    test_wait_threads();
 8003a06:	f004 ffcb 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 8003a0a:	4923      	ldr	r1, [pc, #140]	; (8003a98 <test_011_001_execute.lto_priv.242+0x158>)
 8003a0c:	4823      	ldr	r0, [pc, #140]	; (8003a9c <test_011_001_execute.lto_priv.242+0x15c>)
 8003a0e:	f005 feb7 	bl	8009780 <_test_assert_sequence>
 8003a12:	2800      	cmp	r0, #0
 8003a14:	d1ac      	bne.n	8003970 <test_011_001_execute.lto_priv.242+0x30>
  test_set_step(7);
 8003a16:	2307      	movs	r3, #7
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8003a18:	a903      	add	r1, sp, #12
 8003a1a:	aa02      	add	r2, sp, #8
 8003a1c:	4812      	ldr	r0, [pc, #72]	; (8003a68 <test_011_001_execute.lto_priv.242+0x128>)
  test_set_step(7);
 8003a1e:	6023      	str	r3, [r4, #0]
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8003a20:	f000 febe 	bl	80047a0 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
 8003a24:	1a28      	subs	r0, r5, r0
 8003a26:	fab0 f080 	clz	r0, r0
 8003a2a:	491d      	ldr	r1, [pc, #116]	; (8003aa0 <test_011_001_execute.lto_priv.242+0x160>)
 8003a2c:	0940      	lsrs	r0, r0, #5
 8003a2e:	f005 fecf 	bl	80097d0 <_test_assert>
 8003a32:	2800      	cmp	r0, #0
 8003a34:	d19c      	bne.n	8003970 <test_011_001_execute.lto_priv.242+0x30>
    test_assert(total1 == total2, "total free space changed");
 8003a36:	9805      	ldr	r0, [sp, #20]
 8003a38:	9b03      	ldr	r3, [sp, #12]
 8003a3a:	491a      	ldr	r1, [pc, #104]	; (8003aa4 <test_011_001_execute.lto_priv.242+0x164>)
 8003a3c:	1ac0      	subs	r0, r0, r3
 8003a3e:	fab0 f080 	clz	r0, r0
 8003a42:	0940      	lsrs	r0, r0, #5
 8003a44:	f005 fec4 	bl	80097d0 <_test_assert>
 8003a48:	2800      	cmp	r0, #0
 8003a4a:	d191      	bne.n	8003970 <test_011_001_execute.lto_priv.242+0x30>
    test_assert(largest1 == largest2, "largest fragment size changed");
 8003a4c:	9804      	ldr	r0, [sp, #16]
 8003a4e:	9b02      	ldr	r3, [sp, #8]
 8003a50:	4915      	ldr	r1, [pc, #84]	; (8003aa8 <test_011_001_execute.lto_priv.242+0x168>)
 8003a52:	1ac0      	subs	r0, r0, r3
 8003a54:	fab0 f080 	clz	r0, r0
 8003a58:	0940      	lsrs	r0, r0, #5
 8003a5a:	f005 feb9 	bl	80097d0 <_test_assert>
 8003a5e:	e787      	b.n	8003970 <test_011_001_execute.lto_priv.242+0x30>
 8003a60:	20001e68 	.word	0x20001e68
 8003a64:	20001df8 	.word	0x20001df8
 8003a68:	200016f0 	.word	0x200016f0
 8003a6c:	0800ab20 	.word	0x0800ab20
 8003a70:	0800a9dc 	.word	0x0800a9dc
 8003a74:	0800ab30 	.word	0x0800ab30
 8003a78:	20001d98 	.word	0x20001d98
 8003a7c:	0800ab38 	.word	0x0800ab38
 8003a80:	0800a9e0 	.word	0x0800a9e0
 8003a84:	0800ab50 	.word	0x0800ab50
 8003a88:	0800a9e4 	.word	0x0800a9e4
 8003a8c:	000200c8 	.word	0x000200c8
 8003a90:	0800ab58 	.word	0x0800ab58
 8003a94:	0800ab60 	.word	0x0800ab60
 8003a98:	0800a9e8 	.word	0x0800a9e8
 8003a9c:	0800ab7c 	.word	0x0800ab7c
 8003aa0:	0800ab80 	.word	0x0800ab80
 8003aa4:	0800ab98 	.word	0x0800ab98
 8003aa8:	0800abb4 	.word	0x0800abb4
 8003aac:	08003931 	.word	0x08003931

08003ab0 <test_010_002_execute.lto_priv.240>:
 *   block is freed using chHeapFree(), must not fail.
 * - [10.2.2] Testing allocation failure.
 * .
 */

static void test_010_002_execute(void) {
 8003ab0:	b570      	push	{r4, r5, r6, lr}
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8003ab2:	4c14      	ldr	r4, [pc, #80]	; (8003b04 <test_010_002_execute.lto_priv.240+0x54>)
static void test_010_002_execute(void) {
 8003ab4:	b082      	sub	sp, #8
  test_set_step(1);
 8003ab6:	2301      	movs	r3, #1
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8003ab8:	466a      	mov	r2, sp
 8003aba:	a901      	add	r1, sp, #4
 8003abc:	2000      	movs	r0, #0
  test_set_step(1);
 8003abe:	6023      	str	r3, [r4, #0]
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8003ac0:	f000 fe6e 	bl	80047a0 <chHeapStatus>
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 8003ac4:	2110      	movs	r1, #16
 8003ac6:	4810      	ldr	r0, [pc, #64]	; (8003b08 <test_010_002_execute.lto_priv.240+0x58>)
 8003ac8:	f006 f9b2 	bl	8009e30 <chHeapAllocAligned.constprop.41>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 8003acc:	4606      	mov	r6, r0
 8003ace:	3000      	adds	r0, #0
 8003ad0:	bf18      	it	ne
 8003ad2:	2001      	movne	r0, #1
 8003ad4:	490d      	ldr	r1, [pc, #52]	; (8003b0c <test_010_002_execute.lto_priv.240+0x5c>)
 8003ad6:	f005 fe7b 	bl	80097d0 <_test_assert>
 8003ada:	b980      	cbnz	r0, 8003afe <test_010_002_execute.lto_priv.240+0x4e>
 8003adc:	4605      	mov	r5, r0
    chHeapFree(p1);
 8003ade:	4630      	mov	r0, r6
 8003ae0:	f000 fe96 	bl	8004810 <chHeapFree>
  }

  /* [10.2.2] Testing allocation failure.*/
  test_set_step(2);
 8003ae4:	2302      	movs	r3, #2
 8003ae6:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 8003aea:	4628      	mov	r0, r5
 8003aec:	6023      	str	r3, [r4, #0]
 8003aee:	f006 f99f 	bl	8009e30 <chHeapAllocAligned.constprop.41>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
 8003af2:	fab0 f080 	clz	r0, r0
 8003af6:	0940      	lsrs	r0, r0, #5
 8003af8:	4905      	ldr	r1, [pc, #20]	; (8003b10 <test_010_002_execute.lto_priv.240+0x60>)
 8003afa:	f005 fe69 	bl	80097d0 <_test_assert>
  }
}
 8003afe:	b002      	add	sp, #8
 8003b00:	bd70      	pop	{r4, r5, r6, pc}
 8003b02:	bf00      	nop
 8003b04:	20001df8 	.word	0x20001df8
 8003b08:	20001d78 	.word	0x20001d78
 8003b0c:	0800aaf4 	.word	0x0800aaf4
 8003b10:	0800ab08 	.word	0x0800ab08
	...

08003b20 <test_010_001_execute.lto_priv.239>:
static void test_010_001_execute(void) {
 8003b20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8003b24:	4cc0      	ldr	r4, [pc, #768]	; (8003e28 <test_010_001_execute.lto_priv.239+0x308>)
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8003b26:	48c1      	ldr	r0, [pc, #772]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
static void test_010_001_execute(void) {
 8003b28:	b084      	sub	sp, #16
  test_set_step(1);
 8003b2a:	2301      	movs	r3, #1
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8003b2c:	4669      	mov	r1, sp
 8003b2e:	2200      	movs	r2, #0
  test_set_step(1);
 8003b30:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8003b32:	f000 fe35 	bl	80047a0 <chHeapStatus>
 8003b36:	f1a0 0001 	sub.w	r0, r0, #1
 8003b3a:	fab0 f080 	clz	r0, r0
 8003b3e:	49bc      	ldr	r1, [pc, #752]	; (8003e30 <test_010_001_execute.lto_priv.239+0x310>)
 8003b40:	0940      	lsrs	r0, r0, #5
 8003b42:	f005 fe45 	bl	80097d0 <_test_assert>
 8003b46:	b110      	cbz	r0, 8003b4e <test_010_001_execute.lto_priv.239+0x2e>
}
 8003b48:	b004      	add	sp, #16
 8003b4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(2);
 8003b4e:	2302      	movs	r3, #2
 8003b50:	f44f 614d 	mov.w	r1, #3280	; 0xcd0
 8003b54:	48b5      	ldr	r0, [pc, #724]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003b56:	6023      	str	r3, [r4, #0]
 8003b58:	f006 f96a 	bl	8009e30 <chHeapAllocAligned.constprop.41>
    test_assert(p1 == NULL, "allocation not failed");
 8003b5c:	fab0 f080 	clz	r0, r0
 8003b60:	0940      	lsrs	r0, r0, #5
 8003b62:	49b4      	ldr	r1, [pc, #720]	; (8003e34 <test_010_001_execute.lto_priv.239+0x314>)
 8003b64:	f005 fe34 	bl	80097d0 <_test_assert>
 8003b68:	2800      	cmp	r0, #0
 8003b6a:	d1ed      	bne.n	8003b48 <test_010_001_execute.lto_priv.239+0x28>
  test_set_step(3);
 8003b6c:	2303      	movs	r3, #3
 8003b6e:	2110      	movs	r1, #16
 8003b70:	48ae      	ldr	r0, [pc, #696]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003b72:	6023      	str	r3, [r4, #0]
 8003b74:	f006 f95c 	bl	8009e30 <chHeapAllocAligned.constprop.41>
    test_assert(p1 != NULL, "allocation failed");
 8003b78:	4605      	mov	r5, r0
 8003b7a:	3000      	adds	r0, #0
 8003b7c:	bf18      	it	ne
 8003b7e:	2001      	movne	r0, #1
 8003b80:	49ad      	ldr	r1, [pc, #692]	; (8003e38 <test_010_001_execute.lto_priv.239+0x318>)
 8003b82:	f005 fe25 	bl	80097d0 <_test_assert>
 8003b86:	2800      	cmp	r0, #0
 8003b88:	d1de      	bne.n	8003b48 <test_010_001_execute.lto_priv.239+0x28>
    chHeapFree(p1);
 8003b8a:	4628      	mov	r0, r5
 8003b8c:	f000 fe40 	bl	8004810 <chHeapFree>
  test_set_step(4);
 8003b90:	2304      	movs	r3, #4
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8003b92:	a902      	add	r1, sp, #8
 8003b94:	aa03      	add	r2, sp, #12
 8003b96:	48a5      	ldr	r0, [pc, #660]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
  test_set_step(4);
 8003b98:	6023      	str	r3, [r4, #0]
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8003b9a:	f000 fe01 	bl	80047a0 <chHeapStatus>
 8003b9e:	4603      	mov	r3, r0
    test_assert(n == 1, "missing free block");
 8003ba0:	f1a0 0001 	sub.w	r0, r0, #1
 8003ba4:	fab0 f080 	clz	r0, r0
 8003ba8:	0940      	lsrs	r0, r0, #5
 8003baa:	49a4      	ldr	r1, [pc, #656]	; (8003e3c <test_010_001_execute.lto_priv.239+0x31c>)
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8003bac:	9301      	str	r3, [sp, #4]
    test_assert(n == 1, "missing free block");
 8003bae:	f005 fe0f 	bl	80097d0 <_test_assert>
 8003bb2:	2800      	cmp	r0, #0
 8003bb4:	d1c8      	bne.n	8003b48 <test_010_001_execute.lto_priv.239+0x28>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 8003bb6:	9802      	ldr	r0, [sp, #8]
 8003bb8:	49a1      	ldr	r1, [pc, #644]	; (8003e40 <test_010_001_execute.lto_priv.239+0x320>)
 8003bba:	280f      	cmp	r0, #15
 8003bbc:	bf94      	ite	ls
 8003bbe:	2000      	movls	r0, #0
 8003bc0:	2001      	movhi	r0, #1
 8003bc2:	f005 fe05 	bl	80097d0 <_test_assert>
 8003bc6:	2800      	cmp	r0, #0
 8003bc8:	d1be      	bne.n	8003b48 <test_010_001_execute.lto_priv.239+0x28>
    test_assert(total_size == largest_size, "unexpected heap state");
 8003bca:	9802      	ldr	r0, [sp, #8]
 8003bcc:	9b03      	ldr	r3, [sp, #12]
 8003bce:	499c      	ldr	r1, [pc, #624]	; (8003e40 <test_010_001_execute.lto_priv.239+0x320>)
 8003bd0:	1ac0      	subs	r0, r0, r3
 8003bd2:	fab0 f080 	clz	r0, r0
 8003bd6:	0940      	lsrs	r0, r0, #5
 8003bd8:	f005 fdfa 	bl	80097d0 <_test_assert>
 8003bdc:	4605      	mov	r5, r0
 8003bde:	2800      	cmp	r0, #0
 8003be0:	d1b2      	bne.n	8003b48 <test_010_001_execute.lto_priv.239+0x28>
  test_set_step(5);
 8003be2:	2305      	movs	r3, #5
 8003be4:	2110      	movs	r1, #16
 8003be6:	4891      	ldr	r0, [pc, #580]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003be8:	6023      	str	r3, [r4, #0]
 8003bea:	f006 f921 	bl	8009e30 <chHeapAllocAligned.constprop.41>
 8003bee:	2110      	movs	r1, #16
 8003bf0:	4680      	mov	r8, r0
 8003bf2:	488e      	ldr	r0, [pc, #568]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003bf4:	f006 f91c 	bl	8009e30 <chHeapAllocAligned.constprop.41>
 8003bf8:	2110      	movs	r1, #16
 8003bfa:	4607      	mov	r7, r0
 8003bfc:	488b      	ldr	r0, [pc, #556]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003bfe:	f006 f917 	bl	8009e30 <chHeapAllocAligned.constprop.41>
 8003c02:	4606      	mov	r6, r0
    chHeapFree(p1);                                 /* Does not merge.*/
 8003c04:	4640      	mov	r0, r8
 8003c06:	f000 fe03 	bl	8004810 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 8003c0a:	4638      	mov	r0, r7
 8003c0c:	f000 fe00 	bl	8004810 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 8003c10:	4630      	mov	r0, r6
 8003c12:	f000 fdfd 	bl	8004810 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8003c16:	462a      	mov	r2, r5
 8003c18:	a901      	add	r1, sp, #4
 8003c1a:	4884      	ldr	r0, [pc, #528]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003c1c:	f000 fdc0 	bl	80047a0 <chHeapStatus>
 8003c20:	f1a0 0001 	sub.w	r0, r0, #1
 8003c24:	fab0 f080 	clz	r0, r0
 8003c28:	4981      	ldr	r1, [pc, #516]	; (8003e30 <test_010_001_execute.lto_priv.239+0x310>)
 8003c2a:	0940      	lsrs	r0, r0, #5
 8003c2c:	f005 fdd0 	bl	80097d0 <_test_assert>
 8003c30:	4605      	mov	r5, r0
 8003c32:	2800      	cmp	r0, #0
 8003c34:	d188      	bne.n	8003b48 <test_010_001_execute.lto_priv.239+0x28>
  test_set_step(6);
 8003c36:	2306      	movs	r3, #6
 8003c38:	2110      	movs	r1, #16
 8003c3a:	487c      	ldr	r0, [pc, #496]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003c3c:	6023      	str	r3, [r4, #0]
 8003c3e:	f006 f8f7 	bl	8009e30 <chHeapAllocAligned.constprop.41>
 8003c42:	2110      	movs	r1, #16
 8003c44:	4606      	mov	r6, r0
 8003c46:	4879      	ldr	r0, [pc, #484]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003c48:	f006 f8f2 	bl	8009e30 <chHeapAllocAligned.constprop.41>
 8003c4c:	2110      	movs	r1, #16
 8003c4e:	4607      	mov	r7, r0
 8003c50:	4876      	ldr	r0, [pc, #472]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003c52:	f006 f8ed 	bl	8009e30 <chHeapAllocAligned.constprop.41>
    chHeapFree(p3);                                 /* Merges forward.*/
 8003c56:	f000 fddb 	bl	8004810 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 8003c5a:	4638      	mov	r0, r7
 8003c5c:	f000 fdd8 	bl	8004810 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 8003c60:	4630      	mov	r0, r6
 8003c62:	f000 fdd5 	bl	8004810 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8003c66:	462a      	mov	r2, r5
 8003c68:	a901      	add	r1, sp, #4
 8003c6a:	4870      	ldr	r0, [pc, #448]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003c6c:	f000 fd98 	bl	80047a0 <chHeapStatus>
 8003c70:	f1a0 0001 	sub.w	r0, r0, #1
 8003c74:	fab0 f080 	clz	r0, r0
 8003c78:	496d      	ldr	r1, [pc, #436]	; (8003e30 <test_010_001_execute.lto_priv.239+0x310>)
 8003c7a:	0940      	lsrs	r0, r0, #5
 8003c7c:	f005 fda8 	bl	80097d0 <_test_assert>
 8003c80:	4605      	mov	r5, r0
 8003c82:	2800      	cmp	r0, #0
 8003c84:	f47f af60 	bne.w	8003b48 <test_010_001_execute.lto_priv.239+0x28>
  test_set_step(7);
 8003c88:	2307      	movs	r3, #7
 8003c8a:	2111      	movs	r1, #17
 8003c8c:	4867      	ldr	r0, [pc, #412]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003c8e:	6023      	str	r3, [r4, #0]
 8003c90:	f006 f8ce 	bl	8009e30 <chHeapAllocAligned.constprop.41>
 8003c94:	2110      	movs	r1, #16
 8003c96:	4606      	mov	r6, r0
 8003c98:	4864      	ldr	r0, [pc, #400]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003c9a:	f006 f8c9 	bl	8009e30 <chHeapAllocAligned.constprop.41>
 8003c9e:	4607      	mov	r7, r0
    chHeapFree(p1);
 8003ca0:	4630      	mov	r0, r6
 8003ca2:	f000 fdb5 	bl	8004810 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8003ca6:	462a      	mov	r2, r5
 8003ca8:	a901      	add	r1, sp, #4
 8003caa:	4860      	ldr	r0, [pc, #384]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003cac:	f000 fd78 	bl	80047a0 <chHeapStatus>
 8003cb0:	f1a0 0802 	sub.w	r8, r0, #2
 8003cb4:	f1d8 0000 	rsbs	r0, r8, #0
 8003cb8:	4962      	ldr	r1, [pc, #392]	; (8003e44 <test_010_001_execute.lto_priv.239+0x324>)
 8003cba:	eb40 0008 	adc.w	r0, r0, r8
 8003cbe:	f005 fd87 	bl	80097d0 <_test_assert>
 8003cc2:	4605      	mov	r5, r0
 8003cc4:	2800      	cmp	r0, #0
 8003cc6:	f47f af3f 	bne.w	8003b48 <test_010_001_execute.lto_priv.239+0x28>
 8003cca:	2110      	movs	r1, #16
 8003ccc:	4857      	ldr	r0, [pc, #348]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003cce:	f006 f8af 	bl	8009e30 <chHeapAllocAligned.constprop.41>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8003cd2:	462a      	mov	r2, r5
 8003cd4:	4606      	mov	r6, r0
 8003cd6:	a901      	add	r1, sp, #4
 8003cd8:	4854      	ldr	r0, [pc, #336]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003cda:	f000 fd61 	bl	80047a0 <chHeapStatus>
 8003cde:	2801      	cmp	r0, #1
 8003ce0:	f000 809f 	beq.w	8003e22 <test_010_001_execute.lto_priv.239+0x302>
 8003ce4:	2200      	movs	r2, #0
 8003ce6:	a901      	add	r1, sp, #4
 8003ce8:	4850      	ldr	r0, [pc, #320]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003cea:	f000 fd59 	bl	80047a0 <chHeapStatus>
 8003cee:	f1a0 0c02 	sub.w	ip, r0, #2
 8003cf2:	f1dc 0000 	rsbs	r0, ip, #0
 8003cf6:	eb40 000c 	adc.w	r0, r0, ip
 8003cfa:	494d      	ldr	r1, [pc, #308]	; (8003e30 <test_010_001_execute.lto_priv.239+0x310>)
 8003cfc:	f005 fd68 	bl	80097d0 <_test_assert>
 8003d00:	4605      	mov	r5, r0
 8003d02:	2800      	cmp	r0, #0
 8003d04:	f47f af20 	bne.w	8003b48 <test_010_001_execute.lto_priv.239+0x28>
    chHeapFree(p2);
 8003d08:	4638      	mov	r0, r7
 8003d0a:	f000 fd81 	bl	8004810 <chHeapFree>
    chHeapFree(p1);
 8003d0e:	4630      	mov	r0, r6
 8003d10:	f000 fd7e 	bl	8004810 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8003d14:	462a      	mov	r2, r5
 8003d16:	a901      	add	r1, sp, #4
 8003d18:	4844      	ldr	r0, [pc, #272]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003d1a:	f000 fd41 	bl	80047a0 <chHeapStatus>
 8003d1e:	f100 3eff 	add.w	lr, r0, #4294967295
 8003d22:	f1de 0000 	rsbs	r0, lr, #0
 8003d26:	4942      	ldr	r1, [pc, #264]	; (8003e30 <test_010_001_execute.lto_priv.239+0x310>)
 8003d28:	eb40 000e 	adc.w	r0, r0, lr
 8003d2c:	f005 fd50 	bl	80097d0 <_test_assert>
 8003d30:	4605      	mov	r5, r0
 8003d32:	2800      	cmp	r0, #0
 8003d34:	f47f af08 	bne.w	8003b48 <test_010_001_execute.lto_priv.239+0x28>
  test_set_step(8);
 8003d38:	2308      	movs	r3, #8
 8003d3a:	2110      	movs	r1, #16
 8003d3c:	483b      	ldr	r0, [pc, #236]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003d3e:	6023      	str	r3, [r4, #0]
 8003d40:	f006 f876 	bl	8009e30 <chHeapAllocAligned.constprop.41>
 8003d44:	2110      	movs	r1, #16
 8003d46:	4607      	mov	r7, r0
 8003d48:	4838      	ldr	r0, [pc, #224]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003d4a:	f006 f871 	bl	8009e30 <chHeapAllocAligned.constprop.41>
 8003d4e:	4606      	mov	r6, r0
    chHeapFree(p1);
 8003d50:	4638      	mov	r0, r7
 8003d52:	f000 fd5d 	bl	8004810 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8003d56:	462a      	mov	r2, r5
 8003d58:	a901      	add	r1, sp, #4
 8003d5a:	4834      	ldr	r0, [pc, #208]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003d5c:	f000 fd20 	bl	80047a0 <chHeapStatus>
 8003d60:	1e87      	subs	r7, r0, #2
 8003d62:	4278      	negs	r0, r7
 8003d64:	4937      	ldr	r1, [pc, #220]	; (8003e44 <test_010_001_execute.lto_priv.239+0x324>)
 8003d66:	4178      	adcs	r0, r7
 8003d68:	f005 fd32 	bl	80097d0 <_test_assert>
 8003d6c:	4605      	mov	r5, r0
 8003d6e:	2800      	cmp	r0, #0
 8003d70:	f47f aeea 	bne.w	8003b48 <test_010_001_execute.lto_priv.239+0x28>
 8003d74:	2120      	movs	r1, #32
 8003d76:	482d      	ldr	r0, [pc, #180]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003d78:	f006 f85a 	bl	8009e30 <chHeapAllocAligned.constprop.41>
    chHeapFree(p1);
 8003d7c:	f000 fd48 	bl	8004810 <chHeapFree>
    chHeapFree(p2);
 8003d80:	4630      	mov	r0, r6
 8003d82:	f000 fd45 	bl	8004810 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8003d86:	462a      	mov	r2, r5
 8003d88:	a901      	add	r1, sp, #4
 8003d8a:	4828      	ldr	r0, [pc, #160]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003d8c:	f000 fd08 	bl	80047a0 <chHeapStatus>
 8003d90:	1e45      	subs	r5, r0, #1
 8003d92:	4268      	negs	r0, r5
 8003d94:	4926      	ldr	r1, [pc, #152]	; (8003e30 <test_010_001_execute.lto_priv.239+0x310>)
 8003d96:	4168      	adcs	r0, r5
 8003d98:	f005 fd1a 	bl	80097d0 <_test_assert>
 8003d9c:	4602      	mov	r2, r0
 8003d9e:	2800      	cmp	r0, #0
 8003da0:	f47f aed2 	bne.w	8003b48 <test_010_001_execute.lto_priv.239+0x28>
  test_set_step(9);
 8003da4:	2309      	movs	r3, #9
    (void)chHeapStatus(&test_heap, &n, NULL);
 8003da6:	a901      	add	r1, sp, #4
 8003da8:	4820      	ldr	r0, [pc, #128]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
  test_set_step(9);
 8003daa:	6023      	str	r3, [r4, #0]
    (void)chHeapStatus(&test_heap, &n, NULL);
 8003dac:	f000 fcf8 	bl	80047a0 <chHeapStatus>
 8003db0:	9901      	ldr	r1, [sp, #4]
 8003db2:	481e      	ldr	r0, [pc, #120]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003db4:	f006 f83c 	bl	8009e30 <chHeapAllocAligned.constprop.41>
    test_assert(p1 != NULL, "allocation failed");
 8003db8:	4606      	mov	r6, r0
 8003dba:	3000      	adds	r0, #0
 8003dbc:	491e      	ldr	r1, [pc, #120]	; (8003e38 <test_010_001_execute.lto_priv.239+0x318>)
 8003dbe:	bf18      	it	ne
 8003dc0:	2001      	movne	r0, #1
 8003dc2:	f005 fd05 	bl	80097d0 <_test_assert>
 8003dc6:	4602      	mov	r2, r0
 8003dc8:	2800      	cmp	r0, #0
 8003dca:	f47f aebd 	bne.w	8003b48 <test_010_001_execute.lto_priv.239+0x28>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 8003dce:	4601      	mov	r1, r0
 8003dd0:	4816      	ldr	r0, [pc, #88]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
 8003dd2:	f000 fce5 	bl	80047a0 <chHeapStatus>
 8003dd6:	fab0 f080 	clz	r0, r0
 8003dda:	0940      	lsrs	r0, r0, #5
 8003ddc:	491a      	ldr	r1, [pc, #104]	; (8003e48 <test_010_001_execute.lto_priv.239+0x328>)
 8003dde:	f005 fcf7 	bl	80097d0 <_test_assert>
 8003de2:	4605      	mov	r5, r0
 8003de4:	2800      	cmp	r0, #0
 8003de6:	f47f aeaf 	bne.w	8003b48 <test_010_001_execute.lto_priv.239+0x28>
    chHeapFree(p1);
 8003dea:	4630      	mov	r0, r6
 8003dec:	f000 fd10 	bl	8004810 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8003df0:	462a      	mov	r2, r5
 8003df2:	a901      	add	r1, sp, #4
  test_set_step(10);
 8003df4:	230a      	movs	r3, #10
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8003df6:	480d      	ldr	r0, [pc, #52]	; (8003e2c <test_010_001_execute.lto_priv.239+0x30c>)
  test_set_step(10);
 8003df8:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8003dfa:	f000 fcd1 	bl	80047a0 <chHeapStatus>
 8003dfe:	1e42      	subs	r2, r0, #1
 8003e00:	4250      	negs	r0, r2
 8003e02:	4150      	adcs	r0, r2
 8003e04:	490a      	ldr	r1, [pc, #40]	; (8003e30 <test_010_001_execute.lto_priv.239+0x310>)
 8003e06:	f005 fce3 	bl	80097d0 <_test_assert>
 8003e0a:	2800      	cmp	r0, #0
 8003e0c:	f47f ae9c 	bne.w	8003b48 <test_010_001_execute.lto_priv.239+0x28>
    test_assert(n == sz, "size changed");
 8003e10:	9801      	ldr	r0, [sp, #4]
 8003e12:	9b00      	ldr	r3, [sp, #0]
 8003e14:	490d      	ldr	r1, [pc, #52]	; (8003e4c <test_010_001_execute.lto_priv.239+0x32c>)
 8003e16:	1ac3      	subs	r3, r0, r3
 8003e18:	4258      	negs	r0, r3
 8003e1a:	4158      	adcs	r0, r3
 8003e1c:	f005 fcd8 	bl	80097d0 <_test_assert>
 8003e20:	e692      	b.n	8003b48 <test_010_001_execute.lto_priv.239+0x28>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8003e22:	2001      	movs	r0, #1
 8003e24:	e769      	b.n	8003cfa <test_010_001_execute.lto_priv.239+0x1da>
 8003e26:	bf00      	nop
 8003e28:	20001df8 	.word	0x20001df8
 8003e2c:	20001d78 	.word	0x20001d78
 8003e30:	0800ab20 	.word	0x0800ab20
 8003e34:	0800ab08 	.word	0x0800ab08
 8003e38:	0800aaf4 	.word	0x0800aaf4
 8003e3c:	0800aa9c 	.word	0x0800aa9c
 8003e40:	0800aab0 	.word	0x0800aab0
 8003e44:	0800aac8 	.word	0x0800aac8
 8003e48:	0800aad8 	.word	0x0800aad8
 8003e4c:	0800aae4 	.word	0x0800aae4

08003e50 <bmk_thread3>:
  chThdExit((msg_t)p);
 8003e50:	f7fd bd3e 	b.w	80018d0 <chThdExit>
	...

08003e60 <test_012_004_execute.lto_priv.248>:
static void test_012_004_execute(void) {
 8003e60:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  return ch.rlist.current;
 8003e64:	4d39      	ldr	r5, [pc, #228]	; (8003f4c <test_012_004_execute.lto_priv.248+0xec>)
  test_set_step(1);
 8003e66:	f8df 8100 	ldr.w	r8, [pc, #256]	; 8003f68 <test_012_004_execute.lto_priv.248+0x108>
  return chThdGetSelfX()->prio;
 8003e6a:	69ab      	ldr	r3, [r5, #24]
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003e6c:	4a38      	ldr	r2, [pc, #224]	; (8003f50 <test_012_004_execute.lto_priv.248+0xf0>)
 8003e6e:	6899      	ldr	r1, [r3, #8]
 8003e70:	4838      	ldr	r0, [pc, #224]	; (8003f54 <test_012_004_execute.lto_priv.248+0xf4>)
 8003e72:	3101      	adds	r1, #1
  test_set_step(1);
 8003e74:	2401      	movs	r4, #1
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003e76:	2300      	movs	r3, #0
  test_set_step(1);
 8003e78:	f8c8 4000 	str.w	r4, [r8]
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003e7c:	f006 f878 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8003e80:	4a35      	ldr	r2, [pc, #212]	; (8003f58 <test_012_004_execute.lto_priv.248+0xf8>)
  test_set_step(2);
 8003e82:	2302      	movs	r3, #2
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003e84:	4604      	mov	r4, r0
 8003e86:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 8003e88:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
 8003e8c:	f005 f9b0 	bl	80091f0 <test_wait_tick>
    n = 0;
 8003e90:	2600      	movs	r6, #0
      chSchWakeupS(tp, MSG_OK);
 8003e92:	46b3      	mov	fp, r6
    start = test_wait_tick();
 8003e94:	4682      	mov	sl, r0
 8003e96:	2720      	movs	r7, #32
 8003e98:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
 8003e9c:	f387 8811 	msr	BASEPRI, r7
  _dbg_check_lock();
 8003ea0:	f7fd f9de 	bl	8001260 <_dbg_check_lock>
      chSchWakeupS(tp, MSG_OK);
 8003ea4:	4620      	mov	r0, r4
 8003ea6:	2100      	movs	r1, #0
 8003ea8:	f7fc ff52 	bl	8000d50 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8003eac:	4620      	mov	r0, r4
 8003eae:	2100      	movs	r1, #0
 8003eb0:	f7fc ff4e 	bl	8000d50 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8003eb4:	4620      	mov	r0, r4
 8003eb6:	2100      	movs	r1, #0
 8003eb8:	f7fc ff4a 	bl	8000d50 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8003ebc:	4620      	mov	r0, r4
 8003ebe:	2100      	movs	r1, #0
 8003ec0:	f7fc ff46 	bl	8000d50 <chSchWakeupS>
  _dbg_check_unlock();
 8003ec4:	f7fd f9a4 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003ec8:	682b      	ldr	r3, [r5, #0]
 8003eca:	42ab      	cmp	r3, r5
 8003ecc:	d004      	beq.n	8003ed8 <test_012_004_execute.lto_priv.248+0x78>
 8003ece:	69aa      	ldr	r2, [r5, #24]
 8003ed0:	689b      	ldr	r3, [r3, #8]
 8003ed2:	6892      	ldr	r2, [r2, #8]
 8003ed4:	429a      	cmp	r2, r3
 8003ed6:	d335      	bcc.n	8003f44 <test_012_004_execute.lto_priv.248+0xe4>
 8003ed8:	f38b 8811 	msr	BASEPRI, fp
 8003edc:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
    } while (chVTIsSystemTimeWithinX(start, end));
 8003ee0:	f242 720f 	movw	r2, #9999	; 0x270f
 8003ee4:	eba3 030a 	sub.w	r3, r3, sl
 8003ee8:	4293      	cmp	r3, r2
      n += 4;
 8003eea:	f106 0604 	add.w	r6, r6, #4
    } while (chVTIsSystemTimeWithinX(start, end));
 8003eee:	d9d5      	bls.n	8003e9c <test_012_004_execute.lto_priv.248+0x3c>
  test_set_step(3);
 8003ef0:	2303      	movs	r3, #3
 8003ef2:	f8c8 3000 	str.w	r3, [r8]
 8003ef6:	2320      	movs	r3, #32
 8003ef8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003efc:	f7fd f9b0 	bl	8001260 <_dbg_check_lock>
    chSchWakeupS(tp, MSG_TIMEOUT);
 8003f00:	4620      	mov	r0, r4
 8003f02:	f04f 31ff 	mov.w	r1, #4294967295
 8003f06:	f7fc ff23 	bl	8000d50 <chSchWakeupS>
  _dbg_check_unlock();
 8003f0a:	f7fd f981 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003f0e:	682b      	ldr	r3, [r5, #0]
 8003f10:	42ab      	cmp	r3, r5
 8003f12:	d004      	beq.n	8003f1e <test_012_004_execute.lto_priv.248+0xbe>
 8003f14:	69aa      	ldr	r2, [r5, #24]
 8003f16:	689b      	ldr	r3, [r3, #8]
 8003f18:	6892      	ldr	r2, [r2, #8]
 8003f1a:	429a      	cmp	r2, r3
 8003f1c:	d312      	bcc.n	8003f44 <test_012_004_execute.lto_priv.248+0xe4>
 8003f1e:	2300      	movs	r3, #0
 8003f20:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 8003f24:	f004 fd3c 	bl	80089a0 <test_wait_threads>
  test_set_step(4);
 8003f28:	2304      	movs	r3, #4
    test_print("--- Score : ");
 8003f2a:	480c      	ldr	r0, [pc, #48]	; (8003f5c <test_012_004_execute.lto_priv.248+0xfc>)
  test_set_step(4);
 8003f2c:	f8c8 3000 	str.w	r3, [r8]
    test_print("--- Score : ");
 8003f30:	f005 fa8e 	bl	8009450 <test_print>
    test_printn(n * 2);
 8003f34:	0070      	lsls	r0, r6, #1
 8003f36:	f005 faa3 	bl	8009480 <test_printn>
    test_println(" ctxswc/S");
 8003f3a:	4809      	ldr	r0, [pc, #36]	; (8003f60 <test_012_004_execute.lto_priv.248+0x100>)
}
 8003f3c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_println(" ctxswc/S");
 8003f40:	f005 ba66 	b.w	8009410 <test_println>
 8003f44:	4807      	ldr	r0, [pc, #28]	; (8003f64 <test_012_004_execute.lto_priv.248+0x104>)
 8003f46:	f7fc fc6b 	bl	8000820 <chSysHalt>
 8003f4a:	bf00      	nop
 8003f4c:	20001e68 	.word	0x20001e68
 8003f50:	08003f71 	.word	0x08003f71
 8003f54:	20001710 	.word	0x20001710
 8003f58:	20001d98 	.word	0x20001d98
 8003f5c:	0800ac3c 	.word	0x0800ac3c
 8003f60:	0800ac4c 	.word	0x0800ac4c
 8003f64:	0800ae50 	.word	0x0800ae50
 8003f68:	20001df8 	.word	0x20001df8
 8003f6c:	00000000 	.word	0x00000000

08003f70 <bmk_thread4>:
static THD_FUNCTION(bmk_thread4, p) {
 8003f70:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 8003f72:	4d0f      	ldr	r5, [pc, #60]	; (8003fb0 <bmk_thread4+0x40>)
 8003f74:	2320      	movs	r3, #32
 8003f76:	69ac      	ldr	r4, [r5, #24]
 8003f78:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8003f7c:	f7fd f970 	bl	8001260 <_dbg_check_lock>
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8003f80:	2003      	movs	r0, #3
 8003f82:	f7fc fc75 	bl	8000870 <chSchGoSleepS>
  } while (msg == MSG_OK);
 8003f86:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003f88:	2b00      	cmp	r3, #0
 8003f8a:	d0f9      	beq.n	8003f80 <bmk_thread4+0x10>
  _dbg_check_unlock();
 8003f8c:	f7fd f940 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003f90:	682b      	ldr	r3, [r5, #0]
 8003f92:	42ab      	cmp	r3, r5
 8003f94:	d004      	beq.n	8003fa0 <bmk_thread4+0x30>
 8003f96:	69aa      	ldr	r2, [r5, #24]
 8003f98:	689b      	ldr	r3, [r3, #8]
 8003f9a:	6892      	ldr	r2, [r2, #8]
 8003f9c:	429a      	cmp	r2, r3
 8003f9e:	d303      	bcc.n	8003fa8 <bmk_thread4+0x38>
 8003fa0:	2300      	movs	r3, #0
 8003fa2:	f383 8811 	msr	BASEPRI, r3
 8003fa6:	bd38      	pop	{r3, r4, r5, pc}
 8003fa8:	4802      	ldr	r0, [pc, #8]	; (8003fb4 <bmk_thread4+0x44>)
 8003faa:	f7fc fc39 	bl	8000820 <chSysHalt>
 8003fae:	bf00      	nop
 8003fb0:	20001e68 	.word	0x20001e68
 8003fb4:	0800ae50 	.word	0x0800ae50
	...

08003fc0 <test_011_002_execute.lto_priv.244>:

static void test_011_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void test_011_002_execute(void) {
 8003fc0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned i;
  tprio_t prio;

  /* [11.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 8003fc4:	4e48      	ldr	r6, [pc, #288]	; (80040e8 <test_011_002_execute.lto_priv.244+0x128>)
 8003fc6:	4d49      	ldr	r5, [pc, #292]	; (80040ec <test_011_002_execute.lto_priv.244+0x12c>)
 8003fc8:	f8df b174 	ldr.w	fp, [pc, #372]	; 8004140 <test_011_002_execute.lto_priv.244+0x180>
 8003fcc:	4c48      	ldr	r4, [pc, #288]	; (80040f0 <test_011_002_execute.lto_priv.244+0x130>)
  chPoolFreeI(mp, objp);
 8003fce:	f8df 8164 	ldr.w	r8, [pc, #356]	; 8004134 <test_011_002_execute.lto_priv.244+0x174>
 8003fd2:	2301      	movs	r3, #1
 8003fd4:	6033      	str	r3, [r6, #0]
 8003fd6:	f105 0a0c 	add.w	sl, r5, #12
 8003fda:	2720      	movs	r7, #32
 8003fdc:	f04f 0900 	mov.w	r9, #0
 8003fe0:	f387 8811 	msr	BASEPRI, r7
  _dbg_check_lock();
 8003fe4:	f7fd f93c 	bl	8001260 <_dbg_check_lock>
 8003fe8:	4659      	mov	r1, fp
 8003fea:	4640      	mov	r0, r8
 8003fec:	f000 fbb0 	bl	8004750 <chPoolFreeI>
  _dbg_check_unlock();
 8003ff0:	f7fd f90e 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003ff4:	6823      	ldr	r3, [r4, #0]
 8003ff6:	42a3      	cmp	r3, r4
 8003ff8:	d004      	beq.n	8004004 <test_011_002_execute.lto_priv.244+0x44>
 8003ffa:	69a2      	ldr	r2, [r4, #24]
 8003ffc:	689b      	ldr	r3, [r3, #8]
 8003ffe:	6892      	ldr	r2, [r2, #8]
 8004000:	429a      	cmp	r2, r3
 8004002:	d306      	bcc.n	8004012 <test_011_002_execute.lto_priv.244+0x52>
 8004004:	f389 8811 	msr	BASEPRI, r9
  {
    for (i = 0; i < 4; i++)
 8004008:	4555      	cmp	r5, sl
 800400a:	d005      	beq.n	8004018 <test_011_002_execute.lto_priv.244+0x58>
 800400c:	f855 bb04 	ldr.w	fp, [r5], #4
 8004010:	e7e6      	b.n	8003fe0 <test_011_002_execute.lto_priv.244+0x20>
 8004012:	4838      	ldr	r0, [pc, #224]	; (80040f4 <test_011_002_execute.lto_priv.244+0x134>)
 8004014:	f7fc fc04 	bl	8000820 <chSysHalt>
  return chThdGetSelfX()->prio;
 8004018:	69a3      	ldr	r3, [r4, #24]
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 800401a:	4a37      	ldr	r2, [pc, #220]	; (80040f8 <test_011_002_execute.lto_priv.244+0x138>)
 800401c:	689d      	ldr	r5, [r3, #8]
 800401e:	4837      	ldr	r0, [pc, #220]	; (80040fc <test_011_002_execute.lto_priv.244+0x13c>)
 8004020:	4c37      	ldr	r4, [pc, #220]	; (8004100 <test_011_002_execute.lto_priv.244+0x140>)
  test_set_step(3);
 8004022:	2303      	movs	r3, #3
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8004024:	1e69      	subs	r1, r5, #1
  test_set_step(3);
 8004026:	6033      	str	r3, [r6, #0]
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8004028:	f006 f9c2 	bl	800a3b0 <chThdCreateFromMemoryPool.constprop.40>
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 800402c:	1ea9      	subs	r1, r5, #2
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 800402e:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8004030:	4a34      	ldr	r2, [pc, #208]	; (8004104 <test_011_002_execute.lto_priv.244+0x144>)
 8004032:	4835      	ldr	r0, [pc, #212]	; (8004108 <test_011_002_execute.lto_priv.244+0x148>)
 8004034:	f006 f9bc 	bl	800a3b0 <chThdCreateFromMemoryPool.constprop.40>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8004038:	1ee9      	subs	r1, r5, #3
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 800403a:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800403c:	4a33      	ldr	r2, [pc, #204]	; (800410c <test_011_002_execute.lto_priv.244+0x14c>)
 800403e:	4834      	ldr	r0, [pc, #208]	; (8004110 <test_011_002_execute.lto_priv.244+0x150>)
 8004040:	f006 f9b6 	bl	800a3b0 <chThdCreateFromMemoryPool.constprop.40>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8004044:	1f29      	subs	r1, r5, #4
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8004046:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8004048:	4a32      	ldr	r2, [pc, #200]	; (8004114 <test_011_002_execute.lto_priv.244+0x154>)
 800404a:	4833      	ldr	r0, [pc, #204]	; (8004118 <test_011_002_execute.lto_priv.244+0x158>)
 800404c:	f006 f9b0 	bl	800a3b0 <chThdCreateFromMemoryPool.constprop.40>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8004050:	4a32      	ldr	r2, [pc, #200]	; (800411c <test_011_002_execute.lto_priv.244+0x15c>)
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8004052:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8004054:	1f69      	subs	r1, r5, #5
 8004056:	4832      	ldr	r0, [pc, #200]	; (8004120 <test_011_002_execute.lto_priv.244+0x160>)
 8004058:	f006 f9aa 	bl	800a3b0 <chThdCreateFromMemoryPool.constprop.40>
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 800405c:	6823      	ldr	r3, [r4, #0]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800405e:	6120      	str	r0, [r4, #16]
  test_set_step(4);
 8004060:	2204      	movs	r2, #4
 8004062:	6032      	str	r2, [r6, #0]
    test_assert((threads[0] != NULL) &&
 8004064:	2b00      	cmp	r3, #0
 8004066:	d03d      	beq.n	80040e4 <test_011_002_execute.lto_priv.244+0x124>
 8004068:	6860      	ldr	r0, [r4, #4]
 800406a:	b128      	cbz	r0, 8004078 <test_011_002_execute.lto_priv.244+0xb8>
 800406c:	68a0      	ldr	r0, [r4, #8]
 800406e:	b118      	cbz	r0, 8004078 <test_011_002_execute.lto_priv.244+0xb8>
 8004070:	68e0      	ldr	r0, [r4, #12]
 8004072:	3000      	adds	r0, #0
 8004074:	bf18      	it	ne
 8004076:	2001      	movne	r0, #1
 8004078:	492a      	ldr	r1, [pc, #168]	; (8004124 <test_011_002_execute.lto_priv.244+0x164>)
 800407a:	f005 fba9 	bl	80097d0 <_test_assert>
 800407e:	b108      	cbz	r0, 8004084 <test_011_002_execute.lto_priv.244+0xc4>
 8004080:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
 8004084:	6920      	ldr	r0, [r4, #16]
 8004086:	4928      	ldr	r1, [pc, #160]	; (8004128 <test_011_002_execute.lto_priv.244+0x168>)
 8004088:	fab0 f080 	clz	r0, r0
 800408c:	0940      	lsrs	r0, r0, #5
 800408e:	f005 fb9f 	bl	80097d0 <_test_assert>
 8004092:	2800      	cmp	r0, #0
 8004094:	d1f4      	bne.n	8004080 <test_011_002_execute.lto_priv.244+0xc0>
                "thread creation not failed");
  }

  /* [11.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 8004096:	2305      	movs	r3, #5
 8004098:	6033      	str	r3, [r6, #0]
  {
    test_wait_threads();
 800409a:	f004 fc81 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 800409e:	4923      	ldr	r1, [pc, #140]	; (800412c <test_011_002_execute.lto_priv.244+0x16c>)
 80040a0:	4823      	ldr	r0, [pc, #140]	; (8004130 <test_011_002_execute.lto_priv.244+0x170>)
 80040a2:	f005 fb6d 	bl	8009780 <_test_assert_sequence>
 80040a6:	2800      	cmp	r0, #0
 80040a8:	d1ea      	bne.n	8004080 <test_011_002_execute.lto_priv.244+0xc0>
  }

  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
 80040aa:	2306      	movs	r3, #6
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 80040ac:	4f21      	ldr	r7, [pc, #132]	; (8004134 <test_011_002_execute.lto_priv.244+0x174>)
 80040ae:	4d22      	ldr	r5, [pc, #136]	; (8004138 <test_011_002_execute.lto_priv.244+0x178>)
  test_set_step(6);
 80040b0:	6033      	str	r3, [r6, #0]
 80040b2:	2404      	movs	r4, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 80040b4:	4638      	mov	r0, r7
 80040b6:	f000 fe1b 	bl	8004cf0 <chPoolAlloc>
 80040ba:	3000      	adds	r0, #0
 80040bc:	bf18      	it	ne
 80040be:	2001      	movne	r0, #1
 80040c0:	4629      	mov	r1, r5
 80040c2:	f005 fb85 	bl	80097d0 <_test_assert>
 80040c6:	2800      	cmp	r0, #0
 80040c8:	d1da      	bne.n	8004080 <test_011_002_execute.lto_priv.244+0xc0>
    for (i = 0; i < 4; i++)
 80040ca:	3c01      	subs	r4, #1
 80040cc:	d1f2      	bne.n	80040b4 <test_011_002_execute.lto_priv.244+0xf4>
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 80040ce:	4819      	ldr	r0, [pc, #100]	; (8004134 <test_011_002_execute.lto_priv.244+0x174>)
 80040d0:	f000 fe0e 	bl	8004cf0 <chPoolAlloc>
 80040d4:	fab0 f080 	clz	r0, r0
 80040d8:	0940      	lsrs	r0, r0, #5
 80040da:	4918      	ldr	r1, [pc, #96]	; (800413c <test_011_002_execute.lto_priv.244+0x17c>)
  }
}
 80040dc:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 80040e0:	f005 bb76 	b.w	80097d0 <_test_assert>
    test_assert((threads[0] != NULL) &&
 80040e4:	4618      	mov	r0, r3
 80040e6:	e7c7      	b.n	8004078 <test_011_002_execute.lto_priv.244+0xb8>
 80040e8:	20001df8 	.word	0x20001df8
 80040ec:	0800ac5c 	.word	0x0800ac5c
 80040f0:	20001e68 	.word	0x20001e68
 80040f4:	0800a840 	.word	0x0800a840
 80040f8:	0800a9dc 	.word	0x0800a9dc
 80040fc:	0800ab30 	.word	0x0800ab30
 8004100:	20001d98 	.word	0x20001d98
 8004104:	0800a9e0 	.word	0x0800a9e0
 8004108:	0800ab50 	.word	0x0800ab50
 800410c:	0800a9e4 	.word	0x0800a9e4
 8004110:	0800ab58 	.word	0x0800ab58
 8004114:	0800b314 	.word	0x0800b314
 8004118:	0800abd4 	.word	0x0800abd4
 800411c:	0800aa00 	.word	0x0800aa00
 8004120:	0800abdc 	.word	0x0800abdc
 8004124:	0800ab38 	.word	0x0800ab38
 8004128:	0800ab60 	.word	0x0800ab60
 800412c:	0800a9e8 	.word	0x0800a9e8
 8004130:	0800abe4 	.word	0x0800abe4
 8004134:	20002720 	.word	0x20002720
 8004138:	0800abec 	.word	0x0800abec
 800413c:	0800abfc 	.word	0x0800abfc
 8004140:	20001710 	.word	0x20001710
	...

08004150 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 8004150:	4770      	bx	lr
 8004152:	bf00      	nop
	...

08004160 <sduRequestsHook>:
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8004160:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 8004164:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8004168:	2b20      	cmp	r3, #32
 800416a:	d001      	beq.n	8004170 <sduRequestsHook+0x10>
      return false;
 800416c:	2000      	movs	r0, #0
}
 800416e:	4770      	bx	lr
    switch (usbp->setup[1]) {
 8004170:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 8004174:	2b21      	cmp	r3, #33	; 0x21
 8004176:	d003      	beq.n	8004180 <sduRequestsHook+0x20>
 8004178:	2b22      	cmp	r3, #34	; 0x22
 800417a:	d009      	beq.n	8004190 <sduRequestsHook+0x30>
 800417c:	2b20      	cmp	r3, #32
 800417e:	d1f5      	bne.n	800416c <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8004180:	4b06      	ldr	r3, [pc, #24]	; (800419c <sduRequestsHook+0x3c>)
 8004182:	6503      	str	r3, [r0, #80]	; 0x50
 8004184:	2207      	movs	r2, #7
 8004186:	2300      	movs	r3, #0
 8004188:	6542      	str	r2, [r0, #84]	; 0x54
 800418a:	6583      	str	r3, [r0, #88]	; 0x58
      return true;
 800418c:	2001      	movs	r0, #1
 800418e:	4770      	bx	lr
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8004190:	2300      	movs	r3, #0
 8004192:	6503      	str	r3, [r0, #80]	; 0x50
 8004194:	6543      	str	r3, [r0, #84]	; 0x54
 8004196:	6583      	str	r3, [r0, #88]	; 0x58
      return true;
 8004198:	2001      	movs	r0, #1
 800419a:	4770      	bx	lr
 800419c:	20000c1c 	.word	0x20000c1c

080041a0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 80041a0:	b480      	push	{r7}
 80041a2:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80041a4:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80041a8:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80041aa:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80041ae:	2300      	movs	r3, #0
 80041b0:	f383 8811 	msr	BASEPRI, r3
  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 80041b4:	46bd      	mov	sp, r7
 80041b6:	bc80      	pop	{r7}
 80041b8:	4770      	bx	lr
 80041ba:	bf00      	nop
 80041bc:	0000      	movs	r0, r0
	...

080041c0 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 80041c0:	b570      	push	{r4, r5, r6, lr}
 80041c2:	460d      	mov	r5, r1
 80041c4:	4604      	mov	r4, r0

  osalDbgCheckClassS();
 80041c6:	f7fc fb43 	bl	8000850 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 80041ca:	b1d5      	cbz	r5, 8004202 <obqPostFullBufferS+0x42>
 80041cc:	69e3      	ldr	r3, [r4, #28]
 80041ce:	3b04      	subs	r3, #4
 80041d0:	429d      	cmp	r5, r3
 80041d2:	d816      	bhi.n	8004202 <obqPostFullBufferS+0x42>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 80041d4:	68e3      	ldr	r3, [r4, #12]
 80041d6:	b1a3      	cbz	r3, 8004202 <obqPostFullBufferS+0x42>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 80041d8:	6923      	ldr	r3, [r4, #16]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
  if (obqp->bwrptr >= obqp->btop) {
 80041da:	69a1      	ldr	r1, [r4, #24]
  *((size_t *)obqp->bwrptr) = size;
 80041dc:	601d      	str	r5, [r3, #0]
  obqp->bwrptr += obqp->bsize;
 80041de:	69e0      	ldr	r0, [r4, #28]
  obqp->bcounter--;
 80041e0:	68e2      	ldr	r2, [r4, #12]
  obqp->bwrptr += obqp->bsize;
 80041e2:	4403      	add	r3, r0
  if (obqp->bwrptr >= obqp->btop) {
 80041e4:	428b      	cmp	r3, r1
  obqp->bwrptr += obqp->bsize;
 80041e6:	6123      	str	r3, [r4, #16]
    obqp->bwrptr = obqp->buffers;
 80041e8:	bf24      	itt	cs
 80041ea:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 80041ec:	6123      	strcs	r3, [r4, #16]
  obqp->bcounter--;
 80041ee:	3a01      	subs	r2, #1

  /* No "current" buffer.*/
  obqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 80041f0:	6b23      	ldr	r3, [r4, #48]	; 0x30
  obqp->bcounter--;
 80041f2:	60e2      	str	r2, [r4, #12]
  obqp->ptr = NULL;
 80041f4:	2200      	movs	r2, #0
 80041f6:	62a2      	str	r2, [r4, #40]	; 0x28
  if (obqp->notify != NULL) {
 80041f8:	b133      	cbz	r3, 8004208 <obqPostFullBufferS+0x48>
    obqp->notify(obqp);
 80041fa:	4620      	mov	r0, r4
  }
}
 80041fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    obqp->notify(obqp);
 8004200:	4718      	bx	r3
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 8004202:	4802      	ldr	r0, [pc, #8]	; (800420c <obqPostFullBufferS+0x4c>)
 8004204:	f7fc fb0c 	bl	8000820 <chSysHalt>
 8004208:	bd70      	pop	{r4, r5, r6, pc}
 800420a:	bf00      	nop
 800420c:	0800ad6c 	.word	0x0800ad6c

08004210 <ibqReleaseEmptyBufferS>:
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8004210:	b510      	push	{r4, lr}
 8004212:	4604      	mov	r4, r0
  osalDbgCheckClassS();
 8004214:	f7fc fb1c 	bl	8000850 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8004218:	68e3      	ldr	r3, [r4, #12]
 800421a:	b19b      	cbz	r3, 8004244 <ibqReleaseEmptyBufferS+0x34>
  ibqp->brdptr += ibqp->bsize;
 800421c:	6963      	ldr	r3, [r4, #20]
 800421e:	69e0      	ldr	r0, [r4, #28]
  if (ibqp->brdptr >= ibqp->btop) {
 8004220:	69a1      	ldr	r1, [r4, #24]
  ibqp->bcounter--;
 8004222:	68e2      	ldr	r2, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
 8004224:	4403      	add	r3, r0
  if (ibqp->brdptr >= ibqp->btop) {
 8004226:	428b      	cmp	r3, r1
  ibqp->brdptr += ibqp->bsize;
 8004228:	6163      	str	r3, [r4, #20]
    ibqp->brdptr = ibqp->buffers;
 800422a:	bf24      	itt	cs
 800422c:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 800422e:	6163      	strcs	r3, [r4, #20]
  ibqp->bcounter--;
 8004230:	3a01      	subs	r2, #1
  if (ibqp->notify != NULL) {
 8004232:	6b23      	ldr	r3, [r4, #48]	; 0x30
  ibqp->bcounter--;
 8004234:	60e2      	str	r2, [r4, #12]
  ibqp->ptr = NULL;
 8004236:	2200      	movs	r2, #0
 8004238:	62a2      	str	r2, [r4, #40]	; 0x28
  if (ibqp->notify != NULL) {
 800423a:	b133      	cbz	r3, 800424a <ibqReleaseEmptyBufferS+0x3a>
    ibqp->notify(ibqp);
 800423c:	4620      	mov	r0, r4
}
 800423e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ibqp->notify(ibqp);
 8004242:	4718      	bx	r3
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8004244:	4801      	ldr	r0, [pc, #4]	; (800424c <ibqReleaseEmptyBufferS+0x3c>)
 8004246:	f7fc faeb 	bl	8000820 <chSysHalt>
 800424a:	bd10      	pop	{r4, pc}
 800424c:	0800acfc 	.word	0x0800acfc

08004250 <obqGetEmptyBufferTimeoutS>:
                                systime_t timeout) {
 8004250:	b538      	push	{r3, r4, r5, lr}
 8004252:	4604      	mov	r4, r0
 8004254:	460d      	mov	r5, r1
  osalDbgCheckClassS();
 8004256:	f7fc fafb 	bl	8000850 <chDbgCheckClassS>
 800425a:	e007      	b.n	800426c <obqGetEmptyBufferTimeoutS+0x1c>
    if (obqp->suspended) {
 800425c:	7a23      	ldrb	r3, [r4, #8]
 800425e:	b993      	cbnz	r3, 8004286 <obqGetEmptyBufferTimeoutS+0x36>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 8004260:	4629      	mov	r1, r5
 8004262:	4620      	mov	r0, r4
 8004264:	f7fc fec4 	bl	8000ff0 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8004268:	2800      	cmp	r0, #0
 800426a:	db0e      	blt.n	800428a <obqGetEmptyBufferTimeoutS+0x3a>
  while (obqIsFullI(obqp)) {
 800426c:	68e3      	ldr	r3, [r4, #12]
 800426e:	2b00      	cmp	r3, #0
 8004270:	d0f4      	beq.n	800425c <obqGetEmptyBufferTimeoutS+0xc>
  osalDbgAssert(!obqIsFullI(obqp), "still full");
 8004272:	68e3      	ldr	r3, [r4, #12]
 8004274:	b153      	cbz	r3, 800428c <obqGetEmptyBufferTimeoutS+0x3c>
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8004276:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
 8004278:	69e1      	ldr	r1, [r4, #28]
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800427a:	1d1a      	adds	r2, r3, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
 800427c:	440b      	add	r3, r1
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800427e:	62a2      	str	r2, [r4, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
 8004280:	62e3      	str	r3, [r4, #44]	; 0x2c
 8004282:	2000      	movs	r0, #0
 8004284:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 8004286:	f06f 0001 	mvn.w	r0, #1
}
 800428a:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(!obqIsFullI(obqp), "still full");
 800428c:	4801      	ldr	r0, [pc, #4]	; (8004294 <obqGetEmptyBufferTimeoutS+0x44>)
 800428e:	f7fc fac7 	bl	8000820 <chSysHalt>
 8004292:	bf00      	nop
 8004294:	0800ad50 	.word	0x0800ad50
	...

080042a0 <ibqGetFullBufferTimeoutS>:
                                 systime_t timeout) {
 80042a0:	b538      	push	{r3, r4, r5, lr}
 80042a2:	4604      	mov	r4, r0
 80042a4:	460d      	mov	r5, r1
  osalDbgCheckClassS();
 80042a6:	f7fc fad3 	bl	8000850 <chDbgCheckClassS>
 80042aa:	e007      	b.n	80042bc <ibqGetFullBufferTimeoutS+0x1c>
    if (ibqp->suspended) {
 80042ac:	7a23      	ldrb	r3, [r4, #8]
 80042ae:	b993      	cbnz	r3, 80042d6 <ibqGetFullBufferTimeoutS+0x36>
 80042b0:	4629      	mov	r1, r5
 80042b2:	4620      	mov	r0, r4
 80042b4:	f7fc fe9c 	bl	8000ff0 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80042b8:	2800      	cmp	r0, #0
 80042ba:	db0e      	blt.n	80042da <ibqGetFullBufferTimeoutS+0x3a>
  while (ibqIsEmptyI(ibqp)) {
 80042bc:	68e3      	ldr	r3, [r4, #12]
 80042be:	2b00      	cmp	r3, #0
 80042c0:	d0f4      	beq.n	80042ac <ibqGetFullBufferTimeoutS+0xc>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 80042c2:	68e3      	ldr	r3, [r4, #12]
 80042c4:	b153      	cbz	r3, 80042dc <ibqGetFullBufferTimeoutS+0x3c>
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80042c6:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80042c8:	681a      	ldr	r2, [r3, #0]
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80042ca:	3304      	adds	r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80042cc:	441a      	add	r2, r3
 80042ce:	62e2      	str	r2, [r4, #44]	; 0x2c
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80042d0:	62a3      	str	r3, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80042d2:	2000      	movs	r0, #0
 80042d4:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
 80042d6:	f06f 0001 	mvn.w	r0, #1
}
 80042da:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 80042dc:	4801      	ldr	r0, [pc, #4]	; (80042e4 <ibqGetFullBufferTimeoutS+0x44>)
 80042de:	f7fc fa9f 	bl	8000820 <chSysHalt>
 80042e2:	bf00      	nop
 80042e4:	0800ace0 	.word	0x0800ace0
	...

080042f0 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 80042f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80042f4:	4604      	mov	r4, r0
 80042f6:	460e      	mov	r6, r1
 80042f8:	4615      	mov	r5, r2

  osalDbgCheckClassI();
 80042fa:	f7fc fae1 	bl	80008c0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 80042fe:	b11c      	cbz	r4, 8004308 <usbInitEndpointI+0x18>
 8004300:	b115      	cbz	r5, 8004308 <usbInitEndpointI+0x18>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8004302:	7823      	ldrb	r3, [r4, #0]
 8004304:	2b04      	cmp	r3, #4
 8004306:	d002      	beq.n	800430e <usbInitEndpointI+0x1e>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8004308:	485e      	ldr	r0, [pc, #376]	; (8004484 <usbInitEndpointI+0x194>)
 800430a:	f7fc fa89 	bl	8000820 <chSysHalt>
 800430e:	fa0f f886 	sxth.w	r8, r6
 8004312:	eb04 0788 	add.w	r7, r4, r8, lsl #2
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 8004316:	68fb      	ldr	r3, [r7, #12]
 8004318:	2b00      	cmp	r3, #0
 800431a:	d1f5      	bne.n	8004308 <usbInitEndpointI+0x18>

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 800431c:	696a      	ldr	r2, [r5, #20]
  usbp->epc[ep] = epcp;
 800431e:	60fd      	str	r5, [r7, #12]
  if (epcp->in_state != NULL) {
 8004320:	b11a      	cbz	r2, 800432a <usbInitEndpointI+0x3a>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8004322:	6013      	str	r3, [r2, #0]
 8004324:	6053      	str	r3, [r2, #4]
 8004326:	6093      	str	r3, [r2, #8]
 8004328:	60d3      	str	r3, [r2, #12]
  }
  if (epcp->out_state != NULL) {
 800432a:	69ab      	ldr	r3, [r5, #24]
 800432c:	b123      	cbz	r3, 8004338 <usbInitEndpointI+0x48>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 800432e:	2200      	movs	r2, #0
 8004330:	601a      	str	r2, [r3, #0]
 8004332:	605a      	str	r2, [r3, #4]
 8004334:	609a      	str	r2, [r3, #8]
 8004336:	60da      	str	r2, [r3, #12]
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8004338:	68fb      	ldr	r3, [r7, #12]
 800433a:	681a      	ldr	r2, [r3, #0]
 800433c:	f002 0203 	and.w	r2, r2, #3
 8004340:	2a02      	cmp	r2, #2
 8004342:	d05d      	beq.n	8004400 <usbInitEndpointI+0x110>
 8004344:	2a03      	cmp	r2, #3
 8004346:	d05e      	beq.n	8004406 <usbInitEndpointI+0x116>
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8004348:	484f      	ldr	r0, [pc, #316]	; (8004488 <usbInitEndpointI+0x198>)
 800434a:	4950      	ldr	r1, [pc, #320]	; (800448c <usbInitEndpointI+0x19c>)
 800434c:	2a01      	cmp	r2, #1
 800434e:	bf0c      	ite	eq
 8004350:	4681      	moveq	r9, r0
 8004352:	4689      	movne	r9, r1
  stm32_otg_t *otgp = usbp->otg;
 8004354:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
  if (usbp->epc[ep]->out_state != NULL) {
 8004356:	6999      	ldr	r1, [r3, #24]
  otgp->oe[ep].DOEPTSIZ = 0;
 8004358:	0172      	lsls	r2, r6, #5
 800435a:	18a8      	adds	r0, r5, r2
 800435c:	f04f 0e00 	mov.w	lr, #0
 8004360:	f8c0 eb10 	str.w	lr, [r0, #2832]	; 0xb10
  if (usbp->epc[ep]->out_state != NULL) {
 8004364:	2900      	cmp	r1, #0
 8004366:	d054      	beq.n	8004412 <usbInitEndpointI+0x122>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8004368:	8a58      	ldrh	r0, [r3, #18]
 800436a:	f106 0158 	add.w	r1, r6, #88	; 0x58
 800436e:	0149      	lsls	r1, r1, #5
 8004370:	ea40 0009 	orr.w	r0, r0, r9
 8004374:	5068      	str	r0, [r5, r1]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8004376:	f106 0e10 	add.w	lr, r6, #16
 800437a:	f8d5 081c 	ldr.w	r0, [r5, #2076]	; 0x81c
 800437e:	2101      	movs	r1, #1
 8004380:	fa01 f10e 	lsl.w	r1, r1, lr
 8004384:	4301      	orrs	r1, r0
 8004386:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 800438a:	442a      	add	r2, r5
  if (usbp->epc[ep]->in_state != NULL) {
 800438c:	6959      	ldr	r1, [r3, #20]
  otgp->ie[ep].DIEPTSIZ = 0;
 800438e:	2000      	movs	r0, #0
 8004390:	f8c2 0910 	str.w	r0, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 8004394:	2900      	cmp	r1, #0
 8004396:	d050      	beq.n	800443a <usbInitEndpointI+0x14a>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 8004398:	8b9a      	ldrh	r2, [r3, #28]
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800439a:	8a19      	ldrh	r1, [r3, #16]
  next = usbp->pmnext;
 800439c:	6f60      	ldr	r0, [r4, #116]	; 0x74
    if (usbp->epc[ep]->in_multiplier > 1)
 800439e:	2a01      	cmp	r2, #1
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80043a0:	ea4f 0391 	mov.w	r3, r1, lsr #2
      fsize *= usbp->epc[ep]->in_multiplier;
 80043a4:	bf88      	it	hi
 80043a6:	4353      	mulhi	r3, r2
  usbp->pmnext += size;
 80043a8:	1819      	adds	r1, r3, r0
 80043aa:	6f22      	ldr	r2, [r4, #112]	; 0x70
 80043ac:	6761      	str	r1, [r4, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 80043ae:	6852      	ldr	r2, [r2, #4]
 80043b0:	4291      	cmp	r1, r2
 80043b2:	d82b      	bhi.n	800440c <usbInitEndpointI+0x11c>
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80043b4:	f106 013f 	add.w	r1, r6, #63	; 0x3f
 80043b8:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80043ba:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80043be:	eb05 0181 	add.w	r1, r5, r1, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80043c2:	01b0      	lsls	r0, r6, #6
 80043c4:	f040 0020 	orr.w	r0, r0, #32
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80043c8:	604b      	str	r3, [r1, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80043ca:	6110      	str	r0, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80043cc:	6913      	ldr	r3, [r2, #16]
 80043ce:	0699      	lsls	r1, r3, #26
 80043d0:	d4fc      	bmi.n	80043cc <usbInitEndpointI+0xdc>
  chSysPolledDelayX(cycles);
 80043d2:	2012      	movs	r0, #18
 80043d4:	f7fc fa14 	bl	8000800 <chSysPolledDelayX>
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 80043d8:	68fb      	ldr	r3, [r7, #12]
 80043da:	8a1a      	ldrh	r2, [r3, #16]
    otgp->ie[ep].DIEPCTL = ctl |
 80043dc:	f106 0348 	add.w	r3, r6, #72	; 0x48
                           DIEPCTL_TXFNUM(ep) |
 80043e0:	ea42 5286 	orr.w	r2, r2, r6, lsl #22
    otgp->ie[ep].DIEPCTL = ctl |
 80043e4:	015b      	lsls	r3, r3, #5
                           DIEPCTL_TXFNUM(ep) |
 80043e6:	ea42 0209 	orr.w	r2, r2, r9
    otgp->ie[ep].DIEPCTL = ctl |
 80043ea:	50ea      	str	r2, [r5, r3]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 80043ec:	2101      	movs	r1, #1
 80043ee:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 80043f2:	fa01 f606 	lsl.w	r6, r1, r6
 80043f6:	431e      	orrs	r6, r3
 80043f8:	f8c5 681c 	str.w	r6, [r5, #2076]	; 0x81c
 80043fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8004400:	f8df 9094 	ldr.w	r9, [pc, #148]	; 8004498 <usbInitEndpointI+0x1a8>
 8004404:	e7a6      	b.n	8004354 <usbInitEndpointI+0x64>
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8004406:	f8df 9094 	ldr.w	r9, [pc, #148]	; 800449c <usbInitEndpointI+0x1ac>
 800440a:	e7a3      	b.n	8004354 <usbInitEndpointI+0x64>
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800440c:	4820      	ldr	r0, [pc, #128]	; (8004490 <usbInitEndpointI+0x1a0>)
 800440e:	f7fc fa07 	bl	8000820 <chSysHalt>
 8004412:	eb05 1148 	add.w	r1, r5, r8, lsl #5
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8004416:	f106 0e10 	add.w	lr, r6, #16
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 800441a:	f8d1 0b00 	ldr.w	r0, [r1, #2816]	; 0xb00
 800441e:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 8004422:	f8c1 0b00 	str.w	r0, [r1, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8004426:	f8d5 181c 	ldr.w	r1, [r5, #2076]	; 0x81c
 800442a:	2001      	movs	r0, #1
 800442c:	fa00 f00e 	lsl.w	r0, r0, lr
 8004430:	ea21 0100 	bic.w	r1, r1, r0
 8004434:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
 8004438:	e7a7      	b.n	800438a <usbInitEndpointI+0x9a>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 800443a:	f106 033f 	add.w	r3, r6, #63	; 0x3f
 800443e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8004440:	4814      	ldr	r0, [pc, #80]	; (8004494 <usbInitEndpointI+0x1a4>)
 8004442:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8004446:	01b1      	lsls	r1, r6, #6
 8004448:	f041 0120 	orr.w	r1, r1, #32
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 800444c:	6058      	str	r0, [r3, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800444e:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8004450:	6913      	ldr	r3, [r2, #16]
 8004452:	069b      	lsls	r3, r3, #26
 8004454:	d4fc      	bmi.n	8004450 <usbInitEndpointI+0x160>
 8004456:	eb05 1848 	add.w	r8, r5, r8, lsl #5
 800445a:	2012      	movs	r0, #18
 800445c:	f7fc f9d0 	bl	8000800 <chSysPolledDelayX>
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8004460:	f8d8 3900 	ldr.w	r3, [r8, #2304]	; 0x900
 8004464:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8004468:	f8c8 3900 	str.w	r3, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 800446c:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 8004470:	2201      	movs	r2, #1
 8004472:	fa02 f606 	lsl.w	r6, r2, r6
 8004476:	ea23 0306 	bic.w	r3, r3, r6
 800447a:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 800447e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004482:	bf00      	nop
 8004484:	0800ad24 	.word	0x0800ad24
 8004488:	10048000 	.word	0x10048000
 800448c:	10008000 	.word	0x10008000
 8004490:	0800b538 	.word	0x0800b538
 8004494:	02000400 	.word	0x02000400
 8004498:	10088000 	.word	0x10088000
 800449c:	100c8000 	.word	0x100c8000

080044a0 <sdu_start_receive.lto_priv.125>:
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 80044a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80044a2:	f8d0 648c 	ldr.w	r6, [r0, #1164]	; 0x48c
 80044a6:	6837      	ldr	r7, [r6, #0]
 80044a8:	783b      	ldrb	r3, [r7, #0]
 80044aa:	2b04      	cmp	r3, #4
 80044ac:	d001      	beq.n	80044b2 <sdu_start_receive.lto_priv.125+0x12>
    return true;
 80044ae:	2001      	movs	r0, #1
 80044b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80044b2:	7a03      	ldrb	r3, [r0, #8]
 80044b4:	2b02      	cmp	r3, #2
 80044b6:	d1fa      	bne.n	80044ae <sdu_start_receive.lto_priv.125+0xe>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80044b8:	7933      	ldrb	r3, [r6, #4]
 80044ba:	897a      	ldrh	r2, [r7, #10]
 80044bc:	2501      	movs	r5, #1
 80044be:	fa05 f303 	lsl.w	r3, r5, r3
 80044c2:	4213      	tst	r3, r2
 80044c4:	d1f3      	bne.n	80044ae <sdu_start_receive.lto_priv.125+0xe>
 80044c6:	4604      	mov	r4, r0
  osalDbgCheckClassI();
 80044c8:	f7fc f9fa 	bl	80008c0 <chDbgCheckClassI>
  if (ibqIsFullI(ibqp)) {
 80044cc:	69e2      	ldr	r2, [r4, #28]
 80044ce:	6a23      	ldr	r3, [r4, #32]
 80044d0:	429a      	cmp	r2, r3
 80044d2:	d009      	beq.n	80044e8 <sdu_start_receive.lto_priv.125+0x48>
  if (buf == NULL) {
 80044d4:	3204      	adds	r2, #4
 80044d6:	d0ea      	beq.n	80044ae <sdu_start_receive.lto_priv.125+0xe>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 80044d8:	4638      	mov	r0, r7
 80044da:	7971      	ldrb	r1, [r6, #5]
 80044dc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80044e0:	f002 fcce 	bl	8006e80 <usbStartReceiveI>
  return false;
 80044e4:	2000      	movs	r0, #0
 80044e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80044e8:	69a3      	ldr	r3, [r4, #24]
 80044ea:	2b00      	cmp	r3, #0
 80044ec:	d1df      	bne.n	80044ae <sdu_start_receive.lto_priv.125+0xe>
 80044ee:	e7f1      	b.n	80044d4 <sdu_start_receive.lto_priv.125+0x34>

080044f0 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80044f0:	310d      	adds	r1, #13
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 80044f2:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80044f4:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 80044f8:	2c00      	cmp	r4, #0
 80044fa:	d03b      	beq.n	8004574 <sduDataReceived+0x84>
 80044fc:	2320      	movs	r3, #32
 80044fe:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8004502:	f7fc fe35 	bl	8001170 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8004506:	1d20      	adds	r0, r4, #4
 8004508:	2104      	movs	r1, #4
 800450a:	f7fc faf1 	bl	8000af0 <chEvtBroadcastFlagsI>
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 800450e:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8004512:	6813      	ldr	r3, [r2, #0]
 8004514:	7952      	ldrb	r2, [r2, #5]
 8004516:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800451a:	68db      	ldr	r3, [r3, #12]
  ibqPostFullBufferI(&sdup->ibqueue,
 800451c:	699b      	ldr	r3, [r3, #24]
 800451e:	685d      	ldr	r5, [r3, #4]
  osalDbgCheckClassI();
 8004520:	f7fc f9ce 	bl	80008c0 <chDbgCheckClassI>
  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 8004524:	b31d      	cbz	r5, 800456e <sduDataReceived+0x7e>
 8004526:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004528:	3b04      	subs	r3, #4
 800452a:	429d      	cmp	r5, r3
 800452c:	d81f      	bhi.n	800456e <sduDataReceived+0x7e>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 800452e:	69e3      	ldr	r3, [r4, #28]
 8004530:	6a22      	ldr	r2, [r4, #32]
 8004532:	4293      	cmp	r3, r2
 8004534:	d018      	beq.n	8004568 <sduDataReceived+0x78>
  *((size_t *)ibqp->bwrptr) = size;
 8004536:	601d      	str	r5, [r3, #0]
  ibqp->bwrptr += ibqp->bsize;
 8004538:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  ibqp->bcounter++;
 800453a:	69a2      	ldr	r2, [r4, #24]
  if (ibqp->bwrptr >= ibqp->btop) {
 800453c:	6a61      	ldr	r1, [r4, #36]	; 0x24
  ibqp->bwrptr += ibqp->bsize;
 800453e:	4403      	add	r3, r0
  ibqp->bcounter++;
 8004540:	3201      	adds	r2, #1
  if (ibqp->bwrptr >= ibqp->btop) {
 8004542:	428b      	cmp	r3, r1
  ibqp->bcounter++;
 8004544:	61a2      	str	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
 8004546:	61e3      	str	r3, [r4, #28]
  if (ibqp->bwrptr >= ibqp->btop) {
 8004548:	d301      	bcc.n	800454e <sduDataReceived+0x5e>
    ibqp->bwrptr = ibqp->buffers;
 800454a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800454c:	61e3      	str	r3, [r4, #28]
  chThdDequeueNextI(tqp, msg);
 800454e:	f104 000c 	add.w	r0, r4, #12
 8004552:	f005 fc15 	bl	8009d80 <chThdDequeueNextI.constprop.69>
  (void) sdu_start_receive(sdup);
 8004556:	4620      	mov	r0, r4
 8004558:	f7ff ffa2 	bl	80044a0 <sdu_start_receive.lto_priv.125>
  _dbg_check_unlock_from_isr();
 800455c:	f7fc fdf0 	bl	8001140 <_dbg_check_unlock_from_isr>
 8004560:	2300      	movs	r3, #0
 8004562:	f383 8811 	msr	BASEPRI, r3
 8004566:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 8004568:	69a2      	ldr	r2, [r4, #24]
 800456a:	2a00      	cmp	r2, #0
 800456c:	d0e3      	beq.n	8004536 <sduDataReceived+0x46>
  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 800456e:	4802      	ldr	r0, [pc, #8]	; (8004578 <sduDataReceived+0x88>)
 8004570:	f7fc f956 	bl	8000820 <chSysHalt>
 8004574:	bd38      	pop	{r3, r4, r5, pc}
 8004576:	bf00      	nop
 8004578:	0800accc 	.word	0x0800accc
 800457c:	00000000 	.word	0x00000000

08004580 <ibnotify.lto_priv.101>:
  (void) sdu_start_receive(sdup);
 8004580:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8004582:	f7ff bf8d 	b.w	80044a0 <sdu_start_receive.lto_priv.125>
 8004586:	bf00      	nop
	...

08004590 <obqGetFullBufferI>:
                           size_t *sizep) {
 8004590:	b538      	push	{r3, r4, r5, lr}
 8004592:	4604      	mov	r4, r0
 8004594:	460d      	mov	r5, r1
  osalDbgCheckClassI();
 8004596:	f7fc f993 	bl	80008c0 <chDbgCheckClassI>
  if (obqIsEmptyI(obqp)) {
 800459a:	6960      	ldr	r0, [r4, #20]
 800459c:	6922      	ldr	r2, [r4, #16]
 800459e:	4282      	cmp	r2, r0
 80045a0:	d003      	beq.n	80045aa <obqGetFullBufferI+0x1a>
  *sizep = *((size_t *)obqp->brdptr);
 80045a2:	f850 3b04 	ldr.w	r3, [r0], #4
 80045a6:	602b      	str	r3, [r5, #0]
}
 80045a8:	bd38      	pop	{r3, r4, r5, pc}
  if (obqIsEmptyI(obqp)) {
 80045aa:	68e2      	ldr	r2, [r4, #12]
 80045ac:	2a00      	cmp	r2, #0
 80045ae:	d0f8      	beq.n	80045a2 <obqGetFullBufferI+0x12>
    return NULL;
 80045b0:	2000      	movs	r0, #0
 80045b2:	bd38      	pop	{r3, r4, r5, pc}
	...

080045c0 <sduDataTransmitted>:
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 80045c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 80045c2:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 80045c6:	b083      	sub	sp, #12
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 80045c8:	6a1c      	ldr	r4, [r3, #32]
  if (sdup == NULL) {
 80045ca:	b30c      	cbz	r4, 8004610 <sduDataTransmitted+0x50>
 80045cc:	460e      	mov	r6, r1
 80045ce:	4605      	mov	r5, r0
 80045d0:	2320      	movs	r3, #32
 80045d2:	f383 8811 	msr	BASEPRI, r3
 80045d6:	eb00 0781 	add.w	r7, r0, r1, lsl #2
  _dbg_check_lock_from_isr();
 80045da:	f7fc fdc9 	bl	8001170 <_dbg_check_lock_from_isr>
  chEvtBroadcastFlagsI(esp, flags);
 80045de:	1d20      	adds	r0, r4, #4
 80045e0:	2108      	movs	r1, #8
 80045e2:	f7fc fa85 	bl	8000af0 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 80045e6:	68fb      	ldr	r3, [r7, #12]
 80045e8:	695b      	ldr	r3, [r3, #20]
 80045ea:	681b      	ldr	r3, [r3, #0]
 80045ec:	b993      	cbnz	r3, 8004614 <sduDataTransmitted+0x54>
 80045ee:	3444      	adds	r4, #68	; 0x44
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80045f0:	4620      	mov	r0, r4
 80045f2:	a901      	add	r1, sp, #4
 80045f4:	f7ff ffcc 	bl	8004590 <obqGetFullBufferI>
  if (buf != NULL) {
 80045f8:	b338      	cbz	r0, 800464a <sduDataTransmitted+0x8a>
    usbStartTransmitI(usbp, ep, buf, n);
 80045fa:	4602      	mov	r2, r0
 80045fc:	4631      	mov	r1, r6
 80045fe:	4628      	mov	r0, r5
 8004600:	9b01      	ldr	r3, [sp, #4]
 8004602:	f002 fbcd 	bl	8006da0 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8004606:	f7fc fd9b 	bl	8001140 <_dbg_check_unlock_from_isr>
 800460a:	2300      	movs	r3, #0
 800460c:	f383 8811 	msr	BASEPRI, r3
}
 8004610:	b003      	add	sp, #12
 8004612:	bdf0      	pop	{r4, r5, r6, r7, pc}
  osalDbgCheckClassI();
 8004614:	f7fc f954 	bl	80008c0 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 8004618:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800461a:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800461c:	429a      	cmp	r2, r3
 800461e:	d024      	beq.n	800466a <sduDataTransmitted+0xaa>
  obqp->brdptr += obqp->bsize;
 8004620:	6e20      	ldr	r0, [r4, #96]	; 0x60
  obqp->bcounter++;
 8004622:	6d22      	ldr	r2, [r4, #80]	; 0x50
  if (obqp->brdptr >= obqp->btop) {
 8004624:	6de1      	ldr	r1, [r4, #92]	; 0x5c
  obqp->brdptr += obqp->bsize;
 8004626:	4403      	add	r3, r0
  obqp->bcounter++;
 8004628:	3201      	adds	r2, #1
  if (obqp->brdptr >= obqp->btop) {
 800462a:	428b      	cmp	r3, r1
  obqp->bcounter++;
 800462c:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
 800462e:	65a3      	str	r3, [r4, #88]	; 0x58
  if (obqp->brdptr >= obqp->btop) {
 8004630:	d301      	bcc.n	8004636 <sduDataTransmitted+0x76>
    obqp->brdptr = obqp->buffers;
 8004632:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8004634:	65a3      	str	r3, [r4, #88]	; 0x58
    obqReleaseEmptyBufferI(&sdup->obqueue);
 8004636:	3444      	adds	r4, #68	; 0x44
  chThdDequeueNextI(tqp, msg);
 8004638:	4620      	mov	r0, r4
 800463a:	f005 fba1 	bl	8009d80 <chThdDequeueNextI.constprop.69>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800463e:	4620      	mov	r0, r4
 8004640:	a901      	add	r1, sp, #4
 8004642:	f7ff ffa5 	bl	8004590 <obqGetFullBufferI>
  if (buf != NULL) {
 8004646:	2800      	cmp	r0, #0
 8004648:	d1d7      	bne.n	80045fa <sduDataTransmitted+0x3a>
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800464a:	68fb      	ldr	r3, [r7, #12]
 800464c:	695a      	ldr	r2, [r3, #20]
 800464e:	6812      	ldr	r2, [r2, #0]
 8004650:	2a00      	cmp	r2, #0
 8004652:	d0d8      	beq.n	8004606 <sduDataTransmitted+0x46>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8004654:	8a1b      	ldrh	r3, [r3, #16]
 8004656:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8004658:	4013      	ands	r3, r2
 800465a:	d1d4      	bne.n	8004606 <sduDataTransmitted+0x46>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 800465c:	4631      	mov	r1, r6
 800465e:	f105 025c 	add.w	r2, r5, #92	; 0x5c
 8004662:	4628      	mov	r0, r5
 8004664:	f002 fb9c 	bl	8006da0 <usbStartTransmitI>
 8004668:	e7cd      	b.n	8004606 <sduDataTransmitted+0x46>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 800466a:	6d22      	ldr	r2, [r4, #80]	; 0x50
 800466c:	2a00      	cmp	r2, #0
 800466e:	d0d7      	beq.n	8004620 <sduDataTransmitted+0x60>
 8004670:	4801      	ldr	r0, [pc, #4]	; (8004678 <sduDataTransmitted+0xb8>)
 8004672:	f7fc f8d5 	bl	8000820 <chSysHalt>
 8004676:	bf00      	nop
 8004678:	0800ad38 	.word	0x0800ad38
 800467c:	00000000 	.word	0x00000000

08004680 <obnotify.lto_priv.102>:
static void obnotify(io_buffers_queue_t *bqp) {
 8004680:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8004682:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004684:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8004688:	6813      	ldr	r3, [r2, #0]
 800468a:	7819      	ldrb	r1, [r3, #0]
 800468c:	2904      	cmp	r1, #4
static void obnotify(io_buffers_queue_t *bqp) {
 800468e:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004690:	d001      	beq.n	8004696 <obnotify.lto_priv.102+0x16>
}
 8004692:	b002      	add	sp, #8
 8004694:	bd10      	pop	{r4, pc}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004696:	7a21      	ldrb	r1, [r4, #8]
 8004698:	2902      	cmp	r1, #2
 800469a:	d1fa      	bne.n	8004692 <obnotify.lto_priv.102+0x12>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800469c:	7911      	ldrb	r1, [r2, #4]
 800469e:	891a      	ldrh	r2, [r3, #8]
 80046a0:	2301      	movs	r3, #1
 80046a2:	408b      	lsls	r3, r1
 80046a4:	4213      	tst	r3, r2
 80046a6:	d1f4      	bne.n	8004692 <obnotify.lto_priv.102+0x12>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80046a8:	a901      	add	r1, sp, #4
 80046aa:	f104 0044 	add.w	r0, r4, #68	; 0x44
 80046ae:	f7ff ff6f 	bl	8004590 <obqGetFullBufferI>
    if (buf != NULL) {
 80046b2:	4602      	mov	r2, r0
 80046b4:	2800      	cmp	r0, #0
 80046b6:	d0ec      	beq.n	8004692 <obnotify.lto_priv.102+0x12>
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80046b8:	f8d4 048c 	ldr.w	r0, [r4, #1164]	; 0x48c
 80046bc:	9b01      	ldr	r3, [sp, #4]
 80046be:	7901      	ldrb	r1, [r0, #4]
 80046c0:	6800      	ldr	r0, [r0, #0]
 80046c2:	f002 fb6d 	bl	8006da0 <usbStartTransmitI>
 80046c6:	e7e4      	b.n	8004692 <obnotify.lto_priv.102+0x12>
	...

080046d0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 80046d0:	b508      	push	{r3, lr}
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80046d2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80046d6:	68da      	ldr	r2, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80046d8:	0792      	lsls	r2, r2, #30
 80046da:	d501      	bpl.n	80046e0 <stSetAlarm+0x10>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80046dc:	6358      	str	r0, [r3, #52]	; 0x34
 80046de:	bd08      	pop	{r3, pc}
 80046e0:	4801      	ldr	r0, [pc, #4]	; (80046e8 <stSetAlarm+0x18>)
 80046e2:	f7fc f89d 	bl	8000820 <chSysHalt>
 80046e6:	bf00      	nop
 80046e8:	0800acc0 	.word	0x0800acc0
 80046ec:	00000000 	.word	0x00000000

080046f0 <_port_irq_epilogue>:
 80046f0:	2320      	movs	r3, #32
 80046f2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80046f6:	4b11      	ldr	r3, [pc, #68]	; (800473c <_port_irq_epilogue+0x4c>)
 80046f8:	685b      	ldr	r3, [r3, #4]
 80046fa:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80046fe:	d102      	bne.n	8004706 <_port_irq_epilogue+0x16>
 8004700:	f383 8811 	msr	BASEPRI, r3
 8004704:	4770      	bx	lr
void _port_irq_epilogue(void) {
 8004706:	b480      	push	{r7}
 8004708:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800470a:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800470e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8004712:	f843 2c04 	str.w	r2, [r3, #-4]
    ctxp--;
 8004716:	f1a3 0220 	sub.w	r2, r3, #32
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800471a:	f382 8809 	msr	PSP, r2
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800471e:	4a08      	ldr	r2, [pc, #32]	; (8004740 <_port_irq_epilogue+0x50>)
 8004720:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 8004722:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004724:	6889      	ldr	r1, [r1, #8]
 8004726:	6892      	ldr	r2, [r2, #8]
 8004728:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800472a:	bf8c      	ite	hi
 800472c:	4a05      	ldrhi	r2, [pc, #20]	; (8004744 <_port_irq_epilogue+0x54>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800472e:	4a06      	ldrls	r2, [pc, #24]	; (8004748 <_port_irq_epilogue+0x58>)
 8004730:	f843 2c08 	str.w	r2, [r3, #-8]
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8004734:	46bd      	mov	sp, r7
 8004736:	bc80      	pop	{r7}
 8004738:	4770      	bx	lr
 800473a:	bf00      	nop
 800473c:	e000ed00 	.word	0xe000ed00
 8004740:	20001e68 	.word	0x20001e68
 8004744:	080002b9 	.word	0x080002b9
 8004748:	080002c4 	.word	0x080002c4
 800474c:	00000000 	.word	0x00000000

08004750 <chPoolFreeI>:
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8004750:	b538      	push	{r3, r4, r5, lr}
 8004752:	4604      	mov	r4, r0
 8004754:	460d      	mov	r5, r1
  chDbgCheckClassI();
 8004756:	f7fc f8b3 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 800475a:	b124      	cbz	r4, 8004766 <chPoolFreeI+0x16>
 800475c:	b11d      	cbz	r5, 8004766 <chPoolFreeI+0x16>
  php->next = mp->next;
 800475e:	6823      	ldr	r3, [r4, #0]
 8004760:	602b      	str	r3, [r5, #0]
  mp->next = php;
 8004762:	6025      	str	r5, [r4, #0]
 8004764:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheck((mp != NULL) && (objp != NULL));
 8004766:	4801      	ldr	r0, [pc, #4]	; (800476c <chPoolFreeI+0x1c>)
 8004768:	f7fc f85a 	bl	8000820 <chSysHalt>
 800476c:	0800aca8 	.word	0x0800aca8

08004770 <chPoolAllocI>:
void *chPoolAllocI(memory_pool_t *mp) {
 8004770:	b510      	push	{r4, lr}
 8004772:	4604      	mov	r4, r0
  chDbgCheckClassI();
 8004774:	f7fc f8a4 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 8004778:	b164      	cbz	r4, 8004794 <chPoolAllocI+0x24>
  objp = mp->next;
 800477a:	6820      	ldr	r0, [r4, #0]
  if (objp != NULL) {
 800477c:	b110      	cbz	r0, 8004784 <chPoolAllocI+0x14>
    mp->next = mp->next->next;
 800477e:	6803      	ldr	r3, [r0, #0]
 8004780:	6023      	str	r3, [r4, #0]
 8004782:	bd10      	pop	{r4, pc}
  else if (mp->provider != NULL) {
 8004784:	68a3      	ldr	r3, [r4, #8]
 8004786:	b123      	cbz	r3, 8004792 <chPoolAllocI+0x22>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8004788:	6860      	ldr	r0, [r4, #4]
 800478a:	2104      	movs	r1, #4
}
 800478c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8004790:	4718      	bx	r3
}
 8004792:	bd10      	pop	{r4, pc}
  chDbgCheck(mp != NULL);
 8004794:	4801      	ldr	r0, [pc, #4]	; (800479c <chPoolAllocI+0x2c>)
 8004796:	f7fc f843 	bl	8000820 <chSysHalt>
 800479a:	bf00      	nop
 800479c:	0800ac98 	.word	0x0800ac98

080047a0 <chHeapStatus>:
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80047a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 80047a4:	4c17      	ldr	r4, [pc, #92]	; (8004804 <chHeapStatus+0x64>)
 80047a6:	2800      	cmp	r0, #0
 80047a8:	bf18      	it	ne
 80047aa:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
 80047ac:	f104 0710 	add.w	r7, r4, #16
 80047b0:	4638      	mov	r0, r7
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80047b2:	4689      	mov	r9, r1
 80047b4:	4690      	mov	r8, r2
  H_LOCK(heapp);
 80047b6:	f7fc ff0b 	bl	80015d0 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80047ba:	68a3      	ldr	r3, [r4, #8]
 80047bc:	b1f3      	cbz	r3, 80047fc <chHeapStatus+0x5c>
 80047be:	2400      	movs	r4, #0
 80047c0:	4625      	mov	r5, r4
 80047c2:	4626      	mov	r6, r4
    size_t pages = H_PAGES(H_NEXT(qp));
 80047c4:	6858      	ldr	r0, [r3, #4]
  while (H_NEXT(qp) != NULL) {
 80047c6:	681b      	ldr	r3, [r3, #0]
 80047c8:	4284      	cmp	r4, r0

    /* Updating counters.*/
    n++;
 80047ca:	f106 0601 	add.w	r6, r6, #1
    tpages += pages;
 80047ce:	4405      	add	r5, r0
 80047d0:	bf38      	it	cc
 80047d2:	4604      	movcc	r4, r0
  while (H_NEXT(qp) != NULL) {
 80047d4:	2b00      	cmp	r3, #0
 80047d6:	d1f5      	bne.n	80047c4 <chHeapStatus+0x24>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 80047d8:	f1b9 0f00 	cmp.w	r9, #0
 80047dc:	d002      	beq.n	80047e4 <chHeapStatus+0x44>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 80047de:	00ed      	lsls	r5, r5, #3
 80047e0:	f8c9 5000 	str.w	r5, [r9]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 80047e4:	f1b8 0f00 	cmp.w	r8, #0
 80047e8:	d002      	beq.n	80047f0 <chHeapStatus+0x50>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 80047ea:	00e4      	lsls	r4, r4, #3
 80047ec:	f8c8 4000 	str.w	r4, [r8]
  }
  H_UNLOCK(heapp);
 80047f0:	4638      	mov	r0, r7
 80047f2:	f7fc fe8d 	bl	8001510 <chMtxUnlock>

  return n;
}
 80047f6:	4630      	mov	r0, r6
 80047f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  lpages = 0U;
 80047fc:	461c      	mov	r4, r3
  tpages = 0U;
 80047fe:	461d      	mov	r5, r3
  n = 0U;
 8004800:	461e      	mov	r6, r3
 8004802:	e7e9      	b.n	80047d8 <chHeapStatus+0x38>
 8004804:	200026f0 	.word	0x200026f0
	...

08004810 <chHeapFree>:
void chHeapFree(void *p) {
 8004810:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8004812:	b328      	cbz	r0, 8004860 <chHeapFree+0x50>
 8004814:	0743      	lsls	r3, r0, #29
 8004816:	4605      	mov	r5, r0
 8004818:	d122      	bne.n	8004860 <chHeapFree+0x50>
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800481a:	f850 3c04 	ldr.w	r3, [r0, #-4]
  heapp = H_HEAP(hp);
 800481e:	f850 4c08 	ldr.w	r4, [r0, #-8]
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8004822:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8004824:	08db      	lsrs	r3, r3, #3
  H_LOCK(heapp);
 8004826:	f104 0610 	add.w	r6, r4, #16
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800482a:	f840 3c04 	str.w	r3, [r0, #-4]
  qp = &heapp->header;
 800482e:	3408      	adds	r4, #8
  H_LOCK(heapp);
 8004830:	4630      	mov	r0, r6
 8004832:	f7fc fecd 	bl	80015d0 <chMtxLock>
  hp = (heap_header_t *)p - 1U;
 8004836:	f1a5 0108 	sub.w	r1, r5, #8
  qp = &heapp->header;
 800483a:	4623      	mov	r3, r4
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 800483c:	428b      	cmp	r3, r1
 800483e:	d805      	bhi.n	800484c <chHeapFree+0x3c>
 8004840:	685a      	ldr	r2, [r3, #4]
 8004842:	3201      	adds	r2, #1
 8004844:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8004848:	4291      	cmp	r1, r2
 800484a:	d309      	bcc.n	8004860 <chHeapFree+0x50>
    if (((qp == &heapp->header) || (hp > qp)) &&
 800484c:	42a3      	cmp	r3, r4
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800484e:	681a      	ldr	r2, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8004850:	d001      	beq.n	8004856 <chHeapFree+0x46>
 8004852:	428b      	cmp	r3, r1
 8004854:	d202      	bcs.n	800485c <chHeapFree+0x4c>
 8004856:	b132      	cbz	r2, 8004866 <chHeapFree+0x56>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8004858:	4291      	cmp	r1, r2
 800485a:	d304      	bcc.n	8004866 <chHeapFree+0x56>
    qp = H_NEXT(qp);
 800485c:	4613      	mov	r3, r2
 800485e:	e7ed      	b.n	800483c <chHeapFree+0x2c>
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8004860:	481a      	ldr	r0, [pc, #104]	; (80048cc <chHeapFree+0xbc>)
 8004862:	f7fb ffdd 	bl	8000820 <chSysHalt>
      H_NEXT(hp) = H_NEXT(qp);
 8004866:	f845 2c08 	str.w	r2, [r5, #-8]
      H_NEXT(qp) = hp;
 800486a:	6019      	str	r1, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800486c:	f855 2c04 	ldr.w	r2, [r5, #-4]
 8004870:	f855 4c08 	ldr.w	r4, [r5, #-8]
 8004874:	3201      	adds	r2, #1
 8004876:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
 800487a:	42a0      	cmp	r0, r4
 800487c:	d00a      	beq.n	8004894 <chHeapFree+0x84>
      if ((H_LIMIT(qp) == hp)) {
 800487e:	6858      	ldr	r0, [r3, #4]
 8004880:	1c42      	adds	r2, r0, #1
 8004882:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8004886:	4291      	cmp	r1, r2
 8004888:	d012      	beq.n	80048b0 <chHeapFree+0xa0>
  H_UNLOCK(heapp);
 800488a:	4630      	mov	r0, r6
}
 800488c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  H_UNLOCK(heapp);
 8004890:	f7fc be3e 	b.w	8001510 <chMtxUnlock>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8004894:	6840      	ldr	r0, [r0, #4]
 8004896:	4410      	add	r0, r2
 8004898:	f845 0c04 	str.w	r0, [r5, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800489c:	f851 2032 	ldr.w	r2, [r1, r2, lsl #3]
 80048a0:	f845 2c08 	str.w	r2, [r5, #-8]
      if ((H_LIMIT(qp) == hp)) {
 80048a4:	6858      	ldr	r0, [r3, #4]
 80048a6:	1c42      	adds	r2, r0, #1
 80048a8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 80048ac:	4291      	cmp	r1, r2
 80048ae:	d1ec      	bne.n	800488a <chHeapFree+0x7a>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80048b0:	f855 2c04 	ldr.w	r2, [r5, #-4]
 80048b4:	3201      	adds	r2, #1
 80048b6:	4410      	add	r0, r2
 80048b8:	6058      	str	r0, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 80048ba:	f855 2c08 	ldr.w	r2, [r5, #-8]
 80048be:	601a      	str	r2, [r3, #0]
  H_UNLOCK(heapp);
 80048c0:	4630      	mov	r0, r6
}
 80048c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  H_UNLOCK(heapp);
 80048c6:	f7fc be23 	b.w	8001510 <chMtxUnlock>
 80048ca:	bf00      	nop
 80048cc:	0800acb4 	.word	0x0800acb4

080048d0 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 80048d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80048d4:	b085      	sub	sp, #20
  size_t w = 0;
  systime_t deadline;

  osalDbgCheck(n > 0U);
 80048d6:	2a00      	cmp	r2, #0
 80048d8:	f000 808b 	beq.w	80049f2 <obqWriteTimeout+0x122>
 80048dc:	4698      	mov	r8, r3
 80048de:	4604      	mov	r4, r0
 80048e0:	468b      	mov	fp, r1
 80048e2:	4617      	mov	r7, r2
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80048e4:	2320      	movs	r3, #32
 80048e6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80048ea:	f7fc fcb9 	bl	8001260 <_dbg_check_lock>
  return (systime_t)STM32_ST_TIM->CNT;
 80048ee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 80048f2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80048f4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80048f6:	9303      	str	r3, [sp, #12]
  size_t w = 0;
 80048f8:	2500      	movs	r5, #0
  deadline = osalOsGetSystemTimeX() + timeout;
 80048fa:	4442      	add	r2, r8
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80048fc:	f108 33ff 	add.w	r3, r8, #4294967295
 8004900:	4e40      	ldr	r6, [pc, #256]	; (8004a04 <obqWriteTimeout+0x134>)
  deadline = osalOsGetSystemTimeX() + timeout;
 8004902:	9202      	str	r2, [sp, #8]
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004904:	9301      	str	r3, [sp, #4]
 8004906:	46a9      	mov	r9, r5
    if (obqp->ptr == NULL) {
 8004908:	2800      	cmp	r0, #0
 800490a:	d04f      	beq.n	80049ac <obqWriteTimeout+0xdc>
        return w;
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 800490c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if (size > (n - w)) {
 800490e:	eba7 0a05 	sub.w	sl, r7, r5
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8004912:	1a1b      	subs	r3, r3, r0
 8004914:	459a      	cmp	sl, r3
 8004916:	bf28      	it	cs
 8004918:	469a      	movcs	sl, r3
      size = n - w;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 800491a:	f1ba 0f40 	cmp.w	sl, #64	; 0x40
 800491e:	d923      	bls.n	8004968 <obqWriteTimeout+0x98>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 8004920:	f10b 0340 	add.w	r3, fp, #64	; 0x40
 8004924:	f8db e000 	ldr.w	lr, [fp]
 8004928:	f8db 1004 	ldr.w	r1, [fp, #4]
 800492c:	f8db 2008 	ldr.w	r2, [fp, #8]
 8004930:	f8db c00c 	ldr.w	ip, [fp, #12]
 8004934:	f8c0 c00c 	str.w	ip, [r0, #12]
 8004938:	f10b 0b10 	add.w	fp, fp, #16
 800493c:	459b      	cmp	fp, r3
 800493e:	f8c0 e000 	str.w	lr, [r0]
 8004942:	6041      	str	r1, [r0, #4]
 8004944:	6082      	str	r2, [r0, #8]
 8004946:	f100 0010 	add.w	r0, r0, #16
 800494a:	d1eb      	bne.n	8004924 <obqWriteTimeout+0x54>
      bp        += 64U;
      obqp->ptr += 64U;
 800494c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 800494e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      obqp->ptr += 64U;
 8004950:	3340      	adds	r3, #64	; 0x40
    if (obqp->ptr >= obqp->top) {
 8004952:	429a      	cmp	r2, r3
      w         += 64U;
 8004954:	f105 0540 	add.w	r5, r5, #64	; 0x40
      obqp->ptr += 64U;
 8004958:	62a3      	str	r3, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 800495a:	d811      	bhi.n	8004980 <obqWriteTimeout+0xb0>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800495c:	69e1      	ldr	r1, [r4, #28]
 800495e:	4620      	mov	r0, r4
 8004960:	3904      	subs	r1, #4
 8004962:	f7ff fc2d 	bl	80041c0 <obqPostFullBufferS>
 8004966:	e00b      	b.n	8004980 <obqWriteTimeout+0xb0>
      memcpy(obqp->ptr, bp, size);
 8004968:	4652      	mov	r2, sl
 800496a:	4659      	mov	r1, fp
 800496c:	f7fb fcac 	bl	80002c8 <memcpy>
      obqp->ptr += size;
 8004970:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 8004972:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      obqp->ptr += size;
 8004974:	4453      	add	r3, sl
    if (obqp->ptr >= obqp->top) {
 8004976:	429a      	cmp	r2, r3
      w         += size;
 8004978:	4455      	add	r5, sl
      bp        += size;
 800497a:	44d3      	add	fp, sl
      obqp->ptr += size;
 800497c:	62a3      	str	r3, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
 800497e:	d9ed      	bls.n	800495c <obqWriteTimeout+0x8c>
  _dbg_check_unlock();
 8004980:	f7fc fc46 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004984:	6833      	ldr	r3, [r6, #0]
 8004986:	42b3      	cmp	r3, r6
 8004988:	d004      	beq.n	8004994 <obqWriteTimeout+0xc4>
 800498a:	69b2      	ldr	r2, [r6, #24]
 800498c:	689b      	ldr	r3, [r3, #8]
 800498e:	6892      	ldr	r2, [r2, #8]
 8004990:	429a      	cmp	r2, r3
 8004992:	d32b      	bcc.n	80049ec <obqWriteTimeout+0x11c>
 8004994:	f389 8811 	msr	BASEPRI, r9
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (w >= n) {
 8004998:	42bd      	cmp	r5, r7
 800499a:	d223      	bcs.n	80049e4 <obqWriteTimeout+0x114>
 800499c:	2320      	movs	r3, #32
 800499e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80049a2:	f7fc fc5d 	bl	8001260 <_dbg_check_lock>
    if (obqp->ptr == NULL) {
 80049a6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80049a8:	2800      	cmp	r0, #0
 80049aa:	d1af      	bne.n	800490c <obqWriteTimeout+0x3c>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80049ac:	9b01      	ldr	r3, [sp, #4]
 80049ae:	3303      	adds	r3, #3
 80049b0:	d822      	bhi.n	80049f8 <obqWriteTimeout+0x128>
 80049b2:	9b03      	ldr	r3, [sp, #12]
 80049b4:	6a59      	ldr	r1, [r3, #36]	; 0x24
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80049b6:	9b02      	ldr	r3, [sp, #8]
 80049b8:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 80049ba:	4588      	cmp	r8, r1
 80049bc:	d305      	bcc.n	80049ca <obqWriteTimeout+0xfa>
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 80049be:	4620      	mov	r0, r4
 80049c0:	f7ff fc46 	bl	8004250 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 80049c4:	b908      	cbnz	r0, 80049ca <obqWriteTimeout+0xfa>
 80049c6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80049c8:	e7a0      	b.n	800490c <obqWriteTimeout+0x3c>
  _dbg_check_unlock();
 80049ca:	f7fc fc21 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80049ce:	6833      	ldr	r3, [r6, #0]
 80049d0:	42b3      	cmp	r3, r6
 80049d2:	d004      	beq.n	80049de <obqWriteTimeout+0x10e>
 80049d4:	69b2      	ldr	r2, [r6, #24]
 80049d6:	689b      	ldr	r3, [r3, #8]
 80049d8:	6892      	ldr	r2, [r2, #8]
 80049da:	429a      	cmp	r2, r3
 80049dc:	d306      	bcc.n	80049ec <obqWriteTimeout+0x11c>
 80049de:	2300      	movs	r3, #0
 80049e0:	f383 8811 	msr	BASEPRI, r3
      return w;
    }
    osalSysLock();
  }
}
 80049e4:	4628      	mov	r0, r5
 80049e6:	b005      	add	sp, #20
 80049e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80049ec:	4806      	ldr	r0, [pc, #24]	; (8004a08 <obqWriteTimeout+0x138>)
 80049ee:	f7fb ff17 	bl	8000820 <chSysHalt>
  osalDbgCheck(n > 0U);
 80049f2:	4806      	ldr	r0, [pc, #24]	; (8004a0c <obqWriteTimeout+0x13c>)
 80049f4:	f7fb ff14 	bl	8000820 <chSysHalt>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80049f8:	4641      	mov	r1, r8
 80049fa:	4620      	mov	r0, r4
 80049fc:	f7ff fc28 	bl	8004250 <obqGetEmptyBufferTimeoutS>
 8004a00:	e7e0      	b.n	80049c4 <obqWriteTimeout+0xf4>
 8004a02:	bf00      	nop
 8004a04:	20001e68 	.word	0x20001e68
 8004a08:	0800ac78 	.word	0x0800ac78
 8004a0c:	0800ad80 	.word	0x0800ad80

08004a10 <_writet.lto_priv.113>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 8004a10:	3044      	adds	r0, #68	; 0x44
 8004a12:	f7ff bf5d 	b.w	80048d0 <obqWriteTimeout>
 8004a16:	bf00      	nop
	...

08004a20 <_write.lto_priv.107>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 8004a20:	3044      	adds	r0, #68	; 0x44
 8004a22:	f04f 33ff 	mov.w	r3, #4294967295
 8004a26:	f7ff bf53 	b.w	80048d0 <obqWriteTimeout>
 8004a2a:	bf00      	nop
 8004a2c:	0000      	movs	r0, r0
	...

08004a30 <obqPutTimeout>:
                    systime_t timeout) {
 8004a30:	b570      	push	{r4, r5, r6, lr}
 8004a32:	2320      	movs	r3, #32
 8004a34:	b082      	sub	sp, #8
 8004a36:	4604      	mov	r4, r0
 8004a38:	460d      	mov	r5, r1
 8004a3a:	4616      	mov	r6, r2
 8004a3c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004a40:	f7fc fc0e 	bl	8001260 <_dbg_check_lock>
  if (obqp->ptr == NULL) {
 8004a44:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004a46:	b1fb      	cbz	r3, 8004a88 <obqPutTimeout+0x58>
  *obqp->ptr = b;
 8004a48:	701d      	strb	r5, [r3, #0]
  obqp->ptr++;
 8004a4a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 8004a4c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  obqp->ptr++;
 8004a4e:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 8004a50:	4293      	cmp	r3, r2
  obqp->ptr++;
 8004a52:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
 8004a54:	d212      	bcs.n	8004a7c <obqPutTimeout+0x4c>
  _dbg_check_unlock();
 8004a56:	f7fc fbdb 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004a5a:	4b17      	ldr	r3, [pc, #92]	; (8004ab8 <obqPutTimeout+0x88>)
 8004a5c:	681a      	ldr	r2, [r3, #0]
 8004a5e:	429a      	cmp	r2, r3
 8004a60:	d004      	beq.n	8004a6c <obqPutTimeout+0x3c>
 8004a62:	6999      	ldr	r1, [r3, #24]
 8004a64:	6893      	ldr	r3, [r2, #8]
 8004a66:	688a      	ldr	r2, [r1, #8]
 8004a68:	429a      	cmp	r2, r3
 8004a6a:	d304      	bcc.n	8004a76 <obqPutTimeout+0x46>
 8004a6c:	2000      	movs	r0, #0
 8004a6e:	f380 8811 	msr	BASEPRI, r0
}
 8004a72:	b002      	add	sp, #8
 8004a74:	bd70      	pop	{r4, r5, r6, pc}
 8004a76:	4811      	ldr	r0, [pc, #68]	; (8004abc <obqPutTimeout+0x8c>)
 8004a78:	f7fb fed2 	bl	8000820 <chSysHalt>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8004a7c:	69e1      	ldr	r1, [r4, #28]
 8004a7e:	4620      	mov	r0, r4
 8004a80:	3904      	subs	r1, #4
 8004a82:	f7ff fb9d 	bl	80041c0 <obqPostFullBufferS>
 8004a86:	e7e6      	b.n	8004a56 <obqPutTimeout+0x26>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8004a88:	4631      	mov	r1, r6
 8004a8a:	4620      	mov	r0, r4
 8004a8c:	f7ff fbe0 	bl	8004250 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8004a90:	b908      	cbnz	r0, 8004a96 <obqPutTimeout+0x66>
 8004a92:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004a94:	e7d8      	b.n	8004a48 <obqPutTimeout+0x18>
 8004a96:	9001      	str	r0, [sp, #4]
  _dbg_check_unlock();
 8004a98:	f7fc fbba 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004a9c:	4b06      	ldr	r3, [pc, #24]	; (8004ab8 <obqPutTimeout+0x88>)
 8004a9e:	9801      	ldr	r0, [sp, #4]
 8004aa0:	681a      	ldr	r2, [r3, #0]
 8004aa2:	429a      	cmp	r2, r3
 8004aa4:	d004      	beq.n	8004ab0 <obqPutTimeout+0x80>
 8004aa6:	6999      	ldr	r1, [r3, #24]
 8004aa8:	6893      	ldr	r3, [r2, #8]
 8004aaa:	688a      	ldr	r2, [r1, #8]
 8004aac:	429a      	cmp	r2, r3
 8004aae:	d3e2      	bcc.n	8004a76 <obqPutTimeout+0x46>
 8004ab0:	2300      	movs	r3, #0
 8004ab2:	f383 8811 	msr	BASEPRI, r3
 8004ab6:	e7dc      	b.n	8004a72 <obqPutTimeout+0x42>
 8004ab8:	20001e68 	.word	0x20001e68
 8004abc:	0800ac78 	.word	0x0800ac78

08004ac0 <_putt.lto_priv.111>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8004ac0:	3044      	adds	r0, #68	; 0x44
 8004ac2:	f7ff bfb5 	b.w	8004a30 <obqPutTimeout>
 8004ac6:	bf00      	nop
	...

08004ad0 <_put.lto_priv.109>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8004ad0:	3044      	adds	r0, #68	; 0x44
 8004ad2:	f04f 32ff 	mov.w	r2, #4294967295
 8004ad6:	f7ff bfab 	b.w	8004a30 <obqPutTimeout>
 8004ada:	bf00      	nop
 8004adc:	0000      	movs	r0, r0
	...

08004ae0 <ibqReadTimeout>:
                      size_t n, systime_t timeout) {
 8004ae0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004ae4:	b085      	sub	sp, #20
  osalDbgCheck(n > 0U);
 8004ae6:	2a00      	cmp	r2, #0
 8004ae8:	f000 808b 	beq.w	8004c02 <ibqReadTimeout+0x122>
 8004aec:	4699      	mov	r9, r3
 8004aee:	4604      	mov	r4, r0
 8004af0:	460f      	mov	r7, r1
 8004af2:	4690      	mov	r8, r2
 8004af4:	2320      	movs	r3, #32
 8004af6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004afa:	f7fc fbb1 	bl	8001260 <_dbg_check_lock>
 8004afe:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    if (ibqp->ptr == NULL) {
 8004b02:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8004b04:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004b06:	9303      	str	r3, [sp, #12]
  size_t r = 0;
 8004b08:	2500      	movs	r5, #0
  deadline = osalOsGetSystemTimeX() + timeout;
 8004b0a:	444a      	add	r2, r9
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004b0c:	f109 33ff 	add.w	r3, r9, #4294967295
 8004b10:	4e40      	ldr	r6, [pc, #256]	; (8004c14 <ibqReadTimeout+0x134>)
  deadline = osalOsGetSystemTimeX() + timeout;
 8004b12:	9202      	str	r2, [sp, #8]
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004b14:	9301      	str	r3, [sp, #4]
 8004b16:	46aa      	mov	sl, r5
    if (ibqp->ptr == NULL) {
 8004b18:	2900      	cmp	r1, #0
 8004b1a:	d04f      	beq.n	8004bbc <ibqReadTimeout+0xdc>
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004b1c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if (size > (n - r)) {
 8004b1e:	eba8 0b05 	sub.w	fp, r8, r5
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004b22:	1a5b      	subs	r3, r3, r1
 8004b24:	459b      	cmp	fp, r3
 8004b26:	bf28      	it	cs
 8004b28:	469b      	movcs	fp, r3
    if (size > 64U) {
 8004b2a:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
 8004b2e:	d923      	bls.n	8004b78 <ibqReadTimeout+0x98>
      memcpy(bp, ibqp->ptr, 64U);
 8004b30:	f101 0240 	add.w	r2, r1, #64	; 0x40
 8004b34:	463b      	mov	r3, r7
 8004b36:	f8d1 c000 	ldr.w	ip, [r1]
 8004b3a:	f8d1 e004 	ldr.w	lr, [r1, #4]
 8004b3e:	6888      	ldr	r0, [r1, #8]
 8004b40:	f8d1 b00c 	ldr.w	fp, [r1, #12]
 8004b44:	f8c3 b00c 	str.w	fp, [r3, #12]
 8004b48:	3110      	adds	r1, #16
 8004b4a:	4291      	cmp	r1, r2
 8004b4c:	f8c3 c000 	str.w	ip, [r3]
 8004b50:	f8c3 e004 	str.w	lr, [r3, #4]
 8004b54:	6098      	str	r0, [r3, #8]
 8004b56:	f103 0310 	add.w	r3, r3, #16
 8004b5a:	d1ec      	bne.n	8004b36 <ibqReadTimeout+0x56>
      ibqp->ptr += 64U;
 8004b5c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 8004b5e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      ibqp->ptr += 64U;
 8004b60:	3340      	adds	r3, #64	; 0x40
    if (ibqp->ptr >= ibqp->top) {
 8004b62:	429a      	cmp	r2, r3
      bp        += 64U;
 8004b64:	f107 0740 	add.w	r7, r7, #64	; 0x40
      r         += 64U;
 8004b68:	f105 0540 	add.w	r5, r5, #64	; 0x40
      ibqp->ptr += 64U;
 8004b6c:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 8004b6e:	d80f      	bhi.n	8004b90 <ibqReadTimeout+0xb0>
      ibqReleaseEmptyBufferS(ibqp);
 8004b70:	4620      	mov	r0, r4
 8004b72:	f7ff fb4d 	bl	8004210 <ibqReleaseEmptyBufferS>
 8004b76:	e00b      	b.n	8004b90 <ibqReadTimeout+0xb0>
      memcpy(bp, ibqp->ptr, size);
 8004b78:	465a      	mov	r2, fp
 8004b7a:	4638      	mov	r0, r7
 8004b7c:	f7fb fba4 	bl	80002c8 <memcpy>
      ibqp->ptr += size;
 8004b80:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 8004b82:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      ibqp->ptr += size;
 8004b84:	445b      	add	r3, fp
    if (ibqp->ptr >= ibqp->top) {
 8004b86:	429a      	cmp	r2, r3
      r         += size;
 8004b88:	445d      	add	r5, fp
      bp        += size;
 8004b8a:	445f      	add	r7, fp
      ibqp->ptr += size;
 8004b8c:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
 8004b8e:	d9ef      	bls.n	8004b70 <ibqReadTimeout+0x90>
  _dbg_check_unlock();
 8004b90:	f7fc fb3e 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004b94:	6833      	ldr	r3, [r6, #0]
 8004b96:	42b3      	cmp	r3, r6
 8004b98:	d004      	beq.n	8004ba4 <ibqReadTimeout+0xc4>
 8004b9a:	69b2      	ldr	r2, [r6, #24]
 8004b9c:	689b      	ldr	r3, [r3, #8]
 8004b9e:	6892      	ldr	r2, [r2, #8]
 8004ba0:	429a      	cmp	r2, r3
 8004ba2:	d32b      	bcc.n	8004bfc <ibqReadTimeout+0x11c>
 8004ba4:	f38a 8811 	msr	BASEPRI, sl
    if (r >= n) {
 8004ba8:	4545      	cmp	r5, r8
 8004baa:	d223      	bcs.n	8004bf4 <ibqReadTimeout+0x114>
 8004bac:	2320      	movs	r3, #32
 8004bae:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004bb2:	f7fc fb55 	bl	8001260 <_dbg_check_lock>
    if (ibqp->ptr == NULL) {
 8004bb6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8004bb8:	2900      	cmp	r1, #0
 8004bba:	d1af      	bne.n	8004b1c <ibqReadTimeout+0x3c>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004bbc:	9b01      	ldr	r3, [sp, #4]
 8004bbe:	3303      	adds	r3, #3
 8004bc0:	d822      	bhi.n	8004c08 <ibqReadTimeout+0x128>
 8004bc2:	9b03      	ldr	r3, [sp, #12]
 8004bc4:	6a59      	ldr	r1, [r3, #36]	; 0x24
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8004bc6:	9b02      	ldr	r3, [sp, #8]
 8004bc8:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 8004bca:	4589      	cmp	r9, r1
 8004bcc:	d305      	bcc.n	8004bda <ibqReadTimeout+0xfa>
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 8004bce:	4620      	mov	r0, r4
 8004bd0:	f7ff fb66 	bl	80042a0 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 8004bd4:	b908      	cbnz	r0, 8004bda <ibqReadTimeout+0xfa>
 8004bd6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8004bd8:	e7a0      	b.n	8004b1c <ibqReadTimeout+0x3c>
  _dbg_check_unlock();
 8004bda:	f7fc fb19 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004bde:	6833      	ldr	r3, [r6, #0]
 8004be0:	42b3      	cmp	r3, r6
 8004be2:	d004      	beq.n	8004bee <ibqReadTimeout+0x10e>
 8004be4:	69b2      	ldr	r2, [r6, #24]
 8004be6:	689b      	ldr	r3, [r3, #8]
 8004be8:	6892      	ldr	r2, [r2, #8]
 8004bea:	429a      	cmp	r2, r3
 8004bec:	d306      	bcc.n	8004bfc <ibqReadTimeout+0x11c>
 8004bee:	2300      	movs	r3, #0
 8004bf0:	f383 8811 	msr	BASEPRI, r3
}
 8004bf4:	4628      	mov	r0, r5
 8004bf6:	b005      	add	sp, #20
 8004bf8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004bfc:	4806      	ldr	r0, [pc, #24]	; (8004c18 <ibqReadTimeout+0x138>)
 8004bfe:	f7fb fe0f 	bl	8000820 <chSysHalt>
  osalDbgCheck(n > 0U);
 8004c02:	4806      	ldr	r0, [pc, #24]	; (8004c1c <ibqReadTimeout+0x13c>)
 8004c04:	f7fb fe0c 	bl	8000820 <chSysHalt>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004c08:	4649      	mov	r1, r9
 8004c0a:	4620      	mov	r0, r4
 8004c0c:	f7ff fb48 	bl	80042a0 <ibqGetFullBufferTimeoutS>
 8004c10:	e7e0      	b.n	8004bd4 <ibqReadTimeout+0xf4>
 8004c12:	bf00      	nop
 8004c14:	20001e68 	.word	0x20001e68
 8004c18:	0800ac78 	.word	0x0800ac78
 8004c1c:	0800ad14 	.word	0x0800ad14

08004c20 <_readt.lto_priv.114>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 8004c20:	300c      	adds	r0, #12
 8004c22:	f7ff bf5d 	b.w	8004ae0 <ibqReadTimeout>
 8004c26:	bf00      	nop
	...

08004c30 <_read.lto_priv.108>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 8004c30:	300c      	adds	r0, #12
 8004c32:	f04f 33ff 	mov.w	r3, #4294967295
 8004c36:	f7ff bf53 	b.w	8004ae0 <ibqReadTimeout>
 8004c3a:	bf00      	nop
 8004c3c:	0000      	movs	r0, r0
	...

08004c40 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8004c40:	b530      	push	{r4, r5, lr}
 8004c42:	2320      	movs	r3, #32
 8004c44:	b083      	sub	sp, #12
 8004c46:	4604      	mov	r4, r0
 8004c48:	460d      	mov	r5, r1
 8004c4a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004c4e:	f7fc fb07 	bl	8001260 <_dbg_check_lock>
  if (ibqp->ptr == NULL) {
 8004c52:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004c54:	b353      	cbz	r3, 8004cac <ibqGetTimeout+0x6c>
  msg = (msg_t)*ibqp->ptr;
 8004c56:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
 8004c5a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  ibqp->ptr++;
 8004c5c:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
 8004c5e:	4293      	cmp	r3, r2
 8004c60:	d220      	bcs.n	8004ca4 <ibqGetTimeout+0x64>
  _dbg_check_unlock();
 8004c62:	f7fc fad5 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004c66:	4b15      	ldr	r3, [pc, #84]	; (8004cbc <ibqGetTimeout+0x7c>)
 8004c68:	681a      	ldr	r2, [r3, #0]
 8004c6a:	429a      	cmp	r2, r3
 8004c6c:	d004      	beq.n	8004c78 <ibqGetTimeout+0x38>
 8004c6e:	6999      	ldr	r1, [r3, #24]
 8004c70:	6893      	ldr	r3, [r2, #8]
 8004c72:	688a      	ldr	r2, [r1, #8]
 8004c74:	429a      	cmp	r2, r3
 8004c76:	d312      	bcc.n	8004c9e <ibqGetTimeout+0x5e>
  msg = (msg_t)*ibqp->ptr;
 8004c78:	4628      	mov	r0, r5
 8004c7a:	2300      	movs	r3, #0
 8004c7c:	f383 8811 	msr	BASEPRI, r3
}
 8004c80:	b003      	add	sp, #12
 8004c82:	bd30      	pop	{r4, r5, pc}
 8004c84:	9001      	str	r0, [sp, #4]
  _dbg_check_unlock();
 8004c86:	f7fc fac3 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004c8a:	4b0c      	ldr	r3, [pc, #48]	; (8004cbc <ibqGetTimeout+0x7c>)
 8004c8c:	9801      	ldr	r0, [sp, #4]
 8004c8e:	681a      	ldr	r2, [r3, #0]
 8004c90:	429a      	cmp	r2, r3
 8004c92:	d0f2      	beq.n	8004c7a <ibqGetTimeout+0x3a>
 8004c94:	6999      	ldr	r1, [r3, #24]
 8004c96:	6893      	ldr	r3, [r2, #8]
 8004c98:	688a      	ldr	r2, [r1, #8]
 8004c9a:	429a      	cmp	r2, r3
 8004c9c:	d2ed      	bcs.n	8004c7a <ibqGetTimeout+0x3a>
 8004c9e:	4808      	ldr	r0, [pc, #32]	; (8004cc0 <ibqGetTimeout+0x80>)
 8004ca0:	f7fb fdbe 	bl	8000820 <chSysHalt>
    ibqReleaseEmptyBufferS(ibqp);
 8004ca4:	4620      	mov	r0, r4
 8004ca6:	f7ff fab3 	bl	8004210 <ibqReleaseEmptyBufferS>
 8004caa:	e7da      	b.n	8004c62 <ibqGetTimeout+0x22>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004cac:	4629      	mov	r1, r5
 8004cae:	4620      	mov	r0, r4
 8004cb0:	f7ff faf6 	bl	80042a0 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 8004cb4:	2800      	cmp	r0, #0
 8004cb6:	d1e5      	bne.n	8004c84 <ibqGetTimeout+0x44>
 8004cb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8004cba:	e7cc      	b.n	8004c56 <ibqGetTimeout+0x16>
 8004cbc:	20001e68 	.word	0x20001e68
 8004cc0:	0800ac78 	.word	0x0800ac78
	...

08004cd0 <_gett.lto_priv.112>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 8004cd0:	300c      	adds	r0, #12
 8004cd2:	f7ff bfb5 	b.w	8004c40 <ibqGetTimeout>
 8004cd6:	bf00      	nop
	...

08004ce0 <_get.lto_priv.110>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 8004ce0:	300c      	adds	r0, #12
 8004ce2:	f04f 31ff 	mov.w	r1, #4294967295
 8004ce6:	f7ff bfab 	b.w	8004c40 <ibqGetTimeout>
 8004cea:	bf00      	nop
 8004cec:	0000      	movs	r0, r0
	...

08004cf0 <chPoolAlloc>:
void *chPoolAlloc(memory_pool_t *mp) {
 8004cf0:	b510      	push	{r4, lr}
 8004cf2:	2320      	movs	r3, #32
 8004cf4:	4604      	mov	r4, r0
 8004cf6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004cfa:	f7fc fab1 	bl	8001260 <_dbg_check_lock>
  objp = chPoolAllocI(mp);
 8004cfe:	4620      	mov	r0, r4
 8004d00:	f7ff fd36 	bl	8004770 <chPoolAllocI>
 8004d04:	4604      	mov	r4, r0
  _dbg_check_unlock();
 8004d06:	f7fc fa83 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004d0a:	4b08      	ldr	r3, [pc, #32]	; (8004d2c <chPoolAlloc+0x3c>)
 8004d0c:	681a      	ldr	r2, [r3, #0]
 8004d0e:	429a      	cmp	r2, r3
 8004d10:	d004      	beq.n	8004d1c <chPoolAlloc+0x2c>
 8004d12:	6999      	ldr	r1, [r3, #24]
 8004d14:	6893      	ldr	r3, [r2, #8]
 8004d16:	688a      	ldr	r2, [r1, #8]
 8004d18:	429a      	cmp	r2, r3
 8004d1a:	d304      	bcc.n	8004d26 <chPoolAlloc+0x36>
 8004d1c:	2300      	movs	r3, #0
 8004d1e:	f383 8811 	msr	BASEPRI, r3
}
 8004d22:	4620      	mov	r0, r4
 8004d24:	bd10      	pop	{r4, pc}
 8004d26:	4802      	ldr	r0, [pc, #8]	; (8004d30 <chPoolAlloc+0x40>)
 8004d28:	f7fb fd7a 	bl	8000820 <chSysHalt>
 8004d2c:	20001e68 	.word	0x20001e68
 8004d30:	0800a840 	.word	0x0800a840
	...

08004d40 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 8004d40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004d42:	4605      	mov	r5, r0
 8004d44:	460c      	mov	r4, r1
 8004d46:	2320      	movs	r3, #32
 8004d48:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8004d4c:	f7fc fa88 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8004d50:	f7fb fdb6 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8004d54:	b31c      	cbz	r4, 8004d9e <chCoreAllocAligned+0x5e>
 8004d56:	1e61      	subs	r1, r4, #1
 8004d58:	ea14 0701 	ands.w	r7, r4, r1
 8004d5c:	d11f      	bne.n	8004d9e <chCoreAllocAligned+0x5e>
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8004d5e:	4e13      	ldr	r6, [pc, #76]	; (8004dac <chCoreAllocAligned+0x6c>)
  if (((size_t)endmem - (size_t)p) < size) {
 8004d60:	4a13      	ldr	r2, [pc, #76]	; (8004db0 <chCoreAllocAligned+0x70>)
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8004d62:	6830      	ldr	r0, [r6, #0]
  if (((size_t)endmem - (size_t)p) < size) {
 8004d64:	6813      	ldr	r3, [r2, #0]
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8004d66:	3801      	subs	r0, #1
 8004d68:	4420      	add	r0, r4
  size = MEM_ALIGN_NEXT(size, align);
 8004d6a:	4264      	negs	r4, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8004d6c:	4020      	ands	r0, r4
  size = MEM_ALIGN_NEXT(size, align);
 8004d6e:	440d      	add	r5, r1
 8004d70:	402c      	ands	r4, r5
  if (((size_t)endmem - (size_t)p) < size) {
 8004d72:	1a1b      	subs	r3, r3, r0
 8004d74:	429c      	cmp	r4, r3
 8004d76:	d802      	bhi.n	8004d7e <chCoreAllocAligned+0x3e>
  nextmem = p + size;
 8004d78:	4404      	add	r4, r0
 8004d7a:	6034      	str	r4, [r6, #0]
  return p;
 8004d7c:	4607      	mov	r7, r0
  _dbg_check_unlock();
 8004d7e:	f7fc fa47 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004d82:	4b0c      	ldr	r3, [pc, #48]	; (8004db4 <chCoreAllocAligned+0x74>)
 8004d84:	681a      	ldr	r2, [r3, #0]
 8004d86:	429a      	cmp	r2, r3
 8004d88:	d004      	beq.n	8004d94 <chCoreAllocAligned+0x54>
 8004d8a:	6999      	ldr	r1, [r3, #24]
 8004d8c:	6893      	ldr	r3, [r2, #8]
 8004d8e:	688a      	ldr	r2, [r1, #8]
 8004d90:	429a      	cmp	r2, r3
 8004d92:	d307      	bcc.n	8004da4 <chCoreAllocAligned+0x64>
 8004d94:	2300      	movs	r3, #0
 8004d96:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 8004d9a:	4638      	mov	r0, r7
 8004d9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8004d9e:	4806      	ldr	r0, [pc, #24]	; (8004db8 <chCoreAllocAligned+0x78>)
 8004da0:	f7fb fd3e 	bl	8000820 <chSysHalt>
 8004da4:	4805      	ldr	r0, [pc, #20]	; (8004dbc <chCoreAllocAligned+0x7c>)
 8004da6:	f7fb fd3b 	bl	8000820 <chSysHalt>
 8004daa:	bf00      	nop
 8004dac:	20001594 	.word	0x20001594
 8004db0:	20001590 	.word	0x20001590
 8004db4:	20001e68 	.word	0x20001e68
 8004db8:	0800ac84 	.word	0x0800ac84
 8004dbc:	0800ac6c 	.word	0x0800ac6c

08004dc0 <test_007_003_setup.lto_priv.216>:
 8004dc0:	f002 bafe 	b.w	80073c0 <test_007_006_setup.lto_priv.156>
	...

08004dd0 <test_007_002_setup.lto_priv.214>:
 8004dd0:	f002 baf6 	b.w	80073c0 <test_007_006_setup.lto_priv.156>
	...

08004de0 <test_005_009_setup.lto_priv.210>:
  tqp->next = (thread_t *)tqp;
 8004de0:	4a06      	ldr	r2, [pc, #24]	; (8004dfc <test_005_009_setup.lto_priv.210+0x1c>)
 8004de2:	4b07      	ldr	r3, [pc, #28]	; (8004e00 <test_005_009_setup.lto_priv.210+0x20>)
 8004de4:	4907      	ldr	r1, [pc, #28]	; (8004e04 <test_005_009_setup.lto_priv.210+0x24>)
 8004de6:	6012      	str	r2, [r2, #0]
 8004de8:	2000      	movs	r0, #0
 8004dea:	6009      	str	r1, [r1, #0]
  tqp->prev = (thread_t *)tqp;
 8004dec:	6049      	str	r1, [r1, #4]
 8004dee:	6052      	str	r2, [r2, #4]
 8004df0:	6090      	str	r0, [r2, #8]
 8004df2:	6098      	str	r0, [r3, #8]
  tqp->next = (thread_t *)tqp;
 8004df4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004df6:	605b      	str	r3, [r3, #4]
 8004df8:	4770      	bx	lr
 8004dfa:	bf00      	nop
 8004dfc:	20000c50 	.word	0x20000c50
 8004e00:	20000c24 	.word	0x20000c24
 8004e04:	20000c48 	.word	0x20000c48
	...

08004e10 <test_005_008_setup.lto_priv.208>:
  tqp->next = (thread_t *)tqp;
 8004e10:	4b04      	ldr	r3, [pc, #16]	; (8004e24 <test_005_008_setup.lto_priv.208+0x14>)
 8004e12:	4a05      	ldr	r2, [pc, #20]	; (8004e28 <test_005_008_setup.lto_priv.208+0x18>)
 8004e14:	601b      	str	r3, [r3, #0]
 8004e16:	2100      	movs	r1, #0
 8004e18:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8004e1a:	6052      	str	r2, [r2, #4]
 8004e1c:	605b      	str	r3, [r3, #4]
 8004e1e:	6099      	str	r1, [r3, #8]
 8004e20:	4770      	bx	lr
 8004e22:	bf00      	nop
 8004e24:	20000c50 	.word	0x20000c50
 8004e28:	20000c48 	.word	0x20000c48
 8004e2c:	00000000 	.word	0x00000000

08004e30 <test_005_007_setup.lto_priv.206>:
 8004e30:	f7ff bfee 	b.w	8004e10 <test_005_008_setup.lto_priv.208>
	...

08004e40 <test_005_005_setup.lto_priv.204>:
  tqp->next = (thread_t *)tqp;
 8004e40:	4b02      	ldr	r3, [pc, #8]	; (8004e4c <test_005_005_setup.lto_priv.204+0xc>)
 8004e42:	2200      	movs	r2, #0
 8004e44:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004e46:	605b      	str	r3, [r3, #4]
 8004e48:	609a      	str	r2, [r3, #8]
 8004e4a:	4770      	bx	lr
 8004e4c:	20000c50 	.word	0x20000c50

08004e50 <test_005_001_setup.lto_priv.199>:
 8004e50:	f7ff bff6 	b.w	8004e40 <test_005_005_setup.lto_priv.204>
	...

08004e60 <test_005_004_setup.lto_priv.201>:
  tqp->next = (thread_t *)tqp;
 8004e60:	4a04      	ldr	r2, [pc, #16]	; (8004e74 <test_005_004_setup.lto_priv.201+0x14>)
 8004e62:	4b05      	ldr	r3, [pc, #20]	; (8004e78 <test_005_004_setup.lto_priv.201+0x18>)
 8004e64:	6012      	str	r2, [r2, #0]
 8004e66:	2100      	movs	r1, #0
  tqp->prev = (thread_t *)tqp;
 8004e68:	6052      	str	r2, [r2, #4]
 8004e6a:	6091      	str	r1, [r2, #8]
 8004e6c:	6099      	str	r1, [r3, #8]
  tqp->next = (thread_t *)tqp;
 8004e6e:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004e70:	605b      	str	r3, [r3, #4]
 8004e72:	4770      	bx	lr
 8004e74:	20000c50 	.word	0x20000c50
 8004e78:	20000c24 	.word	0x20000c24
 8004e7c:	00000000 	.word	0x00000000

08004e80 <test_007_002_execute.lto_priv.215>:

static void test_007_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_002_execute(void) {
 8004e80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [7.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 8004e82:	4b10      	ldr	r3, [pc, #64]	; (8004ec4 <test_007_002_execute.lto_priv.215+0x44>)
 8004e84:	4f10      	ldr	r7, [pc, #64]	; (8004ec8 <test_007_002_execute.lto_priv.215+0x48>)
 8004e86:	2601      	movs	r6, #1
 8004e88:	601e      	str	r6, [r3, #0]
 8004e8a:	2507      	movs	r5, #7
 8004e8c:	2400      	movs	r4, #0

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8004e8e:	fa25 f304 	lsr.w	r3, r5, r4
 8004e92:	07db      	lsls	r3, r3, #31
 8004e94:	d511      	bpl.n	8004eba <test_007_002_execute.lto_priv.215+0x3a>
      chDbgAssert(handlers[eid] != NULL, "null handler");
 8004e96:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
 8004e9a:	b183      	cbz	r3, 8004ebe <test_007_002_execute.lto_priv.215+0x3e>
      events &= ~EVENT_MASK(eid);
 8004e9c:	fa06 f204 	lsl.w	r2, r6, r4
      handlers[eid](eid);
 8004ea0:	4620      	mov	r0, r4
      events &= ~EVENT_MASK(eid);
 8004ea2:	ea25 0502 	bic.w	r5, r5, r2
    }
    eid++;
 8004ea6:	3401      	adds	r4, #1
      handlers[eid](eid);
 8004ea8:	4798      	blx	r3
  while (events != (eventmask_t)0) {
 8004eaa:	2d00      	cmp	r5, #0
 8004eac:	d1ef      	bne.n	8004e8e <test_007_002_execute.lto_priv.215+0xe>
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 8004eae:	4907      	ldr	r1, [pc, #28]	; (8004ecc <test_007_002_execute.lto_priv.215+0x4c>)
 8004eb0:	4807      	ldr	r0, [pc, #28]	; (8004ed0 <test_007_002_execute.lto_priv.215+0x50>)
  }
}
 8004eb2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABC", "invalid sequence");
 8004eb6:	f004 bc63 	b.w	8009780 <_test_assert_sequence>
    eid++;
 8004eba:	3401      	adds	r4, #1
 8004ebc:	e7e7      	b.n	8004e8e <test_007_002_execute.lto_priv.215+0xe>
      chDbgAssert(handlers[eid] != NULL, "null handler");
 8004ebe:	4805      	ldr	r0, [pc, #20]	; (8004ed4 <test_007_002_execute.lto_priv.215+0x54>)
 8004ec0:	f7fb fcae 	bl	8000820 <chSysHalt>
 8004ec4:	20001df8 	.word	0x20001df8
 8004ec8:	0800ade4 	.word	0x0800ade4
 8004ecc:	0800a9e8 	.word	0x0800a9e8
 8004ed0:	0800ae4c 	.word	0x0800ae4c
 8004ed4:	0800add4 	.word	0x0800add4
	...

08004ee0 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8004ee0:	2043      	movs	r0, #67	; 0x43
 8004ee2:	f004 bd9d 	b.w	8009a20 <test_emit_token>
 8004ee6:	bf00      	nop
	...

08004ef0 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8004ef0:	2042      	movs	r0, #66	; 0x42
 8004ef2:	f004 bd95 	b.w	8009a20 <test_emit_token>
 8004ef6:	bf00      	nop
	...

08004f00 <h1>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8004f00:	2041      	movs	r0, #65	; 0x41
 8004f02:	f004 bd8d 	b.w	8009a20 <test_emit_token>
 8004f06:	bf00      	nop
	...

08004f10 <test_005_004_teardown.lto_priv.202>:
 8004f10:	f003 bd46 	b.w	80089a0 <test_wait_threads>
	...

08004f20 <test_006_001_execute.lto_priv.212>:
 * - [6.1.1] Starting the messenger thread.
 * - [6.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void test_006_001_execute(void) {
 8004f20:	b538      	push	{r3, r4, r5, lr}
  return ch.rlist.current;
 8004f22:	4b15      	ldr	r3, [pc, #84]	; (8004f78 <test_006_001_execute.lto_priv.212+0x58>)
  thread_t *tp;
  msg_t msg;

  /* [6.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8004f24:	4c15      	ldr	r4, [pc, #84]	; (8004f7c <test_006_001_execute.lto_priv.212+0x5c>)
 8004f26:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004f28:	4a15      	ldr	r2, [pc, #84]	; (8004f80 <test_006_001_execute.lto_priv.212+0x60>)
 8004f2a:	6899      	ldr	r1, [r3, #8]
 8004f2c:	4815      	ldr	r0, [pc, #84]	; (8004f84 <test_006_001_execute.lto_priv.212+0x64>)
 8004f2e:	3101      	adds	r1, #1
  test_set_step(1);
 8004f30:	2501      	movs	r5, #1
 8004f32:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004f34:	f005 f81c 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8004f38:	4a13      	ldr	r2, [pc, #76]	; (8004f88 <test_006_001_execute.lto_priv.212+0x68>)
                                   msg_thread1, chThdGetSelfX());
  }

  /* [6.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8004f3a:	2302      	movs	r3, #2
 8004f3c:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004f3e:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 8004f40:	2404      	movs	r4, #4
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
 8004f42:	f7fc fa15 	bl	8001370 <chMsgWait>
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
 8004f46:	f890 2020 	ldrb.w	r2, [r0, #32]
 8004f4a:	2a0d      	cmp	r2, #13
 8004f4c:	d002      	beq.n	8004f54 <test_006_001_execute.lto_priv.212+0x34>
 8004f4e:	480f      	ldr	r0, [pc, #60]	; (8004f8c <test_006_001_execute.lto_priv.212+0x6c>)
 8004f50:	f7fb fc66 	bl	8000820 <chSysHalt>
  return tp->u.sentmsg;
 8004f54:	6a45      	ldr	r5, [r0, #36]	; 0x24
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
 8004f56:	4629      	mov	r1, r5
 8004f58:	f7fc f9da 	bl	8001310 <chMsgRelease>
      test_emit_token(msg);
 8004f5c:	b2e8      	uxtb	r0, r5
 8004f5e:	f004 fd5f 	bl	8009a20 <test_emit_token>
    for (i = 0; i < 4; i++) {
 8004f62:	3c01      	subs	r4, #1
 8004f64:	d1ed      	bne.n	8004f42 <test_006_001_execute.lto_priv.212+0x22>
    }
    test_wait_threads();
 8004f66:	f003 fd1b 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8004f6a:	4909      	ldr	r1, [pc, #36]	; (8004f90 <test_006_001_execute.lto_priv.212+0x70>)
 8004f6c:	4809      	ldr	r0, [pc, #36]	; (8004f94 <test_006_001_execute.lto_priv.212+0x74>)
  }
}
 8004f6e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_sequence("ABCD", "invalid sequence");
 8004f72:	f004 bc05 	b.w	8009780 <_test_assert_sequence>
 8004f76:	bf00      	nop
 8004f78:	20001e68 	.word	0x20001e68
 8004f7c:	20001df8 	.word	0x20001df8
 8004f80:	08004fa1 	.word	0x08004fa1
 8004f84:	20001710 	.word	0x20001710
 8004f88:	20001d98 	.word	0x20001d98
 8004f8c:	0800ada8 	.word	0x0800ada8
 8004f90:	0800a9e8 	.word	0x0800a9e8
 8004f94:	0800abe4 	.word	0x0800abe4
	...

08004fa0 <msg_thread1>:
static THD_FUNCTION(msg_thread1, p) {
 8004fa0:	b510      	push	{r4, lr}
  chMsgSend(p, 'A');
 8004fa2:	2141      	movs	r1, #65	; 0x41
static THD_FUNCTION(msg_thread1, p) {
 8004fa4:	4604      	mov	r4, r0
  chMsgSend(p, 'A');
 8004fa6:	f7fc fa1b 	bl	80013e0 <chMsgSend>
  chMsgSend(p, 'B');
 8004faa:	4620      	mov	r0, r4
 8004fac:	2142      	movs	r1, #66	; 0x42
 8004fae:	f7fc fa17 	bl	80013e0 <chMsgSend>
  chMsgSend(p, 'C');
 8004fb2:	4620      	mov	r0, r4
 8004fb4:	2143      	movs	r1, #67	; 0x43
 8004fb6:	f7fc fa13 	bl	80013e0 <chMsgSend>
  chMsgSend(p, 'D');
 8004fba:	4620      	mov	r0, r4
 8004fbc:	2144      	movs	r1, #68	; 0x44
}
 8004fbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMsgSend(p, 'D');
 8004fc2:	f7fc ba0d 	b.w	80013e0 <chMsgSend>
 8004fc6:	bf00      	nop
	...

08004fd0 <test_005_009_execute.lto_priv.211>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void test_005_009_execute(void) {
 8004fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004fd2:	4b1c      	ldr	r3, [pc, #112]	; (8005044 <test_005_009_execute.lto_priv.211+0x74>)

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8004fd4:	4e1c      	ldr	r6, [pc, #112]	; (8005048 <test_005_009_execute.lto_priv.211+0x78>)
  return chThdGetSelfX()->prio;
 8004fd6:	699b      	ldr	r3, [r3, #24]
  test_set_step(2);
 8004fd8:	4c1c      	ldr	r4, [pc, #112]	; (800504c <test_005_009_execute.lto_priv.211+0x7c>)
 8004fda:	689f      	ldr	r7, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8004fdc:	4a1c      	ldr	r2, [pc, #112]	; (8005050 <test_005_009_execute.lto_priv.211+0x80>)
 8004fde:	4b1d      	ldr	r3, [pc, #116]	; (8005054 <test_005_009_execute.lto_priv.211+0x84>)
 8004fe0:	4d1d      	ldr	r5, [pc, #116]	; (8005058 <test_005_009_execute.lto_priv.211+0x88>)
 8004fe2:	1c79      	adds	r1, r7, #1
  test_set_step(2);
 8004fe4:	f04f 0e02 	mov.w	lr, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8004fe8:	4630      	mov	r0, r6
  test_set_step(2);
 8004fea:	f8c4 e000 	str.w	lr, [r4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8004fee:	f004 ffbf 	bl	8009f70 <chThdCreateStatic.constprop.72>
  }

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8004ff2:	f04f 0e03 	mov.w	lr, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8004ff6:	6028      	str	r0, [r5, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8004ff8:	1cb9      	adds	r1, r7, #2
 8004ffa:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 8004ffe:	4b17      	ldr	r3, [pc, #92]	; (800505c <test_005_009_execute.lto_priv.211+0x8c>)
 8005000:	4a17      	ldr	r2, [pc, #92]	; (8005060 <test_005_009_execute.lto_priv.211+0x90>)
  test_set_step(3);
 8005002:	f8c4 e000 	str.w	lr, [r4]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8005006:	f004 ffb3 	bl	8009f70 <chThdCreateStatic.constprop.72>

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 800500a:	1cf9      	adds	r1, r7, #3
 800500c:	4a15      	ldr	r2, [pc, #84]	; (8005064 <test_005_009_execute.lto_priv.211+0x94>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 800500e:	6068      	str	r0, [r5, #4]
  test_set_step(4);
 8005010:	2704      	movs	r7, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8005012:	f506 7024 	add.w	r0, r6, #656	; 0x290
 8005016:	4b14      	ldr	r3, [pc, #80]	; (8005068 <test_005_009_execute.lto_priv.211+0x98>)
  test_set_step(4);
 8005018:	6027      	str	r7, [r4, #0]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 800501a:	f004 ffa9 	bl	8009f70 <chThdCreateStatic.constprop.72>
  }

  /* [5.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 800501e:	2305      	movs	r3, #5
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8005020:	60a8      	str	r0, [r5, #8]
  test_set_step(5);
 8005022:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8005024:	f005 f8a4 	bl	800a170 <chCondSignal.constprop.60>
  }

  /* [5.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 8005028:	2306      	movs	r3, #6
 800502a:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 800502c:	f005 f8a0 	bl	800a170 <chCondSignal.constprop.60>
  }

  /* [5.9.7] Checking the order of operations.*/
  test_set_step(7);
 8005030:	2307      	movs	r3, #7
 8005032:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 8005034:	f003 fcb4 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 8005038:	490c      	ldr	r1, [pc, #48]	; (800506c <test_005_009_execute.lto_priv.211+0x9c>)
 800503a:	480d      	ldr	r0, [pc, #52]	; (8005070 <test_005_009_execute.lto_priv.211+0xa0>)
  }
}
 800503c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABC", "invalid sequence");
 8005040:	f004 bb9e 	b.w	8009780 <_test_assert_sequence>
 8005044:	20001e68 	.word	0x20001e68
 8005048:	20001710 	.word	0x20001710
 800504c:	20001df8 	.word	0x20001df8
 8005050:	080058f1 	.word	0x080058f1
 8005054:	0800a9dc 	.word	0x0800a9dc
 8005058:	20001d98 	.word	0x20001d98
 800505c:	0800a9e4 	.word	0x0800a9e4
 8005060:	08002ab1 	.word	0x08002ab1
 8005064:	08005081 	.word	0x08005081
 8005068:	0800a9e0 	.word	0x0800a9e0
 800506c:	0800a9e8 	.word	0x0800a9e8
 8005070:	0800ae4c 	.word	0x0800ae4c
	...

08005080 <thread9>:
static THD_FUNCTION(thread9, p) {
 8005080:	b538      	push	{r3, r4, r5, lr}
  chMtxLock(&m2);
 8005082:	4c06      	ldr	r4, [pc, #24]	; (800509c <thread9+0x1c>)
static THD_FUNCTION(thread9, p) {
 8005084:	4605      	mov	r5, r0
  chMtxLock(&m2);
 8005086:	4620      	mov	r0, r4
 8005088:	f7fc faa2 	bl	80015d0 <chMtxLock>
  test_emit_token(*(char *)p);
 800508c:	7828      	ldrb	r0, [r5, #0]
 800508e:	f004 fcc7 	bl	8009a20 <test_emit_token>
  chMtxUnlock(&m2);
 8005092:	4620      	mov	r0, r4
}
 8005094:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m2);
 8005098:	f7fc ba3a 	b.w	8001510 <chMtxUnlock>
 800509c:	20000c24 	.word	0x20000c24

080050a0 <test_005_004_execute.lto_priv.203>:
static void test_005_004_execute(void) {
 80050a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return ch.rlist.current;
 80050a4:	4d40      	ldr	r5, [pc, #256]	; (80051a8 <test_005_004_execute.lto_priv.203+0x108>)
  test_set_step(2);
 80050a6:	4e41      	ldr	r6, [pc, #260]	; (80051ac <test_005_004_execute.lto_priv.203+0x10c>)
  return chThdGetSelfX()->prio;
 80050a8:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80050aa:	4b41      	ldr	r3, [pc, #260]	; (80051b0 <test_005_004_execute.lto_priv.203+0x110>)
 80050ac:	6894      	ldr	r4, [r2, #8]
 80050ae:	4841      	ldr	r0, [pc, #260]	; (80051b4 <test_005_004_execute.lto_priv.203+0x114>)
 80050b0:	4a41      	ldr	r2, [pc, #260]	; (80051b8 <test_005_004_execute.lto_priv.203+0x118>)
 80050b2:	4f42      	ldr	r7, [pc, #264]	; (80051bc <test_005_004_execute.lto_priv.203+0x11c>)
    pa = p + 1;
 80050b4:	f104 0801 	add.w	r8, r4, #1
  test_set_step(2);
 80050b8:	f04f 0e02 	mov.w	lr, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80050bc:	4641      	mov	r1, r8
  test_set_step(2);
 80050be:	f8c6 e000 	str.w	lr, [r6]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80050c2:	f004 ff55 	bl	8009f70 <chThdCreateStatic.constprop.72>
    pb = p + 2;
 80050c6:	f104 0902 	add.w	r9, r4, #2
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 80050ca:	4649      	mov	r1, r9
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80050cc:	6038      	str	r0, [r7, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 80050ce:	4b3c      	ldr	r3, [pc, #240]	; (80051c0 <test_005_004_execute.lto_priv.203+0x120>)
 80050d0:	4a3c      	ldr	r2, [pc, #240]	; (80051c4 <test_005_004_execute.lto_priv.203+0x124>)
 80050d2:	483d      	ldr	r0, [pc, #244]	; (80051c8 <test_005_004_execute.lto_priv.203+0x128>)
 80050d4:	f004 ff4c 	bl	8009f70 <chThdCreateStatic.constprop.72>
  test_set_step(3);
 80050d8:	2303      	movs	r3, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 80050da:	6078      	str	r0, [r7, #4]
    chMtxLock(&m1);
 80050dc:	483b      	ldr	r0, [pc, #236]	; (80051cc <test_005_004_execute.lto_priv.203+0x12c>)
  test_set_step(3);
 80050de:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
 80050e0:	f7fc fa76 	bl	80015d0 <chMtxLock>
 80050e4:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 80050e6:	493a      	ldr	r1, [pc, #232]	; (80051d0 <test_005_004_execute.lto_priv.203+0x130>)
 80050e8:	6898      	ldr	r0, [r3, #8]
 80050ea:	1b00      	subs	r0, r0, r4
 80050ec:	fab0 f080 	clz	r0, r0
 80050f0:	0940      	lsrs	r0, r0, #5
 80050f2:	f004 fb6d 	bl	80097d0 <_test_assert>
 80050f6:	b108      	cbz	r0, 80050fc <test_005_004_execute.lto_priv.203+0x5c>
 80050f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  test_set_step(4);
 80050fc:	2304      	movs	r3, #4
    chThdSleepMilliseconds(100);
 80050fe:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(4);
 8005102:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
 8005104:	f7fc fb8c 	bl	8001820 <chThdSleep>
 8005108:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 800510a:	4931      	ldr	r1, [pc, #196]	; (80051d0 <test_005_004_execute.lto_priv.203+0x130>)
 800510c:	6898      	ldr	r0, [r3, #8]
 800510e:	eba0 0008 	sub.w	r0, r0, r8
 8005112:	fab0 f080 	clz	r0, r0
 8005116:	0940      	lsrs	r0, r0, #5
 8005118:	f004 fb5a 	bl	80097d0 <_test_assert>
 800511c:	2800      	cmp	r0, #0
 800511e:	d1eb      	bne.n	80050f8 <test_005_004_execute.lto_priv.203+0x58>
  test_set_step(5);
 8005120:	2305      	movs	r3, #5
    chMtxLock(&m2);
 8005122:	482c      	ldr	r0, [pc, #176]	; (80051d4 <test_005_004_execute.lto_priv.203+0x134>)
  test_set_step(5);
 8005124:	6033      	str	r3, [r6, #0]
    chMtxLock(&m2);
 8005126:	f7fc fa53 	bl	80015d0 <chMtxLock>
 800512a:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 800512c:	4928      	ldr	r1, [pc, #160]	; (80051d0 <test_005_004_execute.lto_priv.203+0x130>)
 800512e:	6898      	ldr	r0, [r3, #8]
 8005130:	eba0 0008 	sub.w	r0, r0, r8
 8005134:	fab0 f080 	clz	r0, r0
 8005138:	0940      	lsrs	r0, r0, #5
 800513a:	f004 fb49 	bl	80097d0 <_test_assert>
 800513e:	2800      	cmp	r0, #0
 8005140:	d1da      	bne.n	80050f8 <test_005_004_execute.lto_priv.203+0x58>
  test_set_step(6);
 8005142:	2306      	movs	r3, #6
    chThdSleepMilliseconds(100);
 8005144:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(6);
 8005148:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
 800514a:	f7fc fb69 	bl	8001820 <chThdSleep>
 800514e:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8005150:	491f      	ldr	r1, [pc, #124]	; (80051d0 <test_005_004_execute.lto_priv.203+0x130>)
 8005152:	6898      	ldr	r0, [r3, #8]
 8005154:	eba0 0009 	sub.w	r0, r0, r9
 8005158:	fab0 f080 	clz	r0, r0
 800515c:	0940      	lsrs	r0, r0, #5
 800515e:	f004 fb37 	bl	80097d0 <_test_assert>
 8005162:	2800      	cmp	r0, #0
 8005164:	d1c8      	bne.n	80050f8 <test_005_004_execute.lto_priv.203+0x58>
  test_set_step(7);
 8005166:	2307      	movs	r3, #7
    chMtxUnlock(&m2);
 8005168:	481a      	ldr	r0, [pc, #104]	; (80051d4 <test_005_004_execute.lto_priv.203+0x134>)
  test_set_step(7);
 800516a:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m2);
 800516c:	f7fc f9d0 	bl	8001510 <chMtxUnlock>
 8005170:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8005172:	4917      	ldr	r1, [pc, #92]	; (80051d0 <test_005_004_execute.lto_priv.203+0x130>)
 8005174:	6898      	ldr	r0, [r3, #8]
 8005176:	eba0 0008 	sub.w	r0, r0, r8
 800517a:	fab0 f080 	clz	r0, r0
 800517e:	0940      	lsrs	r0, r0, #5
 8005180:	f004 fb26 	bl	80097d0 <_test_assert>
 8005184:	2800      	cmp	r0, #0
 8005186:	d1b7      	bne.n	80050f8 <test_005_004_execute.lto_priv.203+0x58>
  test_set_step(8);
 8005188:	2308      	movs	r3, #8
    chMtxUnlock(&m1);
 800518a:	4810      	ldr	r0, [pc, #64]	; (80051cc <test_005_004_execute.lto_priv.203+0x12c>)
  test_set_step(8);
 800518c:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m1);
 800518e:	f7fc f9bf 	bl	8001510 <chMtxUnlock>
 8005192:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8005194:	490e      	ldr	r1, [pc, #56]	; (80051d0 <test_005_004_execute.lto_priv.203+0x130>)
 8005196:	6898      	ldr	r0, [r3, #8]
 8005198:	1b00      	subs	r0, r0, r4
 800519a:	fab0 f080 	clz	r0, r0
 800519e:	0940      	lsrs	r0, r0, #5
}
 80051a0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 80051a4:	f004 bb14 	b.w	80097d0 <_test_assert>
 80051a8:	20001e68 	.word	0x20001e68
 80051ac:	20001df8 	.word	0x20001df8
 80051b0:	0800a9dc 	.word	0x0800a9dc
 80051b4:	20001710 	.word	0x20001710
 80051b8:	080028d1 	.word	0x080028d1
 80051bc:	20001d98 	.word	0x20001d98
 80051c0:	0800a9e0 	.word	0x0800a9e0
 80051c4:	08002b51 	.word	0x08002b51
 80051c8:	20001858 	.word	0x20001858
 80051cc:	20000c50 	.word	0x20000c50
 80051d0:	0800adf0 	.word	0x0800adf0
 80051d4:	20000c24 	.word	0x20000c24
	...

080051e0 <test_005_001_execute.lto_priv.200>:
static void test_005_001_execute(void) {
 80051e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 80051e2:	4f24      	ldr	r7, [pc, #144]	; (8005274 <test_005_001_execute.lto_priv.200+0x94>)
  test_set_step(2);
 80051e4:	4e24      	ldr	r6, [pc, #144]	; (8005278 <test_005_001_execute.lto_priv.200+0x98>)
  return chThdGetSelfX()->prio;
 80051e6:	69bb      	ldr	r3, [r7, #24]
    chMtxLock(&m1);
 80051e8:	4824      	ldr	r0, [pc, #144]	; (800527c <test_005_001_execute.lto_priv.200+0x9c>)
 80051ea:	689c      	ldr	r4, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80051ec:	4d24      	ldr	r5, [pc, #144]	; (8005280 <test_005_001_execute.lto_priv.200+0xa0>)
  test_set_step(2);
 80051ee:	2302      	movs	r3, #2
 80051f0:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
 80051f2:	f7fc f9ed 	bl	80015d0 <chMtxLock>
  test_set_step(3);
 80051f6:	f04f 0e03 	mov.w	lr, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80051fa:	1c61      	adds	r1, r4, #1
 80051fc:	4b21      	ldr	r3, [pc, #132]	; (8005284 <test_005_001_execute.lto_priv.200+0xa4>)
 80051fe:	4a22      	ldr	r2, [pc, #136]	; (8005288 <test_005_001_execute.lto_priv.200+0xa8>)
 8005200:	4822      	ldr	r0, [pc, #136]	; (800528c <test_005_001_execute.lto_priv.200+0xac>)
  test_set_step(3);
 8005202:	f8c6 e000 	str.w	lr, [r6]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8005206:	f004 feb3 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800520a:	1ca1      	adds	r1, r4, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800520c:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800520e:	4b20      	ldr	r3, [pc, #128]	; (8005290 <test_005_001_execute.lto_priv.200+0xb0>)
 8005210:	4a1d      	ldr	r2, [pc, #116]	; (8005288 <test_005_001_execute.lto_priv.200+0xa8>)
 8005212:	4820      	ldr	r0, [pc, #128]	; (8005294 <test_005_001_execute.lto_priv.200+0xb4>)
 8005214:	f004 feac 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8005218:	1ce1      	adds	r1, r4, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800521a:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800521c:	4b1e      	ldr	r3, [pc, #120]	; (8005298 <test_005_001_execute.lto_priv.200+0xb8>)
 800521e:	4a1a      	ldr	r2, [pc, #104]	; (8005288 <test_005_001_execute.lto_priv.200+0xa8>)
 8005220:	481e      	ldr	r0, [pc, #120]	; (800529c <test_005_001_execute.lto_priv.200+0xbc>)
 8005222:	f004 fea5 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8005226:	1d21      	adds	r1, r4, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8005228:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800522a:	4b1d      	ldr	r3, [pc, #116]	; (80052a0 <test_005_001_execute.lto_priv.200+0xc0>)
 800522c:	4a16      	ldr	r2, [pc, #88]	; (8005288 <test_005_001_execute.lto_priv.200+0xa8>)
 800522e:	481d      	ldr	r0, [pc, #116]	; (80052a4 <test_005_001_execute.lto_priv.200+0xc4>)
 8005230:	f004 fe9e 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8005234:	1d61      	adds	r1, r4, #5
 8005236:	4a14      	ldr	r2, [pc, #80]	; (8005288 <test_005_001_execute.lto_priv.200+0xa8>)
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8005238:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800523a:	4b1b      	ldr	r3, [pc, #108]	; (80052a8 <test_005_001_execute.lto_priv.200+0xc8>)
 800523c:	481b      	ldr	r0, [pc, #108]	; (80052ac <test_005_001_execute.lto_priv.200+0xcc>)
 800523e:	f004 fe97 	bl	8009f70 <chThdCreateStatic.constprop.72>
  test_set_step(4);
 8005242:	2304      	movs	r3, #4
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8005244:	6128      	str	r0, [r5, #16]
    chMtxUnlock(&m1);
 8005246:	480d      	ldr	r0, [pc, #52]	; (800527c <test_005_001_execute.lto_priv.200+0x9c>)
  test_set_step(4);
 8005248:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m1);
 800524a:	f7fc f961 	bl	8001510 <chMtxUnlock>
    test_wait_threads();
 800524e:	f003 fba7 	bl	80089a0 <test_wait_threads>
 8005252:	69bb      	ldr	r3, [r7, #24]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 8005254:	4916      	ldr	r1, [pc, #88]	; (80052b0 <test_005_001_execute.lto_priv.200+0xd0>)
 8005256:	6898      	ldr	r0, [r3, #8]
 8005258:	1b00      	subs	r0, r0, r4
 800525a:	fab0 f080 	clz	r0, r0
 800525e:	0940      	lsrs	r0, r0, #5
 8005260:	f004 fab6 	bl	80097d0 <_test_assert>
 8005264:	b100      	cbz	r0, 8005268 <test_005_001_execute.lto_priv.200+0x88>
 8005266:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
 8005268:	4912      	ldr	r1, [pc, #72]	; (80052b4 <test_005_001_execute.lto_priv.200+0xd4>)
 800526a:	4813      	ldr	r0, [pc, #76]	; (80052b8 <test_005_001_execute.lto_priv.200+0xd8>)
}
 800526c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8005270:	f004 ba86 	b.w	8009780 <_test_assert_sequence>
 8005274:	20001e68 	.word	0x20001e68
 8005278:	20001df8 	.word	0x20001df8
 800527c:	20000c50 	.word	0x20000c50
 8005280:	20001d98 	.word	0x20001d98
 8005284:	0800aa00 	.word	0x0800aa00
 8005288:	08002861 	.word	0x08002861
 800528c:	20001710 	.word	0x20001710
 8005290:	0800b314 	.word	0x0800b314
 8005294:	20001858 	.word	0x20001858
 8005298:	0800a9e4 	.word	0x0800a9e4
 800529c:	200019a0 	.word	0x200019a0
 80052a0:	0800a9e0 	.word	0x0800a9e0
 80052a4:	20001ae8 	.word	0x20001ae8
 80052a8:	0800a9dc 	.word	0x0800a9dc
 80052ac:	20001c30 	.word	0x20001c30
 80052b0:	0800adf0 	.word	0x0800adf0
 80052b4:	0800a9e8 	.word	0x0800a9e8
 80052b8:	0800a9fc 	.word	0x0800a9fc
 80052bc:	00000000 	.word	0x00000000

080052c0 <test_007_001_execute.lto_priv.213>:
static void test_007_001_execute(void) {
 80052c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80052c4:	4d58      	ldr	r5, [pc, #352]	; (8005428 <test_007_001_execute.lto_priv.213+0x168>)
  test_set_step(2);
 80052c6:	f8df 8178 	ldr.w	r8, [pc, #376]	; 8005440 <test_007_001_execute.lto_priv.213+0x180>
 80052ca:	602d      	str	r5, [r5, #0]
 80052cc:	2302      	movs	r3, #2
 80052ce:	f8c8 3000 	str.w	r3, [r8]
static void test_007_001_execute(void) {
 80052d2:	b08b      	sub	sp, #44	; 0x2c
 80052d4:	2320      	movs	r3, #32
 80052d6:	f383 8811 	msr	BASEPRI, r3
  elp->listener = currp;
 80052da:	4c54      	ldr	r4, [pc, #336]	; (800542c <test_007_001_execute.lto_priv.213+0x16c>)
  elp->next     = esp->next;
 80052dc:	ae0a      	add	r6, sp, #40	; 0x28
  _dbg_check_lock();
 80052de:	f7fb ffbf 	bl	8001260 <_dbg_check_lock>
 80052e2:	682b      	ldr	r3, [r5, #0]
 80052e4:	f846 3d14 	str.w	r3, [r6, #-20]!
  elp->listener = currp;
 80052e8:	69a3      	ldr	r3, [r4, #24]
 80052ea:	9306      	str	r3, [sp, #24]
  elp->events   = events;
 80052ec:	2101      	movs	r1, #1
  elp->wflags   = wflags;
 80052ee:	f04f 33ff 	mov.w	r3, #4294967295
  elp->flags    = (eventflags_t)0;
 80052f2:	2200      	movs	r2, #0
  elp->wflags   = wflags;
 80052f4:	9309      	str	r3, [sp, #36]	; 0x24
  elp->events   = events;
 80052f6:	9107      	str	r1, [sp, #28]
  elp->flags    = (eventflags_t)0;
 80052f8:	9208      	str	r2, [sp, #32]
  esp->next     = elp;
 80052fa:	602e      	str	r6, [r5, #0]
  _dbg_check_unlock();
 80052fc:	f7fb ff88 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005300:	6823      	ldr	r3, [r4, #0]
 8005302:	42a3      	cmp	r3, r4
 8005304:	d005      	beq.n	8005312 <test_007_001_execute.lto_priv.213+0x52>
 8005306:	69a2      	ldr	r2, [r4, #24]
 8005308:	689b      	ldr	r3, [r3, #8]
 800530a:	6892      	ldr	r2, [r2, #8]
 800530c:	429a      	cmp	r2, r3
 800530e:	f0c0 8084 	bcc.w	800541a <test_007_001_execute.lto_priv.213+0x15a>
 8005312:	f04f 0900 	mov.w	r9, #0
 8005316:	f389 8811 	msr	BASEPRI, r9
 800531a:	2320      	movs	r3, #32
 800531c:	f383 8811 	msr	BASEPRI, r3
  elp->next     = esp->next;
 8005320:	af0a      	add	r7, sp, #40	; 0x28
  _dbg_check_lock();
 8005322:	f7fb ff9d 	bl	8001260 <_dbg_check_lock>
 8005326:	682b      	ldr	r3, [r5, #0]
 8005328:	f847 3d28 	str.w	r3, [r7, #-40]!
  elp->listener = currp;
 800532c:	69a2      	ldr	r2, [r4, #24]
  elp->flags    = (eventflags_t)0;
 800532e:	f8cd 900c 	str.w	r9, [sp, #12]
  elp->wflags   = wflags;
 8005332:	f04f 33ff 	mov.w	r3, #4294967295
  elp->events   = events;
 8005336:	2102      	movs	r1, #2
  elp->wflags   = wflags;
 8005338:	9304      	str	r3, [sp, #16]
  elp->listener = currp;
 800533a:	9201      	str	r2, [sp, #4]
  elp->events   = events;
 800533c:	9102      	str	r1, [sp, #8]
  esp->next     = elp;
 800533e:	602f      	str	r7, [r5, #0]
  _dbg_check_unlock();
 8005340:	f7fb ff66 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005344:	6823      	ldr	r3, [r4, #0]
 8005346:	42a3      	cmp	r3, r4
 8005348:	d004      	beq.n	8005354 <test_007_001_execute.lto_priv.213+0x94>
 800534a:	69a2      	ldr	r2, [r4, #24]
 800534c:	689b      	ldr	r3, [r3, #8]
 800534e:	6892      	ldr	r2, [r2, #8]
 8005350:	429a      	cmp	r2, r3
 8005352:	d362      	bcc.n	800541a <test_007_001_execute.lto_priv.213+0x15a>
 8005354:	2300      	movs	r3, #0
 8005356:	f383 8811 	msr	BASEPRI, r3
 800535a:	2320      	movs	r3, #32
 800535c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005360:	f7fb ff7e 	bl	8001260 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->next);
 8005364:	6828      	ldr	r0, [r5, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8005366:	4932      	ldr	r1, [pc, #200]	; (8005430 <test_007_001_execute.lto_priv.213+0x170>)
 8005368:	1b40      	subs	r0, r0, r5
 800536a:	bf18      	it	ne
 800536c:	2001      	movne	r0, #1
 800536e:	f004 fa2f 	bl	80097d0 <_test_assert>
 8005372:	2800      	cmp	r0, #0
 8005374:	d141      	bne.n	80053fa <test_007_001_execute.lto_priv.213+0x13a>
  _dbg_check_unlock();
 8005376:	f7fb ff4b 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800537a:	6823      	ldr	r3, [r4, #0]
 800537c:	42a3      	cmp	r3, r4
 800537e:	d004      	beq.n	800538a <test_007_001_execute.lto_priv.213+0xca>
 8005380:	69a2      	ldr	r2, [r4, #24]
 8005382:	689b      	ldr	r3, [r3, #8]
 8005384:	6892      	ldr	r2, [r2, #8]
 8005386:	429a      	cmp	r2, r3
 8005388:	d34a      	bcc.n	8005420 <test_007_001_execute.lto_priv.213+0x160>
 800538a:	2300      	movs	r3, #0
 800538c:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 8005390:	2303      	movs	r3, #3
    chEvtUnregister(&es1, &el1);
 8005392:	4631      	mov	r1, r6
 8005394:	4824      	ldr	r0, [pc, #144]	; (8005428 <test_007_001_execute.lto_priv.213+0x168>)
  test_set_step(3);
 8005396:	f8c8 3000 	str.w	r3, [r8]
    chEvtUnregister(&es1, &el1);
 800539a:	f7fc f889 	bl	80014b0 <chEvtUnregister>
 800539e:	2320      	movs	r3, #32
 80053a0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80053a4:	f7fb ff5c 	bl	8001260 <_dbg_check_lock>
 80053a8:	6828      	ldr	r0, [r5, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 80053aa:	4921      	ldr	r1, [pc, #132]	; (8005430 <test_007_001_execute.lto_priv.213+0x170>)
 80053ac:	1b40      	subs	r0, r0, r5
 80053ae:	bf18      	it	ne
 80053b0:	2001      	movne	r0, #1
 80053b2:	f004 fa0d 	bl	80097d0 <_test_assert>
 80053b6:	bb00      	cbnz	r0, 80053fa <test_007_001_execute.lto_priv.213+0x13a>
  _dbg_check_unlock();
 80053b8:	f7fb ff2a 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80053bc:	6823      	ldr	r3, [r4, #0]
 80053be:	42a3      	cmp	r3, r4
 80053c0:	d004      	beq.n	80053cc <test_007_001_execute.lto_priv.213+0x10c>
 80053c2:	69a2      	ldr	r2, [r4, #24]
 80053c4:	689b      	ldr	r3, [r3, #8]
 80053c6:	6892      	ldr	r2, [r2, #8]
 80053c8:	429a      	cmp	r2, r3
 80053ca:	d329      	bcc.n	8005420 <test_007_001_execute.lto_priv.213+0x160>
 80053cc:	2300      	movs	r3, #0
 80053ce:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
 80053d2:	2304      	movs	r3, #4
    chEvtUnregister(&es1, &el2);
 80053d4:	4639      	mov	r1, r7
 80053d6:	4814      	ldr	r0, [pc, #80]	; (8005428 <test_007_001_execute.lto_priv.213+0x168>)
  test_set_step(4);
 80053d8:	f8c8 3000 	str.w	r3, [r8]
    chEvtUnregister(&es1, &el2);
 80053dc:	f7fc f868 	bl	80014b0 <chEvtUnregister>
 80053e0:	2320      	movs	r3, #32
 80053e2:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80053e6:	f7fb ff3b 	bl	8001260 <_dbg_check_lock>
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 80053ea:	6828      	ldr	r0, [r5, #0]
 80053ec:	4911      	ldr	r1, [pc, #68]	; (8005434 <test_007_001_execute.lto_priv.213+0x174>)
 80053ee:	1b40      	subs	r0, r0, r5
 80053f0:	fab0 f080 	clz	r0, r0
 80053f4:	0940      	lsrs	r0, r0, #5
 80053f6:	f004 f9eb 	bl	80097d0 <_test_assert>
  _dbg_check_unlock();
 80053fa:	f7fb ff09 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80053fe:	6823      	ldr	r3, [r4, #0]
 8005400:	42a3      	cmp	r3, r4
 8005402:	d004      	beq.n	800540e <test_007_001_execute.lto_priv.213+0x14e>
 8005404:	69a2      	ldr	r2, [r4, #24]
 8005406:	689b      	ldr	r3, [r3, #8]
 8005408:	6892      	ldr	r2, [r2, #8]
 800540a:	429a      	cmp	r2, r3
 800540c:	d308      	bcc.n	8005420 <test_007_001_execute.lto_priv.213+0x160>
 800540e:	2300      	movs	r3, #0
 8005410:	f383 8811 	msr	BASEPRI, r3
}
 8005414:	b00b      	add	sp, #44	; 0x2c
 8005416:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800541a:	4807      	ldr	r0, [pc, #28]	; (8005438 <test_007_001_execute.lto_priv.213+0x178>)
 800541c:	f7fb fa00 	bl	8000820 <chSysHalt>
 8005420:	4806      	ldr	r0, [pc, #24]	; (800543c <test_007_001_execute.lto_priv.213+0x17c>)
 8005422:	f7fb f9fd 	bl	8000820 <chSysHalt>
 8005426:	bf00      	nop
 8005428:	20000c34 	.word	0x20000c34
 800542c:	20001e68 	.word	0x20001e68
 8005430:	0800ae30 	.word	0x0800ae30
 8005434:	0800ae3c 	.word	0x0800ae3c
 8005438:	0800c538 	.word	0x0800c538
 800543c:	0800ad9c 	.word	0x0800ad9c
 8005440:	20001df8 	.word	0x20001df8
	...

08005450 <evt_thread7.lto_priv.138>:
static THD_FUNCTION(evt_thread7, p) {
 8005450:	b538      	push	{r3, r4, r5, lr}
 8005452:	2320      	movs	r3, #32
 8005454:	f383 8811 	msr	BASEPRI, r3
 8005458:	4c1a      	ldr	r4, [pc, #104]	; (80054c4 <evt_thread7.lto_priv.138+0x74>)
  _dbg_check_lock();
 800545a:	f7fb ff01 	bl	8001260 <_dbg_check_lock>
  chEvtBroadcastFlagsI(esp, flags);
 800545e:	2100      	movs	r1, #0
 8005460:	4819      	ldr	r0, [pc, #100]	; (80054c8 <evt_thread7.lto_priv.138+0x78>)
 8005462:	f7fb fb45 	bl	8000af0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 8005466:	f7fb fadb 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 800546a:	f7fb fed1 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800546e:	6823      	ldr	r3, [r4, #0]
 8005470:	42a3      	cmp	r3, r4
 8005472:	d004      	beq.n	800547e <evt_thread7.lto_priv.138+0x2e>
 8005474:	69a2      	ldr	r2, [r4, #24]
 8005476:	689b      	ldr	r3, [r3, #8]
 8005478:	6892      	ldr	r2, [r2, #8]
 800547a:	429a      	cmp	r2, r3
 800547c:	d31f      	bcc.n	80054be <evt_thread7.lto_priv.138+0x6e>
 800547e:	2500      	movs	r5, #0
 8005480:	f385 8811 	msr	BASEPRI, r5
  chThdSleepMilliseconds(50);
 8005484:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8005488:	f7fc f9ca 	bl	8001820 <chThdSleep>
 800548c:	2320      	movs	r3, #32
 800548e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005492:	f7fb fee5 	bl	8001260 <_dbg_check_lock>
  chEvtBroadcastFlagsI(esp, flags);
 8005496:	4629      	mov	r1, r5
 8005498:	480c      	ldr	r0, [pc, #48]	; (80054cc <evt_thread7.lto_priv.138+0x7c>)
 800549a:	f7fb fb29 	bl	8000af0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 800549e:	f7fb fabf 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 80054a2:	f7fb feb5 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80054a6:	6823      	ldr	r3, [r4, #0]
 80054a8:	42a3      	cmp	r3, r4
 80054aa:	d004      	beq.n	80054b6 <evt_thread7.lto_priv.138+0x66>
 80054ac:	69a2      	ldr	r2, [r4, #24]
 80054ae:	689b      	ldr	r3, [r3, #8]
 80054b0:	6892      	ldr	r2, [r2, #8]
 80054b2:	429a      	cmp	r2, r3
 80054b4:	d303      	bcc.n	80054be <evt_thread7.lto_priv.138+0x6e>
 80054b6:	2300      	movs	r3, #0
 80054b8:	f383 8811 	msr	BASEPRI, r3
 80054bc:	bd38      	pop	{r3, r4, r5, pc}
 80054be:	4804      	ldr	r0, [pc, #16]	; (80054d0 <evt_thread7.lto_priv.138+0x80>)
 80054c0:	f7fb f9ae 	bl	8000820 <chSysHalt>
 80054c4:	20001e68 	.word	0x20001e68
 80054c8:	20000c34 	.word	0x20000c34
 80054cc:	20000c38 	.word	0x20000c38
 80054d0:	0800c538 	.word	0x0800c538
	...

080054e0 <evt_thread3.lto_priv.139>:
static THD_FUNCTION(evt_thread3, p) {
 80054e0:	b510      	push	{r4, lr}
 80054e2:	4604      	mov	r4, r0
  chThdSleepMilliseconds(50);
 80054e4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80054e8:	f7fc f99a 	bl	8001820 <chThdSleep>
  chDbgCheck(tp != NULL);
 80054ec:	b1e4      	cbz	r4, 8005528 <evt_thread3.lto_priv.139+0x48>
 80054ee:	2320      	movs	r3, #32
 80054f0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80054f4:	f7fb feb4 	bl	8001260 <_dbg_check_lock>
  chEvtSignalI(tp, events);
 80054f8:	4620      	mov	r0, r4
 80054fa:	2101      	movs	r1, #1
 80054fc:	f7fb fad0 	bl	8000aa0 <chEvtSignalI>
  chSchRescheduleS();
 8005500:	f7fb fa8e 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8005504:	f7fb fe84 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005508:	4b09      	ldr	r3, [pc, #36]	; (8005530 <evt_thread3.lto_priv.139+0x50>)
 800550a:	681a      	ldr	r2, [r3, #0]
 800550c:	429a      	cmp	r2, r3
 800550e:	d004      	beq.n	800551a <evt_thread3.lto_priv.139+0x3a>
 8005510:	6999      	ldr	r1, [r3, #24]
 8005512:	6893      	ldr	r3, [r2, #8]
 8005514:	688a      	ldr	r2, [r1, #8]
 8005516:	429a      	cmp	r2, r3
 8005518:	d303      	bcc.n	8005522 <evt_thread3.lto_priv.139+0x42>
 800551a:	2300      	movs	r3, #0
 800551c:	f383 8811 	msr	BASEPRI, r3
 8005520:	bd10      	pop	{r4, pc}
 8005522:	4804      	ldr	r0, [pc, #16]	; (8005534 <evt_thread3.lto_priv.139+0x54>)
 8005524:	f7fb f97c 	bl	8000820 <chSysHalt>
  chDbgCheck(tp != NULL);
 8005528:	4803      	ldr	r0, [pc, #12]	; (8005538 <evt_thread3.lto_priv.139+0x58>)
 800552a:	f7fb f979 	bl	8000820 <chSysHalt>
 800552e:	bf00      	nop
 8005530:	20001e68 	.word	0x20001e68
 8005534:	0800c538 	.word	0x0800c538
 8005538:	0800adb4 	.word	0x0800adb4
 800553c:	00000000 	.word	0x00000000

08005540 <test_005_008_execute.lto_priv.209>:
static void test_005_008_execute(void) {
 8005540:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 8005542:	4e30      	ldr	r6, [pc, #192]	; (8005604 <test_005_008_execute.lto_priv.209+0xc4>)
  test_set_step(1);
 8005544:	4f30      	ldr	r7, [pc, #192]	; (8005608 <test_005_008_execute.lto_priv.209+0xc8>)
  return chThdGetSelfX()->prio;
 8005546:	69b2      	ldr	r2, [r6, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005548:	4b30      	ldr	r3, [pc, #192]	; (800560c <test_005_008_execute.lto_priv.209+0xcc>)
 800554a:	6895      	ldr	r5, [r2, #8]
 800554c:	4830      	ldr	r0, [pc, #192]	; (8005610 <test_005_008_execute.lto_priv.209+0xd0>)
 800554e:	4a31      	ldr	r2, [pc, #196]	; (8005614 <test_005_008_execute.lto_priv.209+0xd4>)
 8005550:	4c31      	ldr	r4, [pc, #196]	; (8005618 <test_005_008_execute.lto_priv.209+0xd8>)
  test_set_step(1);
 8005552:	f04f 0e01 	mov.w	lr, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005556:	1c69      	adds	r1, r5, #1
  test_set_step(1);
 8005558:	f8c7 e000 	str.w	lr, [r7]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800555c:	f004 fd08 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005560:	1ca9      	adds	r1, r5, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005562:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005564:	4b2d      	ldr	r3, [pc, #180]	; (800561c <test_005_008_execute.lto_priv.209+0xdc>)
 8005566:	4a2b      	ldr	r2, [pc, #172]	; (8005614 <test_005_008_execute.lto_priv.209+0xd4>)
 8005568:	482d      	ldr	r0, [pc, #180]	; (8005620 <test_005_008_execute.lto_priv.209+0xe0>)
 800556a:	f004 fd01 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800556e:	1ce9      	adds	r1, r5, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005570:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8005572:	4b2c      	ldr	r3, [pc, #176]	; (8005624 <test_005_008_execute.lto_priv.209+0xe4>)
 8005574:	4a27      	ldr	r2, [pc, #156]	; (8005614 <test_005_008_execute.lto_priv.209+0xd4>)
 8005576:	482c      	ldr	r0, [pc, #176]	; (8005628 <test_005_008_execute.lto_priv.209+0xe8>)
 8005578:	f004 fcfa 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800557c:	1d29      	adds	r1, r5, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800557e:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8005580:	4b2a      	ldr	r3, [pc, #168]	; (800562c <test_005_008_execute.lto_priv.209+0xec>)
 8005582:	4a24      	ldr	r2, [pc, #144]	; (8005614 <test_005_008_execute.lto_priv.209+0xd4>)
 8005584:	482a      	ldr	r0, [pc, #168]	; (8005630 <test_005_008_execute.lto_priv.209+0xf0>)
 8005586:	f004 fcf3 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800558a:	1d69      	adds	r1, r5, #5
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800558c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800558e:	4b29      	ldr	r3, [pc, #164]	; (8005634 <test_005_008_execute.lto_priv.209+0xf4>)
 8005590:	4a20      	ldr	r2, [pc, #128]	; (8005614 <test_005_008_execute.lto_priv.209+0xd4>)
 8005592:	4829      	ldr	r0, [pc, #164]	; (8005638 <test_005_008_execute.lto_priv.209+0xf8>)
 8005594:	f004 fcec 	bl	8009f70 <chThdCreateStatic.constprop.72>
  test_set_step(2);
 8005598:	2302      	movs	r3, #2
 800559a:	603b      	str	r3, [r7, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800559c:	6120      	str	r0, [r4, #16]
 800559e:	2320      	movs	r3, #32
 80055a0:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tqp->next != (const thread_t *)tqp);
 80055a4:	4c25      	ldr	r4, [pc, #148]	; (800563c <test_005_008_execute.lto_priv.209+0xfc>)
  _dbg_check_lock();
 80055a6:	f7fb fe5b 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 80055aa:	f7fb f989 	bl	80008c0 <chDbgCheckClassI>
 80055ae:	6823      	ldr	r3, [r4, #0]
  while (queue_notempty(&cp->queue)) {
 80055b0:	42a3      	cmp	r3, r4
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 80055b2:	bf18      	it	ne
 80055b4:	f06f 0501 	mvnne.w	r5, #1
  while (queue_notempty(&cp->queue)) {
 80055b8:	d009      	beq.n	80055ce <test_005_008_execute.lto_priv.209+0x8e>
  tqp->next             = tp->queue.next;
 80055ba:	681a      	ldr	r2, [r3, #0]
 80055bc:	6022      	str	r2, [r4, #0]
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 80055be:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 80055c0:	6054      	str	r4, [r2, #4]
 80055c2:	f7fb fa45 	bl	8000a50 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 80055c6:	6823      	ldr	r3, [r4, #0]
 80055c8:	6245      	str	r5, [r0, #36]	; 0x24
  while (queue_notempty(&cp->queue)) {
 80055ca:	42a3      	cmp	r3, r4
 80055cc:	d1f5      	bne.n	80055ba <test_005_008_execute.lto_priv.209+0x7a>
  chSchRescheduleS();
 80055ce:	f7fb fa27 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 80055d2:	f7fb fe1d 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80055d6:	6833      	ldr	r3, [r6, #0]
 80055d8:	42b3      	cmp	r3, r6
 80055da:	d004      	beq.n	80055e6 <test_005_008_execute.lto_priv.209+0xa6>
 80055dc:	69b2      	ldr	r2, [r6, #24]
 80055de:	689b      	ldr	r3, [r3, #8]
 80055e0:	6892      	ldr	r2, [r2, #8]
 80055e2:	429a      	cmp	r2, r3
 80055e4:	d30a      	bcc.n	80055fc <test_005_008_execute.lto_priv.209+0xbc>
 80055e6:	2300      	movs	r3, #0
 80055e8:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 80055ec:	f003 f9d8 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80055f0:	4913      	ldr	r1, [pc, #76]	; (8005640 <test_005_008_execute.lto_priv.209+0x100>)
 80055f2:	4814      	ldr	r0, [pc, #80]	; (8005644 <test_005_008_execute.lto_priv.209+0x104>)
}
 80055f4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 80055f8:	f004 b8c2 	b.w	8009780 <_test_assert_sequence>
 80055fc:	4812      	ldr	r0, [pc, #72]	; (8005648 <test_005_008_execute.lto_priv.209+0x108>)
 80055fe:	f7fb f90f 	bl	8000820 <chSysHalt>
 8005602:	bf00      	nop
 8005604:	20001e68 	.word	0x20001e68
 8005608:	20001df8 	.word	0x20001df8
 800560c:	0800aa00 	.word	0x0800aa00
 8005610:	20001710 	.word	0x20001710
 8005614:	08002ab1 	.word	0x08002ab1
 8005618:	20001d98 	.word	0x20001d98
 800561c:	0800b314 	.word	0x0800b314
 8005620:	20001858 	.word	0x20001858
 8005624:	0800a9e4 	.word	0x0800a9e4
 8005628:	200019a0 	.word	0x200019a0
 800562c:	0800a9e0 	.word	0x0800a9e0
 8005630:	20001ae8 	.word	0x20001ae8
 8005634:	0800a9dc 	.word	0x0800a9dc
 8005638:	20001c30 	.word	0x20001c30
 800563c:	20000c48 	.word	0x20000c48
 8005640:	0800a9e8 	.word	0x0800a9e8
 8005644:	0800a9fc 	.word	0x0800a9fc
 8005648:	0800c52c 	.word	0x0800c52c
 800564c:	00000000 	.word	0x00000000

08005650 <test_005_007_execute.lto_priv.207>:
static void test_005_007_execute(void) {
 8005650:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 8005652:	4e2b      	ldr	r6, [pc, #172]	; (8005700 <test_005_007_execute.lto_priv.207+0xb0>)
  test_set_step(1);
 8005654:	4f2b      	ldr	r7, [pc, #172]	; (8005704 <test_005_007_execute.lto_priv.207+0xb4>)
  return chThdGetSelfX()->prio;
 8005656:	69b2      	ldr	r2, [r6, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005658:	4b2b      	ldr	r3, [pc, #172]	; (8005708 <test_005_007_execute.lto_priv.207+0xb8>)
 800565a:	6895      	ldr	r5, [r2, #8]
 800565c:	482b      	ldr	r0, [pc, #172]	; (800570c <test_005_007_execute.lto_priv.207+0xbc>)
 800565e:	4a2c      	ldr	r2, [pc, #176]	; (8005710 <test_005_007_execute.lto_priv.207+0xc0>)
 8005660:	4c2c      	ldr	r4, [pc, #176]	; (8005714 <test_005_007_execute.lto_priv.207+0xc4>)
  test_set_step(1);
 8005662:	f04f 0e01 	mov.w	lr, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005666:	1c69      	adds	r1, r5, #1
  test_set_step(1);
 8005668:	f8c7 e000 	str.w	lr, [r7]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800566c:	f004 fc80 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005670:	1ca9      	adds	r1, r5, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005672:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005674:	4b28      	ldr	r3, [pc, #160]	; (8005718 <test_005_007_execute.lto_priv.207+0xc8>)
 8005676:	4a26      	ldr	r2, [pc, #152]	; (8005710 <test_005_007_execute.lto_priv.207+0xc0>)
 8005678:	4828      	ldr	r0, [pc, #160]	; (800571c <test_005_007_execute.lto_priv.207+0xcc>)
 800567a:	f004 fc79 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800567e:	1ce9      	adds	r1, r5, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005680:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8005682:	4b27      	ldr	r3, [pc, #156]	; (8005720 <test_005_007_execute.lto_priv.207+0xd0>)
 8005684:	4a22      	ldr	r2, [pc, #136]	; (8005710 <test_005_007_execute.lto_priv.207+0xc0>)
 8005686:	4827      	ldr	r0, [pc, #156]	; (8005724 <test_005_007_execute.lto_priv.207+0xd4>)
 8005688:	f004 fc72 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800568c:	1d29      	adds	r1, r5, #4
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 800568e:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8005690:	4b25      	ldr	r3, [pc, #148]	; (8005728 <test_005_007_execute.lto_priv.207+0xd8>)
 8005692:	4a1f      	ldr	r2, [pc, #124]	; (8005710 <test_005_007_execute.lto_priv.207+0xc0>)
 8005694:	4825      	ldr	r0, [pc, #148]	; (800572c <test_005_007_execute.lto_priv.207+0xdc>)
 8005696:	f004 fc6b 	bl	8009f70 <chThdCreateStatic.constprop.72>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800569a:	1d69      	adds	r1, r5, #5
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800569c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800569e:	4b24      	ldr	r3, [pc, #144]	; (8005730 <test_005_007_execute.lto_priv.207+0xe0>)
 80056a0:	4a1b      	ldr	r2, [pc, #108]	; (8005710 <test_005_007_execute.lto_priv.207+0xc0>)
 80056a2:	4824      	ldr	r0, [pc, #144]	; (8005734 <test_005_007_execute.lto_priv.207+0xe4>)
 80056a4:	f004 fc64 	bl	8009f70 <chThdCreateStatic.constprop.72>
  test_set_step(2);
 80056a8:	2302      	movs	r3, #2
 80056aa:	603b      	str	r3, [r7, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 80056ac:	6120      	str	r0, [r4, #16]
 80056ae:	2320      	movs	r3, #32
 80056b0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80056b4:	f7fb fdd4 	bl	8001260 <_dbg_check_lock>
    chCondSignalI(&c1);
 80056b8:	f004 fba2 	bl	8009e00 <chCondSignalI.constprop.59>
    chCondSignalI(&c1);
 80056bc:	f004 fba0 	bl	8009e00 <chCondSignalI.constprop.59>
    chCondSignalI(&c1);
 80056c0:	f004 fb9e 	bl	8009e00 <chCondSignalI.constprop.59>
    chCondSignalI(&c1);
 80056c4:	f004 fb9c 	bl	8009e00 <chCondSignalI.constprop.59>
    chCondSignalI(&c1);
 80056c8:	f004 fb9a 	bl	8009e00 <chCondSignalI.constprop.59>
    chSchRescheduleS();
 80056cc:	f7fb f9a8 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 80056d0:	f7fb fd9e 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80056d4:	6833      	ldr	r3, [r6, #0]
 80056d6:	42b3      	cmp	r3, r6
 80056d8:	d004      	beq.n	80056e4 <test_005_007_execute.lto_priv.207+0x94>
 80056da:	69b2      	ldr	r2, [r6, #24]
 80056dc:	689b      	ldr	r3, [r3, #8]
 80056de:	6892      	ldr	r2, [r2, #8]
 80056e0:	429a      	cmp	r2, r3
 80056e2:	d30a      	bcc.n	80056fa <test_005_007_execute.lto_priv.207+0xaa>
 80056e4:	2300      	movs	r3, #0
 80056e6:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 80056ea:	f003 f959 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80056ee:	4912      	ldr	r1, [pc, #72]	; (8005738 <test_005_007_execute.lto_priv.207+0xe8>)
 80056f0:	4812      	ldr	r0, [pc, #72]	; (800573c <test_005_007_execute.lto_priv.207+0xec>)
}
 80056f2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 80056f6:	f004 b843 	b.w	8009780 <_test_assert_sequence>
 80056fa:	4811      	ldr	r0, [pc, #68]	; (8005740 <test_005_007_execute.lto_priv.207+0xf0>)
 80056fc:	f7fb f890 	bl	8000820 <chSysHalt>
 8005700:	20001e68 	.word	0x20001e68
 8005704:	20001df8 	.word	0x20001df8
 8005708:	0800aa00 	.word	0x0800aa00
 800570c:	20001710 	.word	0x20001710
 8005710:	08002ab1 	.word	0x08002ab1
 8005714:	20001d98 	.word	0x20001d98
 8005718:	0800b314 	.word	0x0800b314
 800571c:	20001858 	.word	0x20001858
 8005720:	0800a9e4 	.word	0x0800a9e4
 8005724:	200019a0 	.word	0x200019a0
 8005728:	0800a9e0 	.word	0x0800a9e0
 800572c:	20001ae8 	.word	0x20001ae8
 8005730:	0800a9dc 	.word	0x0800a9dc
 8005734:	20001c30 	.word	0x20001c30
 8005738:	0800a9e8 	.word	0x0800a9e8
 800573c:	0800a9fc 	.word	0x0800a9fc
 8005740:	0800ad90 	.word	0x0800ad90
	...

08005750 <test_005_005_execute.lto_priv.205>:
static void test_005_005_execute(void) {
 8005750:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  return ch.rlist.current;
 8005754:	4d5b      	ldr	r5, [pc, #364]	; (80058c4 <test_005_005_execute.lto_priv.205+0x174>)
  test_set_step(2);
 8005756:	4c5c      	ldr	r4, [pc, #368]	; (80058c8 <test_005_005_execute.lto_priv.205+0x178>)
  return chThdGetSelfX()->prio;
 8005758:	69aa      	ldr	r2, [r5, #24]
 800575a:	2302      	movs	r3, #2
 800575c:	6896      	ldr	r6, [r2, #8]
 800575e:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
 8005760:	f004 fcd6 	bl	800a110 <chMtxTryLock.constprop.62>
    test_assert(b, "already locked");
 8005764:	4959      	ldr	r1, [pc, #356]	; (80058cc <test_005_005_execute.lto_priv.205+0x17c>)
 8005766:	f004 f833 	bl	80097d0 <_test_assert>
 800576a:	b108      	cbz	r0, 8005770 <test_005_005_execute.lto_priv.205+0x20>
 800576c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  test_set_step(3);
 8005770:	2303      	movs	r3, #3
 8005772:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
 8005774:	f004 fccc 	bl	800a110 <chMtxTryLock.constprop.62>
    test_assert(!b, "not locked");
 8005778:	f080 0001 	eor.w	r0, r0, #1
 800577c:	b2c0      	uxtb	r0, r0
 800577e:	4954      	ldr	r1, [pc, #336]	; (80058d0 <test_005_005_execute.lto_priv.205+0x180>)
 8005780:	f004 f826 	bl	80097d0 <_test_assert>
 8005784:	2800      	cmp	r0, #0
 8005786:	d1f1      	bne.n	800576c <test_005_005_execute.lto_priv.205+0x1c>
    chMtxUnlock(&m1);
 8005788:	4f52      	ldr	r7, [pc, #328]	; (80058d4 <test_005_005_execute.lto_priv.205+0x184>)
  test_set_step(4);
 800578a:	2304      	movs	r3, #4
    chMtxUnlock(&m1);
 800578c:	4638      	mov	r0, r7
  test_set_step(4);
 800578e:	6023      	str	r3, [r4, #0]
    chMtxUnlock(&m1);
 8005790:	f7fb febe 	bl	8001510 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8005794:	68b8      	ldr	r0, [r7, #8]
 8005796:	4950      	ldr	r1, [pc, #320]	; (80058d8 <test_005_005_execute.lto_priv.205+0x188>)
 8005798:	fab0 f080 	clz	r0, r0
 800579c:	0940      	lsrs	r0, r0, #5
 800579e:	f004 f817 	bl	80097d0 <_test_assert>
 80057a2:	2800      	cmp	r0, #0
 80057a4:	d1e2      	bne.n	800576c <test_005_005_execute.lto_priv.205+0x1c>
  return (bool)(tqp->next == (const thread_t *)tqp);
 80057a6:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 80057a8:	494c      	ldr	r1, [pc, #304]	; (80058dc <test_005_005_execute.lto_priv.205+0x18c>)
 80057aa:	1bc0      	subs	r0, r0, r7
 80057ac:	fab0 f080 	clz	r0, r0
 80057b0:	0940      	lsrs	r0, r0, #5
 80057b2:	f004 f80d 	bl	80097d0 <_test_assert>
 80057b6:	2800      	cmp	r0, #0
 80057b8:	d1d8      	bne.n	800576c <test_005_005_execute.lto_priv.205+0x1c>
 80057ba:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80057bc:	4948      	ldr	r1, [pc, #288]	; (80058e0 <test_005_005_execute.lto_priv.205+0x190>)
 80057be:	6898      	ldr	r0, [r3, #8]
 80057c0:	1b80      	subs	r0, r0, r6
 80057c2:	fab0 f080 	clz	r0, r0
  test_set_step(5);
 80057c6:	2305      	movs	r3, #5
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80057c8:	0940      	lsrs	r0, r0, #5
  test_set_step(5);
 80057ca:	6023      	str	r3, [r4, #0]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80057cc:	f004 f800 	bl	80097d0 <_test_assert>
 80057d0:	2800      	cmp	r0, #0
 80057d2:	d1cb      	bne.n	800576c <test_005_005_execute.lto_priv.205+0x1c>
  test_set_step(6);
 80057d4:	2306      	movs	r3, #6
 80057d6:	6023      	str	r3, [r4, #0]
    b = chMtxTryLock(&m1);
 80057d8:	f004 fc9a 	bl	800a110 <chMtxTryLock.constprop.62>
    test_assert(b, "already locked");
 80057dc:	493b      	ldr	r1, [pc, #236]	; (80058cc <test_005_005_execute.lto_priv.205+0x17c>)
 80057de:	f003 fff7 	bl	80097d0 <_test_assert>
 80057e2:	2800      	cmp	r0, #0
 80057e4:	d1c2      	bne.n	800576c <test_005_005_execute.lto_priv.205+0x1c>
    b = chMtxTryLock(&m1);
 80057e6:	f004 fc93 	bl	800a110 <chMtxTryLock.constprop.62>
    test_assert(!b, "not locked");
 80057ea:	f080 0001 	eor.w	r0, r0, #1
 80057ee:	b2c0      	uxtb	r0, r0
 80057f0:	4937      	ldr	r1, [pc, #220]	; (80058d0 <test_005_005_execute.lto_priv.205+0x180>)
 80057f2:	f003 ffed 	bl	80097d0 <_test_assert>
 80057f6:	4682      	mov	sl, r0
 80057f8:	2800      	cmp	r0, #0
 80057fa:	d1b7      	bne.n	800576c <test_005_005_execute.lto_priv.205+0x1c>
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 80057fc:	f8d5 9018 	ldr.w	r9, [r5, #24]
 8005800:	2320      	movs	r3, #32
 8005802:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8005806:	f7fb fd2b 	bl	8001260 <_dbg_check_lock>

  chSysLock();
  if (ctp->mtxlist != NULL) {
 800580a:	f8d9 8038 	ldr.w	r8, [r9, #56]	; 0x38
 800580e:	f1b8 0f00 	cmp.w	r8, #0
 8005812:	d023      	beq.n	800585c <test_005_005_execute.lto_priv.205+0x10c>
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
 8005814:	f8d8 b00c 	ldr.w	fp, [r8, #12]
 8005818:	f8c9 b038 	str.w	fp, [r9, #56]	; 0x38
 800581c:	f7fb f818 	bl	8000850 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8005820:	f8d8 3000 	ldr.w	r3, [r8]
      if (chMtxQueueNotEmptyS(mp)) {
 8005824:	4598      	cmp	r8, r3
 8005826:	d046      	beq.n	80058b6 <test_005_005_execute.lto_priv.205+0x166>
  tqp->next             = tp->queue.next;
 8005828:	681a      	ldr	r2, [r3, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
        mp->next = tp->mtxlist;
 800582a:	6b99      	ldr	r1, [r3, #56]	; 0x38
 800582c:	f8c8 2000 	str.w	r2, [r8]
        tp->mtxlist = mp;
        (void) chSchReadyI(tp);
 8005830:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 8005832:	f8c2 8004 	str.w	r8, [r2, #4]
        mp->owner = tp;
 8005836:	f8c8 3008 	str.w	r3, [r8, #8]
        mp->next = tp->mtxlist;
 800583a:	f8c8 100c 	str.w	r1, [r8, #12]
        tp->mtxlist = mp;
 800583e:	f8c3 8038 	str.w	r8, [r3, #56]	; 0x38
        (void) chSchReadyI(tp);
 8005842:	f7fb f905 	bl	8000a50 <chSchReadyI>
 8005846:	f8d9 8038 	ldr.w	r8, [r9, #56]	; 0x38
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
      }
    } while (ctp->mtxlist != NULL);
 800584a:	f1b8 0f00 	cmp.w	r8, #0
 800584e:	d1e1      	bne.n	8005814 <test_005_005_execute.lto_priv.205+0xc4>
    ctp->prio = ctp->realprio;
 8005850:	f8d9 303c 	ldr.w	r3, [r9, #60]	; 0x3c
 8005854:	f8c9 3008 	str.w	r3, [r9, #8]
    chSchRescheduleS();
 8005858:	f7fb f8e2 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 800585c:	f7fb fcd8 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005860:	682b      	ldr	r3, [r5, #0]
 8005862:	42ab      	cmp	r3, r5
 8005864:	d004      	beq.n	8005870 <test_005_005_execute.lto_priv.205+0x120>
 8005866:	69aa      	ldr	r2, [r5, #24]
 8005868:	689b      	ldr	r3, [r3, #8]
 800586a:	6892      	ldr	r2, [r2, #8]
 800586c:	429a      	cmp	r2, r3
 800586e:	d326      	bcc.n	80058be <test_005_005_execute.lto_priv.205+0x16e>
 8005870:	2300      	movs	r3, #0
 8005872:	f383 8811 	msr	BASEPRI, r3
    test_assert(m1.owner == NULL, "still owned");
 8005876:	68b8      	ldr	r0, [r7, #8]
 8005878:	4917      	ldr	r1, [pc, #92]	; (80058d8 <test_005_005_execute.lto_priv.205+0x188>)
 800587a:	fab0 f080 	clz	r0, r0
 800587e:	0940      	lsrs	r0, r0, #5
 8005880:	f003 ffa6 	bl	80097d0 <_test_assert>
 8005884:	2800      	cmp	r0, #0
 8005886:	f47f af71 	bne.w	800576c <test_005_005_execute.lto_priv.205+0x1c>
  return (bool)(tqp->next == (const thread_t *)tqp);
 800588a:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 800588c:	4913      	ldr	r1, [pc, #76]	; (80058dc <test_005_005_execute.lto_priv.205+0x18c>)
 800588e:	1bc7      	subs	r7, r0, r7
 8005890:	4278      	negs	r0, r7
 8005892:	4178      	adcs	r0, r7
 8005894:	f003 ff9c 	bl	80097d0 <_test_assert>
 8005898:	2800      	cmp	r0, #0
 800589a:	f47f af67 	bne.w	800576c <test_005_005_execute.lto_priv.205+0x1c>
 800589e:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80058a0:	490f      	ldr	r1, [pc, #60]	; (80058e0 <test_005_005_execute.lto_priv.205+0x190>)
 80058a2:	6898      	ldr	r0, [r3, #8]
 80058a4:	1b82      	subs	r2, r0, r6
  test_set_step(7);
 80058a6:	2307      	movs	r3, #7
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80058a8:	4250      	negs	r0, r2
  test_set_step(7);
 80058aa:	6023      	str	r3, [r4, #0]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80058ac:	4150      	adcs	r0, r2
}
 80058ae:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80058b2:	f003 bf8d 	b.w	80097d0 <_test_assert>
        mp->owner = NULL;
 80058b6:	f8c8 a008 	str.w	sl, [r8, #8]
 80058ba:	46d8      	mov	r8, fp
 80058bc:	e7c5      	b.n	800584a <test_005_005_execute.lto_priv.205+0xfa>
 80058be:	4809      	ldr	r0, [pc, #36]	; (80058e4 <test_005_005_execute.lto_priv.205+0x194>)
 80058c0:	f7fa ffae 	bl	8000820 <chSysHalt>
 80058c4:	20001e68 	.word	0x20001e68
 80058c8:	20001df8 	.word	0x20001df8
 80058cc:	0800ae08 	.word	0x0800ae08
 80058d0:	0800ae18 	.word	0x0800ae18
 80058d4:	20000c50 	.word	0x20000c50
 80058d8:	0800ae24 	.word	0x0800ae24
 80058dc:	0800aa2c 	.word	0x0800aa2c
 80058e0:	0800adf0 	.word	0x0800adf0
 80058e4:	0800c520 	.word	0x0800c520
	...

080058f0 <thread8>:
static THD_FUNCTION(thread8, p) {
 80058f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80058f2:	4607      	mov	r7, r0
  chMtxLock(&m2);
 80058f4:	4826      	ldr	r0, [pc, #152]	; (8005990 <thread8+0xa0>)
 80058f6:	f7fb fe6b 	bl	80015d0 <chMtxLock>
  chMtxLock(&m1);
 80058fa:	4826      	ldr	r0, [pc, #152]	; (8005994 <thread8+0xa4>)
 80058fc:	f7fb fe68 	bl	80015d0 <chMtxLock>
 8005900:	2320      	movs	r3, #32
 8005902:	f383 8811 	msr	BASEPRI, r3
  mutex_t *mp;
  msg_t msg;

  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->mtxlist != NULL, "not owning a mutex");
 8005906:	4d24      	ldr	r5, [pc, #144]	; (8005998 <thread8+0xa8>)
  _dbg_check_lock();
 8005908:	f7fb fcaa 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassS();
 800590c:	f7fa ffa0 	bl	8000850 <chDbgCheckClassS>
  chDbgAssert(currp->mtxlist != NULL, "not owning a mutex");
 8005910:	69ab      	ldr	r3, [r5, #24]
 8005912:	6b9e      	ldr	r6, [r3, #56]	; 0x38
 8005914:	2e00      	cmp	r6, #0
 8005916:	d038      	beq.n	800598a <thread8+0x9a>

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8005918:	4630      	mov	r0, r6
 800591a:	f7fb f909 	bl	8000b30 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 800591e:	4b1f      	ldr	r3, [pc, #124]	; (800599c <thread8+0xac>)
 8005920:	69ac      	ldr	r4, [r5, #24]
  thread_t *cp = (thread_t *)tqp;
 8005922:	4618      	mov	r0, r3
 8005924:	6263      	str	r3, [r4, #36]	; 0x24
 8005926:	e003      	b.n	8005930 <thread8+0x40>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8005928:	6899      	ldr	r1, [r3, #8]
 800592a:	68a2      	ldr	r2, [r4, #8]
 800592c:	4291      	cmp	r1, r2
 800592e:	d302      	bcc.n	8005936 <thread8+0x46>
    cp = cp->queue.next;
 8005930:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8005932:	4283      	cmp	r3, r0
 8005934:	d1f8      	bne.n	8005928 <thread8+0x38>
  tp->queue.prev             = cp->queue.prev;
 8005936:	685a      	ldr	r2, [r3, #4]
 8005938:	6062      	str	r2, [r4, #4]
  tp->queue.next             = cp;
 800593a:	6023      	str	r3, [r4, #0]
  queue_prio_insert(currp, &cp->queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800593c:	f04f 31ff 	mov.w	r1, #4294967295
  tp->queue.prev->queue.next = tp;
 8005940:	6014      	str	r4, [r2, #0]
 8005942:	2007      	movs	r0, #7
  cp->queue.prev             = tp;
 8005944:	605c      	str	r4, [r3, #4]
 8005946:	f7fb faf3 	bl	8000f30 <chSchGoSleepTimeoutS>
  if (msg != MSG_TIMEOUT) {
 800594a:	3001      	adds	r0, #1
 800594c:	d002      	beq.n	8005954 <thread8+0x64>
    chMtxLockS(mp);
 800594e:	4630      	mov	r0, r6
 8005950:	f7fb f936 	bl	8000bc0 <chMtxLockS>
  _dbg_check_unlock();
 8005954:	f7fb fc5c 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005958:	682b      	ldr	r3, [r5, #0]
 800595a:	42ab      	cmp	r3, r5
 800595c:	d004      	beq.n	8005968 <thread8+0x78>
 800595e:	69aa      	ldr	r2, [r5, #24]
 8005960:	689b      	ldr	r3, [r3, #8]
 8005962:	6892      	ldr	r2, [r2, #8]
 8005964:	429a      	cmp	r2, r3
 8005966:	d30d      	bcc.n	8005984 <thread8+0x94>
 8005968:	2300      	movs	r3, #0
 800596a:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 800596e:	7838      	ldrb	r0, [r7, #0]
 8005970:	f004 f856 	bl	8009a20 <test_emit_token>
  chMtxUnlock(&m1);
 8005974:	4807      	ldr	r0, [pc, #28]	; (8005994 <thread8+0xa4>)
 8005976:	f7fb fdcb 	bl	8001510 <chMtxUnlock>
  chMtxUnlock(&m2);
 800597a:	4805      	ldr	r0, [pc, #20]	; (8005990 <thread8+0xa0>)
}
 800597c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  chMtxUnlock(&m2);
 8005980:	f7fb bdc6 	b.w	8001510 <chMtxUnlock>
 8005984:	4806      	ldr	r0, [pc, #24]	; (80059a0 <thread8+0xb0>)
 8005986:	f7fa ff4b 	bl	8000820 <chSysHalt>
  chDbgAssert(currp->mtxlist != NULL, "not owning a mutex");
 800598a:	4806      	ldr	r0, [pc, #24]	; (80059a4 <thread8+0xb4>)
 800598c:	f7fa ff48 	bl	8000820 <chSysHalt>
 8005990:	20000c24 	.word	0x20000c24
 8005994:	20000c50 	.word	0x20000c50
 8005998:	20001e68 	.word	0x20001e68
 800599c:	20000c48 	.word	0x20000c48
 80059a0:	0800c52c 	.word	0x0800c52c
 80059a4:	0800adc0 	.word	0x0800adc0
	...

080059b0 <get_descriptor.lto_priv.105>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 80059b0:	2902      	cmp	r1, #2
 80059b2:	d006      	beq.n	80059c2 <get_descriptor.lto_priv.105+0x12>
 80059b4:	2903      	cmp	r1, #3
 80059b6:	d006      	beq.n	80059c6 <get_descriptor.lto_priv.105+0x16>
 80059b8:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 80059ba:	4806      	ldr	r0, [pc, #24]	; (80059d4 <get_descriptor.lto_priv.105+0x24>)
 80059bc:	bf18      	it	ne
 80059be:	2000      	movne	r0, #0
 80059c0:	4770      	bx	lr
    return &vcom_configuration_descriptor;
 80059c2:	4805      	ldr	r0, [pc, #20]	; (80059d8 <get_descriptor.lto_priv.105+0x28>)
 80059c4:	4770      	bx	lr
    if (dindex < 4)
 80059c6:	2a03      	cmp	r2, #3
      return &vcom_strings[dindex];
 80059c8:	bf9a      	itte	ls
 80059ca:	4804      	ldrls	r0, [pc, #16]	; (80059dc <get_descriptor.lto_priv.105+0x2c>)
 80059cc:	eb00 00c2 	addls.w	r0, r0, r2, lsl #3
  return NULL;
 80059d0:	2000      	movhi	r0, #0
}
 80059d2:	4770      	bx	lr
 80059d4:	0800b490 	.word	0x0800b490
 80059d8:	0800b444 	.word	0x0800b444
 80059dc:	0800b518 	.word	0x0800b518

080059e0 <sof_handler.lto_priv.106>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 80059e0:	b510      	push	{r4, lr}
 80059e2:	2320      	movs	r3, #32
 80059e4:	b082      	sub	sp, #8
 80059e6:	f383 8811 	msr	BASEPRI, r3
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80059ea:	4c23      	ldr	r4, [pc, #140]	; (8005a78 <sof_handler.lto_priv.106+0x98>)
  _dbg_check_lock_from_isr();
 80059ec:	f7fb fbc0 	bl	8001170 <_dbg_check_lock_from_isr>
 80059f0:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 80059f4:	6813      	ldr	r3, [r2, #0]
 80059f6:	7819      	ldrb	r1, [r3, #0]
 80059f8:	2904      	cmp	r1, #4
 80059fa:	d006      	beq.n	8005a0a <sof_handler.lto_priv.106+0x2a>
  _dbg_check_unlock_from_isr();
 80059fc:	f7fb fba0 	bl	8001140 <_dbg_check_unlock_from_isr>
 8005a00:	2300      	movs	r3, #0
 8005a02:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
  osalSysUnlockFromISR();
}
 8005a06:	b002      	add	sp, #8
 8005a08:	bd10      	pop	{r4, pc}
 8005a0a:	7a21      	ldrb	r1, [r4, #8]
 8005a0c:	2902      	cmp	r1, #2
 8005a0e:	d1f5      	bne.n	80059fc <sof_handler.lto_priv.106+0x1c>
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8005a10:	7911      	ldrb	r1, [r2, #4]
 8005a12:	891a      	ldrh	r2, [r3, #8]
 8005a14:	2301      	movs	r3, #1
 8005a16:	408b      	lsls	r3, r1
 8005a18:	4213      	tst	r3, r2
 8005a1a:	d1ef      	bne.n	80059fc <sof_handler.lto_priv.106+0x1c>
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
 8005a1c:	f7fa ff50 	bl	80008c0 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8005a20:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8005a22:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8005a24:	4293      	cmp	r3, r2
 8005a26:	d1e9      	bne.n	80059fc <sof_handler.lto_priv.106+0x1c>
 8005a28:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8005a2a:	2a00      	cmp	r2, #0
 8005a2c:	d0e6      	beq.n	80059fc <sof_handler.lto_priv.106+0x1c>
 8005a2e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8005a30:	2a00      	cmp	r2, #0
 8005a32:	d0e3      	beq.n	80059fc <sof_handler.lto_priv.106+0x1c>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 8005a34:	3a04      	subs	r2, #4

    if (size > 0U) {
 8005a36:	1ad2      	subs	r2, r2, r3
 8005a38:	d0e0      	beq.n	80059fc <sof_handler.lto_priv.106+0x1c>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 8005a3a:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
 8005a3c:	6e20      	ldr	r0, [r4, #96]	; 0x60
      if (obqp->bwrptr >= obqp->btop) {
 8005a3e:	6de1      	ldr	r1, [r4, #92]	; 0x5c
      obqp->bcounter--;
 8005a40:	6d22      	ldr	r2, [r4, #80]	; 0x50
      obqp->bwrptr += obqp->bsize;
 8005a42:	4403      	add	r3, r0
      if (obqp->bwrptr >= obqp->btop) {
 8005a44:	428b      	cmp	r3, r1
      obqp->bwrptr += obqp->bsize;
 8005a46:	6563      	str	r3, [r4, #84]	; 0x54
        obqp->bwrptr = obqp->buffers;
 8005a48:	bf24      	itt	cs
 8005a4a:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68
 8005a4c:	6563      	strcs	r3, [r4, #84]	; 0x54
      obqp->bcounter--;
 8005a4e:	3a01      	subs	r2, #1
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 8005a50:	2300      	movs	r3, #0
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8005a52:	a901      	add	r1, sp, #4
 8005a54:	4809      	ldr	r0, [pc, #36]	; (8005a7c <sof_handler.lto_priv.106+0x9c>)
      obqp->bcounter--;
 8005a56:	6522      	str	r2, [r4, #80]	; 0x50
      obqp->ptr = NULL;
 8005a58:	66e3      	str	r3, [r4, #108]	; 0x6c
 8005a5a:	f7fe fd99 	bl	8004590 <obqGetFullBufferI>
    osalDbgAssert(buf != NULL, "queue is empty");
 8005a5e:	4602      	mov	r2, r0
 8005a60:	b138      	cbz	r0, 8005a72 <sof_handler.lto_priv.106+0x92>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8005a62:	f8d4 048c 	ldr.w	r0, [r4, #1164]	; 0x48c
 8005a66:	9b01      	ldr	r3, [sp, #4]
 8005a68:	7901      	ldrb	r1, [r0, #4]
 8005a6a:	6800      	ldr	r0, [r0, #0]
 8005a6c:	f001 f998 	bl	8006da0 <usbStartTransmitI>
 8005a70:	e7c4      	b.n	80059fc <sof_handler.lto_priv.106+0x1c>
    osalDbgAssert(buf != NULL, "queue is empty");
 8005a72:	4803      	ldr	r0, [pc, #12]	; (8005a80 <sof_handler.lto_priv.106+0xa0>)
 8005a74:	f7fa fed4 	bl	8000820 <chSysHalt>
 8005a78:	20000c88 	.word	0x20000c88
 8005a7c:	20000ccc 	.word	0x20000ccc
 8005a80:	0800ae74 	.word	0x0800ae74
	...

08005a90 <usb_event.lto_priv.104>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8005a90:	b538      	push	{r3, r4, r5, lr}
  switch (event) {
 8005a92:	2905      	cmp	r1, #5
 8005a94:	d816      	bhi.n	8005ac4 <usb_event.lto_priv.104+0x34>
 8005a96:	e8df f001 	tbb	[pc, r1]
 8005a9a:	1550      	.short	0x1550
 8005a9c:	03505016 	.word	0x03505016
 8005aa0:	2320      	movs	r3, #32
 8005aa2:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8005aa6:	f7fb fb63 	bl	8001170 <_dbg_check_lock_from_isr>
  chEvtBroadcastFlagsI(esp, flags);
 8005aaa:	2101      	movs	r1, #1
 8005aac:	4831      	ldr	r0, [pc, #196]	; (8005b74 <usb_event.lto_priv.104+0xe4>)
 8005aae:	f7fb f81f 	bl	8000af0 <chEvtBroadcastFlagsI>
  bqResumeX(&sdup->ibqueue);
 8005ab2:	4b31      	ldr	r3, [pc, #196]	; (8005b78 <usb_event.lto_priv.104+0xe8>)
 8005ab4:	2400      	movs	r4, #0
 8005ab6:	751c      	strb	r4, [r3, #20]
  bqResumeX(&sdup->obqueue);
 8005ab8:	f883 404c 	strb.w	r4, [r3, #76]	; 0x4c
  _dbg_check_unlock_from_isr();
 8005abc:	f7fb fb40 	bl	8001140 <_dbg_check_unlock_from_isr>
 8005ac0:	f384 8811 	msr	BASEPRI, r4
 8005ac4:	bd38      	pop	{r3, r4, r5, pc}
 8005ac6:	4605      	mov	r5, r0
 8005ac8:	2320      	movs	r3, #32
 8005aca:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8005ace:	f7fb fb4f 	bl	8001170 <_dbg_check_lock_from_isr>
  ibqp->bcounter  = 0;
 8005ad2:	4c29      	ldr	r4, [pc, #164]	; (8005b78 <usb_event.lto_priv.104+0xe8>)
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8005ad4:	4a29      	ldr	r2, [pc, #164]	; (8005b7c <usb_event.lto_priv.104+0xec>)
 8005ad6:	4628      	mov	r0, r5
 8005ad8:	2101      	movs	r1, #1
 8005ada:	f7fe fc09 	bl	80042f0 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 8005ade:	2102      	movs	r1, #2
 8005ae0:	4a27      	ldr	r2, [pc, #156]	; (8005b80 <usb_event.lto_priv.104+0xf0>)
 8005ae2:	4628      	mov	r0, r5
 8005ae4:	f7fe fc04 	bl	80042f0 <usbInitEndpointI>
 8005ae8:	2500      	movs	r5, #0
  osalDbgCheckClassI();
 8005aea:	f7fa fee9 	bl	80008c0 <chDbgCheckClassI>
  ibqp->brdptr    = ibqp->buffers;
 8005aee:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005af0:	6223      	str	r3, [r4, #32]
  chThdDequeueAllI(tqp, msg);
 8005af2:	f104 000c 	add.w	r0, r4, #12
  ibqp->bwrptr    = ibqp->buffers;
 8005af6:	61e3      	str	r3, [r4, #28]
  ibqp->bcounter  = 0;
 8005af8:	61a5      	str	r5, [r4, #24]
  ibqp->ptr       = NULL;
 8005afa:	6365      	str	r5, [r4, #52]	; 0x34
  ibqp->top       = NULL;
 8005afc:	63a5      	str	r5, [r4, #56]	; 0x38
 8005afe:	f004 f957 	bl	8009db0 <chThdDequeueAllI.constprop.68>
  bqResumeX(&sdup->ibqueue);
 8005b02:	7525      	strb	r5, [r4, #20]
  osalDbgCheckClassI();
 8005b04:	f7fa fedc 	bl	80008c0 <chDbgCheckClassI>
  obqp->brdptr    = obqp->buffers;
 8005b08:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  obqp->bcounter  = bqSizeX(obqp);
 8005b0a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8005b0c:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->brdptr    = obqp->buffers;
 8005b0e:	65a3      	str	r3, [r4, #88]	; 0x58
  obqp->bwrptr    = obqp->buffers;
 8005b10:	6563      	str	r3, [r4, #84]	; 0x54
 8005b12:	f104 0044 	add.w	r0, r4, #68	; 0x44
  obqp->ptr       = NULL;
 8005b16:	66e5      	str	r5, [r4, #108]	; 0x6c
  obqp->top       = NULL;
 8005b18:	6725      	str	r5, [r4, #112]	; 0x70
 8005b1a:	f004 f949 	bl	8009db0 <chThdDequeueAllI.constprop.68>
  chEvtBroadcastFlagsI(esp, flags);
 8005b1e:	2101      	movs	r1, #1
 8005b20:	1d20      	adds	r0, r4, #4
  bqResumeX(&sdup->obqueue);
 8005b22:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8005b26:	f7fa ffe3 	bl	8000af0 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
 8005b2a:	4620      	mov	r0, r4
 8005b2c:	f7fe fcb8 	bl	80044a0 <sdu_start_receive.lto_priv.125>
  _dbg_check_unlock_from_isr();
 8005b30:	f7fb fb06 	bl	8001140 <_dbg_check_unlock_from_isr>
 8005b34:	f385 8811 	msr	BASEPRI, r5
 8005b38:	bd38      	pop	{r3, r4, r5, pc}
 8005b3a:	2320      	movs	r3, #32
 8005b3c:	f383 8811 	msr	BASEPRI, r3
  bqSuspendI(&sdup->ibqueue);
 8005b40:	4c0d      	ldr	r4, [pc, #52]	; (8005b78 <usb_event.lto_priv.104+0xe8>)
  _dbg_check_lock_from_isr();
 8005b42:	f7fb fb15 	bl	8001170 <_dbg_check_lock_from_isr>
 8005b46:	2102      	movs	r1, #2
 8005b48:	1d20      	adds	r0, r4, #4
 8005b4a:	f7fa ffd1 	bl	8000af0 <chEvtBroadcastFlagsI>
 8005b4e:	2501      	movs	r5, #1
  chThdDequeueAllI(tqp, msg);
 8005b50:	f104 000c 	add.w	r0, r4, #12
 8005b54:	7525      	strb	r5, [r4, #20]
 8005b56:	f004 f92b 	bl	8009db0 <chThdDequeueAllI.constprop.68>
 8005b5a:	f104 0044 	add.w	r0, r4, #68	; 0x44
  bqSuspendI(&sdup->obqueue);
 8005b5e:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8005b62:	f004 f925 	bl	8009db0 <chThdDequeueAllI.constprop.68>
  _dbg_check_unlock_from_isr();
 8005b66:	f7fb faeb 	bl	8001140 <_dbg_check_unlock_from_isr>
 8005b6a:	2300      	movs	r3, #0
 8005b6c:	f383 8811 	msr	BASEPRI, r3
 8005b70:	bd38      	pop	{r3, r4, r5, pc}
 8005b72:	bf00      	nop
 8005b74:	20000c8c 	.word	0x20000c8c
 8005b78:	20000c88 	.word	0x20000c88
 8005b7c:	0800b174 	.word	0x0800b174
 8005b80:	0800b198 	.word	0x0800b198
	...

08005b90 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
 8005b90:	b570      	push	{r4, r5, r6, lr}
 8005b92:	460e      	mov	r6, r1
  char *p;

  if (str != NULL)
 8005b94:	b1f0      	cbz	r0, 8005bd4 <parse_arguments+0x44>
 8005b96:	4604      	mov	r4, r0
    *saveptr = str;
 8005b98:	6030      	str	r0, [r6, #0]
  if (!p) {
    return NULL;
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
 8005b9a:	4911      	ldr	r1, [pc, #68]	; (8005be0 <parse_arguments+0x50>)
 8005b9c:	4620      	mov	r0, r4
 8005b9e:	f004 fce7 	bl	800a570 <strspn>

  if (*p == '"') {
 8005ba2:	5c21      	ldrb	r1, [r4, r0]
 8005ba4:	2922      	cmp	r1, #34	; 0x22
  p += strspn(p, " \t");
 8005ba6:	eb04 0500 	add.w	r5, r4, r0
  if (*p == '"') {
 8005baa:	d00d      	beq.n	8005bc8 <parse_arguments+0x38>
    p++;
    *saveptr = strpbrk(p, "\"");
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
 8005bac:	490c      	ldr	r1, [pc, #48]	; (8005be0 <parse_arguments+0x50>)
 8005bae:	4628      	mov	r0, r5
 8005bb0:	f004 fcbc 	bl	800a52c <strpbrk>
 8005bb4:	6030      	str	r0, [r6, #0]
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
 8005bb6:	b118      	cbz	r0, 8005bc0 <parse_arguments+0x30>
    *(*saveptr)++ = '\0';
 8005bb8:	1c42      	adds	r2, r0, #1
 8005bba:	2300      	movs	r3, #0
 8005bbc:	6032      	str	r2, [r6, #0]
 8005bbe:	7003      	strb	r3, [r0, #0]
  }

  return *p != '\0' ? p : NULL;
 8005bc0:	782b      	ldrb	r3, [r5, #0]
 8005bc2:	b153      	cbz	r3, 8005bda <parse_arguments+0x4a>
}
 8005bc4:	4628      	mov	r0, r5
 8005bc6:	bd70      	pop	{r4, r5, r6, pc}
    p++;
 8005bc8:	3501      	adds	r5, #1
    *saveptr = strpbrk(p, "\"");
 8005bca:	4628      	mov	r0, r5
 8005bcc:	f004 fc3a 	bl	800a444 <strchr>
 8005bd0:	6030      	str	r0, [r6, #0]
 8005bd2:	e7f0      	b.n	8005bb6 <parse_arguments+0x26>
  p = *saveptr;
 8005bd4:	680c      	ldr	r4, [r1, #0]
  if (!p) {
 8005bd6:	2c00      	cmp	r4, #0
 8005bd8:	d1df      	bne.n	8005b9a <parse_arguments+0xa>
  return *p != '\0' ? p : NULL;
 8005bda:	2500      	movs	r5, #0
}
 8005bdc:	4628      	mov	r0, r5
 8005bde:	bd70      	pop	{r4, r5, r6, pc}
 8005be0:	0800b1bc 	.word	0x0800b1bc
	...

08005bf0 <test_012_012_execute.lto_priv.259>:
 * - [12.12.8] The size of an event listener is printed.
 * - [12.12.9] The size of a mailbox is printed.
 * .
 */

static void test_012_012_execute(void) {
 8005bf0:	b570      	push	{r4, r5, r6, lr}

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8005bf2:	4d34      	ldr	r5, [pc, #208]	; (8005cc4 <test_012_012_execute.lto_priv.259+0xd4>)
  {
    test_print("--- System: ");
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
 8005bf4:	4c34      	ldr	r4, [pc, #208]	; (8005cc8 <test_012_012_execute.lto_priv.259+0xd8>)
    test_print("--- System: ");
 8005bf6:	4835      	ldr	r0, [pc, #212]	; (8005ccc <test_012_012_execute.lto_priv.259+0xdc>)
  test_set_step(1);
 8005bf8:	2301      	movs	r3, #1
 8005bfa:	602b      	str	r3, [r5, #0]
    test_print("--- System: ");
 8005bfc:	f003 fc28 	bl	8009450 <test_print>
    test_printn(sizeof(ch_system_t));
 8005c00:	f640 0088 	movw	r0, #2184	; 0x888
 8005c04:	f003 fc3c 	bl	8009480 <test_printn>
    test_println(" bytes");
 8005c08:	4620      	mov	r0, r4
 8005c0a:	f003 fc01 	bl	8009410 <test_println>
  }

  /* [12.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 8005c0e:	2302      	movs	r3, #2
  {
    test_print("--- Thread: ");
 8005c10:	482f      	ldr	r0, [pc, #188]	; (8005cd0 <test_012_012_execute.lto_priv.259+0xe0>)
  test_set_step(2);
 8005c12:	602b      	str	r3, [r5, #0]
    test_print("--- Thread: ");
 8005c14:	f003 fc1c 	bl	8009450 <test_print>
    test_printn(sizeof(thread_t));
 8005c18:	2044      	movs	r0, #68	; 0x44
 8005c1a:	f003 fc31 	bl	8009480 <test_printn>
    test_println(" bytes");
 8005c1e:	4620      	mov	r0, r4
 8005c20:	f003 fbf6 	bl	8009410 <test_println>
  }

  /* [12.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8005c24:	2303      	movs	r3, #3
  {
    test_print("--- Timer : ");
 8005c26:	482b      	ldr	r0, [pc, #172]	; (8005cd4 <test_012_012_execute.lto_priv.259+0xe4>)
  test_set_step(3);
 8005c28:	602b      	str	r3, [r5, #0]
    test_print("--- Timer : ");
 8005c2a:	f003 fc11 	bl	8009450 <test_print>
    test_printn(sizeof(virtual_timer_t));
 8005c2e:	2014      	movs	r0, #20
 8005c30:	f003 fc26 	bl	8009480 <test_printn>
    test_println(" bytes");
 8005c34:	4620      	mov	r0, r4
 8005c36:	f003 fbeb 	bl	8009410 <test_println>
  }

  /* [12.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8005c3a:	2604      	movs	r6, #4
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 8005c3c:	4826      	ldr	r0, [pc, #152]	; (8005cd8 <test_012_012_execute.lto_priv.259+0xe8>)
  test_set_step(4);
 8005c3e:	602e      	str	r6, [r5, #0]
    test_print("--- Semaph: ");
 8005c40:	f003 fc06 	bl	8009450 <test_print>
    test_printn(sizeof(semaphore_t));
 8005c44:	200c      	movs	r0, #12
 8005c46:	f003 fc1b 	bl	8009480 <test_printn>
    test_println(" bytes");
 8005c4a:	4620      	mov	r0, r4
 8005c4c:	f003 fbe0 	bl	8009410 <test_println>
#endif
  }

  /* [12.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 8005c50:	2305      	movs	r3, #5
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 8005c52:	4822      	ldr	r0, [pc, #136]	; (8005cdc <test_012_012_execute.lto_priv.259+0xec>)
  test_set_step(5);
 8005c54:	602b      	str	r3, [r5, #0]
    test_print("--- Mutex : ");
 8005c56:	f003 fbfb 	bl	8009450 <test_print>
    test_printn(sizeof(mutex_t));
 8005c5a:	2010      	movs	r0, #16
 8005c5c:	f003 fc10 	bl	8009480 <test_printn>
    test_println(" bytes");
 8005c60:	4620      	mov	r0, r4
 8005c62:	f003 fbd5 	bl	8009410 <test_println>
#endif
  }

  /* [12.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8005c66:	2306      	movs	r3, #6
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 8005c68:	481d      	ldr	r0, [pc, #116]	; (8005ce0 <test_012_012_execute.lto_priv.259+0xf0>)
  test_set_step(6);
 8005c6a:	602b      	str	r3, [r5, #0]
    test_print("--- CondV.: ");
 8005c6c:	f003 fbf0 	bl	8009450 <test_print>
    test_printn(sizeof(condition_variable_t));
 8005c70:	2008      	movs	r0, #8
 8005c72:	f003 fc05 	bl	8009480 <test_printn>
    test_println(" bytes");
 8005c76:	4620      	mov	r0, r4
 8005c78:	f003 fbca 	bl	8009410 <test_println>
#endif
  }

  /* [12.12.7] The size of an event source is printed.*/
  test_set_step(7);
 8005c7c:	2307      	movs	r3, #7
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 8005c7e:	4819      	ldr	r0, [pc, #100]	; (8005ce4 <test_012_012_execute.lto_priv.259+0xf4>)
  test_set_step(7);
 8005c80:	602b      	str	r3, [r5, #0]
    test_print("--- EventS: ");
 8005c82:	f003 fbe5 	bl	8009450 <test_print>
    test_printn(sizeof(event_source_t));
 8005c86:	4630      	mov	r0, r6
 8005c88:	f003 fbfa 	bl	8009480 <test_printn>
    test_println(" bytes");
 8005c8c:	4620      	mov	r0, r4
 8005c8e:	f003 fbbf 	bl	8009410 <test_println>
#endif
  }

  /* [12.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 8005c92:	2308      	movs	r3, #8
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8005c94:	4814      	ldr	r0, [pc, #80]	; (8005ce8 <test_012_012_execute.lto_priv.259+0xf8>)
  test_set_step(8);
 8005c96:	602b      	str	r3, [r5, #0]
    test_print("--- EventL: ");
 8005c98:	f003 fbda 	bl	8009450 <test_print>
    test_printn(sizeof(event_listener_t));
 8005c9c:	2014      	movs	r0, #20
 8005c9e:	f003 fbef 	bl	8009480 <test_printn>
    test_println(" bytes");
 8005ca2:	4620      	mov	r0, r4
 8005ca4:	f003 fbb4 	bl	8009410 <test_println>
#endif
  }

  /* [12.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 8005ca8:	2309      	movs	r3, #9
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 8005caa:	4810      	ldr	r0, [pc, #64]	; (8005cec <test_012_012_execute.lto_priv.259+0xfc>)
  test_set_step(9);
 8005cac:	602b      	str	r3, [r5, #0]
    test_print("--- MailB.: ");
 8005cae:	f003 fbcf 	bl	8009450 <test_print>
    test_printn(sizeof(mailbox_t));
 8005cb2:	2028      	movs	r0, #40	; 0x28
 8005cb4:	f003 fbe4 	bl	8009480 <test_printn>
    test_println(" bytes");
 8005cb8:	4620      	mov	r0, r4
#endif
  }
}
 8005cba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_println(" bytes");
 8005cbe:	f003 bba7 	b.w	8009410 <test_println>
 8005cc2:	bf00      	nop
 8005cc4:	20001df8 	.word	0x20001df8
 8005cc8:	0800b3bc 	.word	0x0800b3bc
 8005ccc:	0800b3ac 	.word	0x0800b3ac
 8005cd0:	0800b3c4 	.word	0x0800b3c4
 8005cd4:	0800b3d4 	.word	0x0800b3d4
 8005cd8:	0800b3e4 	.word	0x0800b3e4
 8005cdc:	0800b3f4 	.word	0x0800b3f4
 8005ce0:	0800b404 	.word	0x0800b404
 8005ce4:	0800b414 	.word	0x0800b414
 8005ce8:	0800b424 	.word	0x0800b424
 8005cec:	0800b434 	.word	0x0800b434

08005cf0 <test_012_011_execute.lto_priv.258>:
static void test_012_011_execute(void) {
 8005cf0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
 8005cf4:	f8df 9080 	ldr.w	r9, [pc, #128]	; 8005d78 <test_012_011_execute.lto_priv.258+0x88>
      chMtxLock(&mtx1);
 8005cf8:	4c1c      	ldr	r4, [pc, #112]	; (8005d6c <test_012_011_execute.lto_priv.258+0x7c>)
  test_set_step(1);
 8005cfa:	2301      	movs	r3, #1
 8005cfc:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 8005d00:	f003 fa76 	bl	80091f0 <test_wait_tick>
    n = 0;
 8005d04:	2500      	movs	r5, #0
    start = test_wait_tick();
 8005d06:	4680      	mov	r8, r0
 8005d08:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 8005d0c:	f242 760f 	movw	r6, #9999	; 0x270f
      chMtxLock(&mtx1);
 8005d10:	4620      	mov	r0, r4
 8005d12:	f7fb fc5d 	bl	80015d0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8005d16:	4620      	mov	r0, r4
 8005d18:	f7fb fbfa 	bl	8001510 <chMtxUnlock>
      chMtxLock(&mtx1);
 8005d1c:	4620      	mov	r0, r4
 8005d1e:	f7fb fc57 	bl	80015d0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8005d22:	4620      	mov	r0, r4
 8005d24:	f7fb fbf4 	bl	8001510 <chMtxUnlock>
      chMtxLock(&mtx1);
 8005d28:	4620      	mov	r0, r4
 8005d2a:	f7fb fc51 	bl	80015d0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8005d2e:	4620      	mov	r0, r4
 8005d30:	f7fb fbee 	bl	8001510 <chMtxUnlock>
      chMtxLock(&mtx1);
 8005d34:	4620      	mov	r0, r4
 8005d36:	f7fb fc4b 	bl	80015d0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8005d3a:	4620      	mov	r0, r4
 8005d3c:	f7fb fbe8 	bl	8001510 <chMtxUnlock>
 8005d40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005d42:	eba3 0308 	sub.w	r3, r3, r8
    } while (chVTIsSystemTimeWithinX(start, end));
 8005d46:	42b3      	cmp	r3, r6
      n++;
 8005d48:	f105 0501 	add.w	r5, r5, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8005d4c:	d9e0      	bls.n	8005d10 <test_012_011_execute.lto_priv.258+0x20>
  test_set_step(2);
 8005d4e:	2302      	movs	r3, #2
    test_print("--- Score : ");
 8005d50:	4807      	ldr	r0, [pc, #28]	; (8005d70 <test_012_011_execute.lto_priv.258+0x80>)
  test_set_step(2);
 8005d52:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8005d56:	f003 fb7b 	bl	8009450 <test_print>
    test_printn(n * 4);
 8005d5a:	00a8      	lsls	r0, r5, #2
 8005d5c:	f003 fb90 	bl	8009480 <test_printn>
    test_println(" lock+unlock/S");
 8005d60:	4804      	ldr	r0, [pc, #16]	; (8005d74 <test_012_011_execute.lto_priv.258+0x84>)
}
 8005d62:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" lock+unlock/S");
 8005d66:	f003 bb53 	b.w	8009410 <test_println>
 8005d6a:	bf00      	nop
 8005d6c:	20001ddc 	.word	0x20001ddc
 8005d70:	0800ac3c 	.word	0x0800ac3c
 8005d74:	0800b39c 	.word	0x0800b39c
 8005d78:	20001df8 	.word	0x20001df8
 8005d7c:	00000000 	.word	0x00000000

08005d80 <test_012_011_setup.lto_priv.257>:
  tqp->next = (thread_t *)tqp;
 8005d80:	4b02      	ldr	r3, [pc, #8]	; (8005d8c <test_012_011_setup.lto_priv.257+0xc>)
  mp->owner = NULL;
 8005d82:	2200      	movs	r2, #0
 8005d84:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8005d86:	605b      	str	r3, [r3, #4]
 8005d88:	609a      	str	r2, [r3, #8]
 8005d8a:	4770      	bx	lr
 8005d8c:	20001ddc 	.word	0x20001ddc

08005d90 <test_012_010_setup.lto_priv.255>:
  tqp->next = (thread_t *)tqp;
 8005d90:	4b02      	ldr	r3, [pc, #8]	; (8005d9c <test_012_010_setup.lto_priv.255+0xc>)
 8005d92:	2201      	movs	r2, #1
 8005d94:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8005d96:	605b      	str	r3, [r3, #4]
 8005d98:	609a      	str	r2, [r3, #8]
 8005d9a:	4770      	bx	lr
 8005d9c:	20001dec 	.word	0x20001dec

08005da0 <test_012_010_execute.lto_priv.256>:
static void test_012_010_execute(void) {
 8005da0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
 8005da4:	f8df 9080 	ldr.w	r9, [pc, #128]	; 8005e28 <test_012_010_execute.lto_priv.256+0x88>
      chSemWait(&sem1);
 8005da8:	4c1c      	ldr	r4, [pc, #112]	; (8005e1c <test_012_010_execute.lto_priv.256+0x7c>)
  test_set_step(1);
 8005daa:	2301      	movs	r3, #1
 8005dac:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 8005db0:	f003 fa1e 	bl	80091f0 <test_wait_tick>
    n = 0;
 8005db4:	2500      	movs	r5, #0
    start = test_wait_tick();
 8005db6:	4680      	mov	r8, r0
 8005db8:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 8005dbc:	f242 760f 	movw	r6, #9999	; 0x270f
      chSemWait(&sem1);
 8005dc0:	4620      	mov	r0, r4
 8005dc2:	f7fb fc5d 	bl	8001680 <chSemWait>
      chSemSignal(&sem1);
 8005dc6:	4620      	mov	r0, r4
 8005dc8:	f7fb fc22 	bl	8001610 <chSemSignal>
      chSemWait(&sem1);
 8005dcc:	4620      	mov	r0, r4
 8005dce:	f7fb fc57 	bl	8001680 <chSemWait>
      chSemSignal(&sem1);
 8005dd2:	4620      	mov	r0, r4
 8005dd4:	f7fb fc1c 	bl	8001610 <chSemSignal>
      chSemWait(&sem1);
 8005dd8:	4620      	mov	r0, r4
 8005dda:	f7fb fc51 	bl	8001680 <chSemWait>
      chSemSignal(&sem1);
 8005dde:	4620      	mov	r0, r4
 8005de0:	f7fb fc16 	bl	8001610 <chSemSignal>
      chSemWait(&sem1);
 8005de4:	4620      	mov	r0, r4
 8005de6:	f7fb fc4b 	bl	8001680 <chSemWait>
      chSemSignal(&sem1);
 8005dea:	4620      	mov	r0, r4
 8005dec:	f7fb fc10 	bl	8001610 <chSemSignal>
 8005df0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005df2:	eba3 0308 	sub.w	r3, r3, r8
    } while (chVTIsSystemTimeWithinX(start, end));
 8005df6:	42b3      	cmp	r3, r6
      n++;
 8005df8:	f105 0501 	add.w	r5, r5, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8005dfc:	d9e0      	bls.n	8005dc0 <test_012_010_execute.lto_priv.256+0x20>
  test_set_step(2);
 8005dfe:	2302      	movs	r3, #2
    test_print("--- Score : ");
 8005e00:	4807      	ldr	r0, [pc, #28]	; (8005e20 <test_012_010_execute.lto_priv.256+0x80>)
  test_set_step(2);
 8005e02:	f8c9 3000 	str.w	r3, [r9]
    test_print("--- Score : ");
 8005e06:	f003 fb23 	bl	8009450 <test_print>
    test_printn(n * 4);
 8005e0a:	00a8      	lsls	r0, r5, #2
 8005e0c:	f003 fb38 	bl	8009480 <test_printn>
    test_println(" wait+signal/S");
 8005e10:	4804      	ldr	r0, [pc, #16]	; (8005e24 <test_012_010_execute.lto_priv.256+0x84>)
}
 8005e12:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    test_println(" wait+signal/S");
 8005e16:	f003 bafb 	b.w	8009410 <test_println>
 8005e1a:	bf00      	nop
 8005e1c:	20001dec 	.word	0x20001dec
 8005e20:	0800ac3c 	.word	0x0800ac3c
 8005e24:	0800b38c 	.word	0x0800b38c
 8005e28:	20001df8 	.word	0x20001df8
 8005e2c:	00000000 	.word	0x00000000

08005e30 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8005e30:	b40e      	push	{r1, r2, r3}
 8005e32:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005e36:	b086      	sub	sp, #24
 8005e38:	af0f      	add	r7, sp, #60	; 0x3c
  int n = 0;
 8005e3a:	2300      	movs	r3, #0
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8005e3c:	f857 6b04 	ldr.w	r6, [r7], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8005e40:	9702      	str	r7, [sp, #8]
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8005e42:	4605      	mov	r5, r0
  q = p + MAX_FILLER;
 8005e44:	469a      	mov	sl, r3
    c = *fmt++;
 8005e46:	7831      	ldrb	r1, [r6, #0]
 8005e48:	1c73      	adds	r3, r6, #1
    if (c == 0)
 8005e4a:	b161      	cbz	r1, 8005e66 <chprintf+0x36>
    if (c != '%') {
 8005e4c:	2925      	cmp	r1, #37	; 0x25
 8005e4e:	d010      	beq.n	8005e72 <chprintf+0x42>
      streamPut(chp, (uint8_t)c);
 8005e50:	682a      	ldr	r2, [r5, #0]
    c = *fmt++;
 8005e52:	461e      	mov	r6, r3
      streamPut(chp, (uint8_t)c);
 8005e54:	6892      	ldr	r2, [r2, #8]
 8005e56:	4628      	mov	r0, r5
 8005e58:	4790      	blx	r2
    c = *fmt++;
 8005e5a:	7831      	ldrb	r1, [r6, #0]
      n++;
 8005e5c:	f10a 0a01 	add.w	sl, sl, #1
    c = *fmt++;
 8005e60:	1c73      	adds	r3, r6, #1
    if (c == 0)
 8005e62:	2900      	cmp	r1, #0
 8005e64:	d1f2      	bne.n	8005e4c <chprintf+0x1c>
 8005e66:	4650      	mov	r0, sl
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8005e68:	b006      	add	sp, #24
 8005e6a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005e6e:	b003      	add	sp, #12
 8005e70:	4770      	bx	lr
    if (*fmt == '-') {
 8005e72:	7872      	ldrb	r2, [r6, #1]
 8005e74:	2a2d      	cmp	r2, #45	; 0x2d
 8005e76:	bf03      	ittte	eq
 8005e78:	78b2      	ldrbeq	r2, [r6, #2]
      fmt++;
 8005e7a:	1cb3      	addeq	r3, r6, #2
      left_align = TRUE;
 8005e7c:	f04f 0c01 	moveq.w	ip, #1
    left_align = FALSE;
 8005e80:	f04f 0c00 	movne.w	ip, #0
    if (*fmt == '0') {
 8005e84:	2a30      	cmp	r2, #48	; 0x30
 8005e86:	bf03      	ittte	eq
 8005e88:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 8005e8a:	3301      	addeq	r3, #1
      filler = '0';
 8005e8c:	f04f 0930 	moveq.w	r9, #48	; 0x30
    filler = ' ';
 8005e90:	f04f 0920 	movne.w	r9, #32
 8005e94:	1c59      	adds	r1, r3, #1
    width = 0;
 8005e96:	2400      	movs	r4, #0
 8005e98:	e005      	b.n	8005ea6 <chprintf+0x76>
        c = va_arg(ap, int);
 8005e9a:	783b      	ldrb	r3, [r7, #0]
 8005e9c:	3704      	adds	r7, #4
 8005e9e:	f811 2b01 	ldrb.w	r2, [r1], #1
      width = width * 10 + c;
 8005ea2:	eb03 0440 	add.w	r4, r3, r0, lsl #1
      if (c >= '0' && c <= '9')
 8005ea6:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8005eaa:	b2db      	uxtb	r3, r3
 8005eac:	2b09      	cmp	r3, #9
      c = *fmt++;
 8005eae:	460e      	mov	r6, r1
      width = width * 10 + c;
 8005eb0:	eb04 0084 	add.w	r0, r4, r4, lsl #2
      if (c >= '0' && c <= '9')
 8005eb4:	d9f3      	bls.n	8005e9e <chprintf+0x6e>
      else if (c == '*')
 8005eb6:	2a2a      	cmp	r2, #42	; 0x2a
 8005eb8:	d0ef      	beq.n	8005e9a <chprintf+0x6a>
    if (c == '.') {
 8005eba:	2a2e      	cmp	r2, #46	; 0x2e
 8005ebc:	f04f 0100 	mov.w	r1, #0
 8005ec0:	d043      	beq.n	8005f4a <chprintf+0x11a>
    if (c == 'l' || c == 'L') {
 8005ec2:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8005ec6:	2b4c      	cmp	r3, #76	; 0x4c
 8005ec8:	d04e      	beq.n	8005f68 <chprintf+0x138>
    switch (c) {
 8005eca:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 8005ece:	2834      	cmp	r0, #52	; 0x34
 8005ed0:	f200 814e 	bhi.w	8006170 <chprintf+0x340>
 8005ed4:	e8df f010 	tbh	[pc, r0, lsl #1]
 8005ed8:	014c00fb 	.word	0x014c00fb
 8005edc:	014c014c 	.word	0x014c014c
 8005ee0:	00fb014c 	.word	0x00fb014c
 8005ee4:	014c014c 	.word	0x014c014c
 8005ee8:	014c014c 	.word	0x014c014c
 8005eec:	00f5014c 	.word	0x00f5014c
 8005ef0:	014c014c 	.word	0x014c014c
 8005ef4:	014c014c 	.word	0x014c014c
 8005ef8:	0088014c 	.word	0x0088014c
 8005efc:	014c014c 	.word	0x014c014c
 8005f00:	014c00f8 	.word	0x014c00f8
 8005f04:	014c014c 	.word	0x014c014c
 8005f08:	014c014c 	.word	0x014c014c
 8005f0c:	014c014c 	.word	0x014c014c
 8005f10:	014c014c 	.word	0x014c014c
 8005f14:	0140014c 	.word	0x0140014c
 8005f18:	014c00fb 	.word	0x014c00fb
 8005f1c:	014c014c 	.word	0x014c014c
 8005f20:	00fb014c 	.word	0x00fb014c
 8005f24:	014c014c 	.word	0x014c014c
 8005f28:	014c014c 	.word	0x014c014c
 8005f2c:	00f5014c 	.word	0x00f5014c
 8005f30:	014c014c 	.word	0x014c014c
 8005f34:	0126014c 	.word	0x0126014c
 8005f38:	0088014c 	.word	0x0088014c
 8005f3c:	014c014c 	.word	0x014c014c
 8005f40:	00f8      	.short	0x00f8
          c = va_arg(ap, int);
 8005f42:	783b      	ldrb	r3, [r7, #0]
 8005f44:	3704      	adds	r7, #4
        precision += c;
 8005f46:	eb03 0140 	add.w	r1, r3, r0, lsl #1
        c = *fmt++;
 8005f4a:	f816 2b01 	ldrb.w	r2, [r6], #1
        if (c >= '0' && c <= '9')
 8005f4e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8005f52:	b2db      	uxtb	r3, r3
 8005f54:	2b09      	cmp	r3, #9
        precision *= 10;
 8005f56:	eb01 0081 	add.w	r0, r1, r1, lsl #2
        if (c >= '0' && c <= '9')
 8005f5a:	d9f4      	bls.n	8005f46 <chprintf+0x116>
        else if (c == '*')
 8005f5c:	2a2a      	cmp	r2, #42	; 0x2a
 8005f5e:	d0f0      	beq.n	8005f42 <chprintf+0x112>
    if (c == 'l' || c == 'L') {
 8005f60:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8005f64:	2b4c      	cmp	r3, #76	; 0x4c
 8005f66:	d1b0      	bne.n	8005eca <chprintf+0x9a>
      if (*fmt)
 8005f68:	7833      	ldrb	r3, [r6, #0]
 8005f6a:	b10b      	cbz	r3, 8005f70 <chprintf+0x140>
        c = *fmt++;
 8005f6c:	3601      	adds	r6, #1
 8005f6e:	461a      	mov	r2, r3
    switch (c) {
 8005f70:	f1a2 0344 	sub.w	r3, r2, #68	; 0x44
 8005f74:	2b34      	cmp	r3, #52	; 0x34
 8005f76:	f200 80fb 	bhi.w	8006170 <chprintf+0x340>
 8005f7a:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005f7e:	00a8      	.short	0x00a8
 8005f80:	00f900f9 	.word	0x00f900f9
 8005f84:	00f900f9 	.word	0x00f900f9
 8005f88:	00f900a8 	.word	0x00f900a8
 8005f8c:	00f900f9 	.word	0x00f900f9
 8005f90:	00f900f9 	.word	0x00f900f9
 8005f94:	00f900a2 	.word	0x00f900a2
 8005f98:	00f900f9 	.word	0x00f900f9
 8005f9c:	00f900f9 	.word	0x00f900f9
 8005fa0:	00f90035 	.word	0x00f90035
 8005fa4:	00a500f9 	.word	0x00a500f9
 8005fa8:	00f900f9 	.word	0x00f900f9
 8005fac:	00f900f9 	.word	0x00f900f9
 8005fb0:	00f900f9 	.word	0x00f900f9
 8005fb4:	00f900f9 	.word	0x00f900f9
 8005fb8:	00f900f9 	.word	0x00f900f9
 8005fbc:	00a800ed 	.word	0x00a800ed
 8005fc0:	00f900f9 	.word	0x00f900f9
 8005fc4:	00f900f9 	.word	0x00f900f9
 8005fc8:	00f900a8 	.word	0x00f900a8
 8005fcc:	00f900f9 	.word	0x00f900f9
 8005fd0:	00f900f9 	.word	0x00f900f9
 8005fd4:	00f900a2 	.word	0x00f900a2
 8005fd8:	00f900f9 	.word	0x00f900f9
 8005fdc:	00f900d3 	.word	0x00f900d3
 8005fe0:	00f90035 	.word	0x00f90035
 8005fe4:	00a500f9 	.word	0x00a500f9
 8005fe8:	f04f 080a 	mov.w	r8, #10
        l = va_arg(ap, unsigned int);
 8005fec:	683a      	ldr	r2, [r7, #0]
  q = p + MAX_FILLER;
 8005fee:	f10d 0117 	add.w	r1, sp, #23
        l = va_arg(ap, unsigned int);
 8005ff2:	3704      	adds	r7, #4
 8005ff4:	e000      	b.n	8005ff8 <chprintf+0x1c8>
  } while ((ll /= radix) != 0);
 8005ff6:	4601      	mov	r1, r0
    i = (int)(l % radix);
 8005ff8:	fbb2 fef8 	udiv	lr, r2, r8
 8005ffc:	fb08 221e 	mls	r2, r8, lr, r2
    i += '0';
 8006000:	f102 0330 	add.w	r3, r2, #48	; 0x30
    if (i > '9')
 8006004:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8006006:	bfc8      	it	gt
 8006008:	f102 0337 	addgt.w	r3, r2, #55	; 0x37
    *--q = i;
 800600c:	b2db      	uxtb	r3, r3
    l /= radix;
 800600e:	4672      	mov	r2, lr
    *--q = i;
 8006010:	f801 3c01 	strb.w	r3, [r1, #-1]
 8006014:	1e48      	subs	r0, r1, #1
  } while ((ll /= radix) != 0);
 8006016:	2a00      	cmp	r2, #0
 8006018:	d1ed      	bne.n	8005ff6 <chprintf+0x1c6>
  i = (int)(p + MAX_FILLER - q);
 800601a:	f10d 0217 	add.w	r2, sp, #23
 800601e:	f10d 080c 	add.w	r8, sp, #12
 8006022:	1a12      	subs	r2, r2, r0
 8006024:	46c6      	mov	lr, r8
 8006026:	4410      	add	r0, r2
 8006028:	e001      	b.n	800602e <chprintf+0x1fe>
 800602a:	f811 3b01 	ldrb.w	r3, [r1], #1
    *p++ = *q++;
 800602e:	f80e 3b01 	strb.w	r3, [lr], #1
  while (--i);
 8006032:	4288      	cmp	r0, r1
 8006034:	d1f9      	bne.n	800602a <chprintf+0x1fa>
 8006036:	1e53      	subs	r3, r2, #1
 8006038:	9301      	str	r3, [sp, #4]
    if ((width -= i) < 0)
 800603a:	1aa4      	subs	r4, r4, r2
 800603c:	d43b      	bmi.n	80060b6 <chprintf+0x286>
    if (left_align == FALSE)
 800603e:	f1bc 0f00 	cmp.w	ip, #0
 8006042:	f040 809e 	bne.w	8006182 <chprintf+0x352>
 8006046:	f1c4 0b00 	rsb	fp, r4, #0
    if (width < 0) {
 800604a:	2c00      	cmp	r4, #0
 800604c:	f000 8098 	beq.w	8006180 <chprintf+0x350>
      if (*s == '-' && filler == '0') {
 8006050:	f898 1000 	ldrb.w	r1, [r8]
 8006054:	292d      	cmp	r1, #45	; 0x2d
 8006056:	f000 80a3 	beq.w	80061a0 <chprintf+0x370>
        streamPut(chp, (uint8_t)filler);
 800605a:	682b      	ldr	r3, [r5, #0]
 800605c:	4649      	mov	r1, r9
 800605e:	689b      	ldr	r3, [r3, #8]
 8006060:	4628      	mov	r0, r5
 8006062:	4798      	blx	r3
      } while (++width != 0);
 8006064:	f11b 0b01 	adds.w	fp, fp, #1
 8006068:	d1f7      	bne.n	800605a <chprintf+0x22a>
    while (--i >= 0) {
 800606a:	9b01      	ldr	r3, [sp, #4]
 800606c:	2b00      	cmp	r3, #0
 800606e:	44a2      	add	sl, r4
 8006070:	bfa8      	it	ge
 8006072:	465c      	movge	r4, fp
 8006074:	f6ff aee7 	blt.w	8005e46 <chprintf+0x16>
 8006078:	f8dd b004 	ldr.w	fp, [sp, #4]
      streamPut(chp, (uint8_t)*s++);
 800607c:	682b      	ldr	r3, [r5, #0]
 800607e:	f818 1b01 	ldrb.w	r1, [r8], #1
 8006082:	689b      	ldr	r3, [r3, #8]
    while (--i >= 0) {
 8006084:	f10b 3bff 	add.w	fp, fp, #4294967295
      streamPut(chp, (uint8_t)*s++);
 8006088:	4628      	mov	r0, r5
 800608a:	4798      	blx	r3
    while (--i >= 0) {
 800608c:	f1bb 3fff 	cmp.w	fp, #4294967295
 8006090:	d1f4      	bne.n	800607c <chprintf+0x24c>
 8006092:	9b01      	ldr	r3, [sp, #4]
 8006094:	f10a 0a01 	add.w	sl, sl, #1
 8006098:	449a      	add	sl, r3
    while (width) {
 800609a:	2c00      	cmp	r4, #0
 800609c:	f43f aed3 	beq.w	8005e46 <chprintf+0x16>
 80060a0:	46a0      	mov	r8, r4
      streamPut(chp, (uint8_t)filler);
 80060a2:	682b      	ldr	r3, [r5, #0]
 80060a4:	4649      	mov	r1, r9
 80060a6:	689b      	ldr	r3, [r3, #8]
 80060a8:	4628      	mov	r0, r5
 80060aa:	4798      	blx	r3
    while (width) {
 80060ac:	f1b8 0801 	subs.w	r8, r8, #1
 80060b0:	d1f7      	bne.n	80060a2 <chprintf+0x272>
 80060b2:	44a2      	add	sl, r4
 80060b4:	e6c7      	b.n	8005e46 <chprintf+0x16>
    while (--i >= 0) {
 80060b6:	9b01      	ldr	r3, [sp, #4]
 80060b8:	2b00      	cmp	r3, #0
      width = 0;
 80060ba:	bfa8      	it	ge
 80060bc:	2400      	movge	r4, #0
    while (--i >= 0) {
 80060be:	dadb      	bge.n	8006078 <chprintf+0x248>
 80060c0:	e6c1      	b.n	8005e46 <chprintf+0x16>
    switch (c) {
 80060c2:	f04f 0808 	mov.w	r8, #8
 80060c6:	e791      	b.n	8005fec <chprintf+0x1bc>
 80060c8:	f04f 0810 	mov.w	r8, #16
 80060cc:	e78e      	b.n	8005fec <chprintf+0x1bc>
        l = va_arg(ap, int);
 80060ce:	6839      	ldr	r1, [r7, #0]
      if (l < 0) {
 80060d0:	2900      	cmp	r1, #0
        l = va_arg(ap, int);
 80060d2:	f107 0704 	add.w	r7, r7, #4
      if (l < 0) {
 80060d6:	db73      	blt.n	80061c0 <chprintf+0x390>
    p = tmpbuf;
 80060d8:	f10d 080c 	add.w	r8, sp, #12
 80060dc:	4642      	mov	r2, r8
  q = p + MAX_FILLER;
 80060de:	f102 030b 	add.w	r3, r2, #11
 80060e2:	9301      	str	r3, [sp, #4]
 80060e4:	4618      	mov	r0, r3
    i = (int)(l % radix);
 80060e6:	4b3e      	ldr	r3, [pc, #248]	; (80061e0 <chprintf+0x3b0>)
 80060e8:	fba3 e301 	umull	lr, r3, r3, r1
 80060ec:	08db      	lsrs	r3, r3, #3
 80060ee:	eb03 0b83 	add.w	fp, r3, r3, lsl #2
 80060f2:	469e      	mov	lr, r3
 80060f4:	eba1 034b 	sub.w	r3, r1, fp, lsl #1
    i += '0';
 80060f8:	3330      	adds	r3, #48	; 0x30
    *--q = i;
 80060fa:	b2db      	uxtb	r3, r3
  } while ((ll /= radix) != 0);
 80060fc:	4671      	mov	r1, lr
    *--q = i;
 80060fe:	f800 3d01 	strb.w	r3, [r0, #-1]!
  } while ((ll /= radix) != 0);
 8006102:	2900      	cmp	r1, #0
 8006104:	d1ef      	bne.n	80060e6 <chprintf+0x2b6>
  i = (int)(p + MAX_FILLER - q);
 8006106:	9901      	ldr	r1, [sp, #4]
 8006108:	1a09      	subs	r1, r1, r0
 800610a:	4411      	add	r1, r2
 800610c:	e001      	b.n	8006112 <chprintf+0x2e2>
 800610e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    *p++ = *q++;
 8006112:	f802 3b01 	strb.w	r3, [r2], #1
  while (--i);
 8006116:	428a      	cmp	r2, r1
 8006118:	d1f9      	bne.n	800610e <chprintf+0x2de>
 800611a:	eba2 0208 	sub.w	r2, r2, r8
 800611e:	1e53      	subs	r3, r2, #1
 8006120:	9301      	str	r3, [sp, #4]
 8006122:	e78a      	b.n	800603a <chprintf+0x20a>
      if ((s = va_arg(ap, char *)) == 0)
 8006124:	f8d7 8000 	ldr.w	r8, [r7]
 8006128:	3704      	adds	r7, #4
 800612a:	f1b8 0f00 	cmp.w	r8, #0
 800612e:	d050      	beq.n	80061d2 <chprintf+0x3a2>
      for (p = s; *p && (--precision >= 0); p++)
 8006130:	f898 3000 	ldrb.w	r3, [r8]
      if (precision == 0)
 8006134:	b351      	cbz	r1, 800618c <chprintf+0x35c>
      for (p = s; *p && (--precision >= 0); p++)
 8006136:	b36b      	cbz	r3, 8006194 <chprintf+0x364>
 8006138:	3901      	subs	r1, #1
 800613a:	4642      	mov	r2, r8
 800613c:	e001      	b.n	8006142 <chprintf+0x312>
 800613e:	3901      	subs	r1, #1
 8006140:	d403      	bmi.n	800614a <chprintf+0x31a>
 8006142:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8006146:	2b00      	cmp	r3, #0
 8006148:	d1f9      	bne.n	800613e <chprintf+0x30e>
 800614a:	eba2 0208 	sub.w	r2, r2, r8
 800614e:	1e53      	subs	r3, r2, #1
 8006150:	9301      	str	r3, [sp, #4]
      filler = ' ';
 8006152:	f04f 0920 	mov.w	r9, #32
 8006156:	e770      	b.n	800603a <chprintf+0x20a>
      *p++ = va_arg(ap, int);
 8006158:	f10d 0818 	add.w	r8, sp, #24
 800615c:	683b      	ldr	r3, [r7, #0]
 800615e:	f808 3d0c 	strb.w	r3, [r8, #-12]!
 8006162:	2300      	movs	r3, #0
 8006164:	3704      	adds	r7, #4
 8006166:	9301      	str	r3, [sp, #4]
 8006168:	2201      	movs	r2, #1
      filler = ' ';
 800616a:	f04f 0920 	mov.w	r9, #32
 800616e:	e764      	b.n	800603a <chprintf+0x20a>
      *p++ = c;
 8006170:	f10d 0818 	add.w	r8, sp, #24
 8006174:	2300      	movs	r3, #0
 8006176:	f808 2d0c 	strb.w	r2, [r8, #-12]!
 800617a:	9301      	str	r3, [sp, #4]
 800617c:	2201      	movs	r2, #1
 800617e:	e75c      	b.n	800603a <chprintf+0x20a>
    if (width < 0) {
 8006180:	465c      	mov	r4, fp
    while (--i >= 0) {
 8006182:	9b01      	ldr	r3, [sp, #4]
 8006184:	2b00      	cmp	r3, #0
 8006186:	f6bf af77 	bge.w	8006078 <chprintf+0x248>
 800618a:	e786      	b.n	800609a <chprintf+0x26a>
      for (p = s; *p && (--precision >= 0); p++)
 800618c:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 8006190:	2b00      	cmp	r3, #0
 8006192:	d1d2      	bne.n	800613a <chprintf+0x30a>
 8006194:	f04f 33ff 	mov.w	r3, #4294967295
 8006198:	9301      	str	r3, [sp, #4]
 800619a:	f04f 0920 	mov.w	r9, #32
 800619e:	e74e      	b.n	800603e <chprintf+0x20e>
      if (*s == '-' && filler == '0') {
 80061a0:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
 80061a4:	f47f af59 	bne.w	800605a <chprintf+0x22a>
        streamPut(chp, (uint8_t)*s++);
 80061a8:	682a      	ldr	r2, [r5, #0]
 80061aa:	4628      	mov	r0, r5
 80061ac:	6892      	ldr	r2, [r2, #8]
 80061ae:	4790      	blx	r2
 80061b0:	9b01      	ldr	r3, [sp, #4]
 80061b2:	3b01      	subs	r3, #1
 80061b4:	f108 0801 	add.w	r8, r8, #1
        n++;
 80061b8:	f10a 0a01 	add.w	sl, sl, #1
 80061bc:	9301      	str	r3, [sp, #4]
 80061be:	e74c      	b.n	800605a <chprintf+0x22a>
        *p++ = '-';
 80061c0:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 80061c2:	4249      	negs	r1, r1
        *p++ = '-';
 80061c4:	f88d 300c 	strb.w	r3, [sp, #12]
 80061c8:	f10d 020d 	add.w	r2, sp, #13
 80061cc:	f10d 080c 	add.w	r8, sp, #12
 80061d0:	e785      	b.n	80060de <chprintf+0x2ae>
        s = "(null)";
 80061d2:	f8df 8010 	ldr.w	r8, [pc, #16]	; 80061e4 <chprintf+0x3b4>
      if (precision == 0)
 80061d6:	2900      	cmp	r1, #0
 80061d8:	d1ae      	bne.n	8006138 <chprintf+0x308>
        precision = 32767;
 80061da:	f647 71ff 	movw	r1, #32767	; 0x7fff
 80061de:	e7ab      	b.n	8006138 <chprintf+0x308>
 80061e0:	cccccccd 	.word	0xcccccccd
 80061e4:	0800ae80 	.word	0x0800ae80
	...

080061f0 <cmd_broadbent>:

#if (SHELL_CMD_BROADBENT_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_broadbent(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 80061f0:	2900      	cmp	r1, #0
 80061f2:	dd03      	ble.n	80061fc <cmd_broadbent+0xc>
    shellUsage(chp, "test");
 80061f4:	4a03      	ldr	r2, [pc, #12]	; (8006204 <cmd_broadbent+0x14>)
 80061f6:	4904      	ldr	r1, [pc, #16]	; (8006208 <cmd_broadbent+0x18>)
 80061f8:	f7ff be1a 	b.w	8005e30 <chprintf>
    return;
  }

  chprintf(chp, "Are related to the ham people"SHELL_NEWLINE_STR);
 80061fc:	4903      	ldr	r1, [pc, #12]	; (800620c <cmd_broadbent+0x1c>)
 80061fe:	f7ff be17 	b.w	8005e30 <chprintf>
 8006202:	bf00      	nop
 8006204:	0800beec 	.word	0x0800beec
 8006208:	0800ae88 	.word	0x0800ae88
 800620c:	0800ae94 	.word	0x0800ae94

08006210 <cmd_test>:
  if (argc > 0) {
 8006210:	2900      	cmp	r1, #0
 8006212:	dd03      	ble.n	800621c <cmd_test+0xc>
    shellUsage(chp, "test");
 8006214:	4a0f      	ldr	r2, [pc, #60]	; (8006254 <cmd_test+0x44>)
 8006216:	4910      	ldr	r1, [pc, #64]	; (8006258 <cmd_test+0x48>)
 8006218:	f7ff be0a 	b.w	8005e30 <chprintf>
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 800621c:	b510      	push	{r4, lr}
  return ch.rlist.current;
 800621e:	4b0f      	ldr	r3, [pc, #60]	; (800625c <cmd_test+0x4c>)
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
 8006220:	490f      	ldr	r1, [pc, #60]	; (8006260 <cmd_test+0x50>)
  return chThdGetSelfX()->prio;
 8006222:	699b      	ldr	r3, [r3, #24]
 8006224:	4a0b      	ldr	r2, [pc, #44]	; (8006254 <cmd_test+0x44>)
 8006226:	689b      	ldr	r3, [r3, #8]
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8006228:	b082      	sub	sp, #8
 800622a:	4604      	mov	r4, r0
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
 800622c:	e88d 0012 	stmia.w	sp, {r1, r4}
 8006230:	2000      	movs	r0, #0
 8006232:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8006236:	f7fb f823 	bl	8001280 <chThdCreateFromHeap>
  if (tp == NULL) {
 800623a:	b120      	cbz	r0, 8006246 <cmd_test+0x36>
}
 800623c:	b002      	add	sp, #8
 800623e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdWait(tp);
 8006242:	f7fb bc25 	b.w	8001a90 <chThdWait>
    chprintf(chp, "out of memory"SHELL_NEWLINE_STR);
 8006246:	4907      	ldr	r1, [pc, #28]	; (8006264 <cmd_test+0x54>)
 8006248:	4620      	mov	r0, r4
}
 800624a:	b002      	add	sp, #8
 800624c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chprintf(chp, "out of memory"SHELL_NEWLINE_STR);
 8006250:	f7ff bdee 	b.w	8005e30 <chprintf>
 8006254:	0800beec 	.word	0x0800beec
 8006258:	0800ae88 	.word	0x0800ae88
 800625c:	20001e68 	.word	0x20001e68
 8006260:	080094e1 	.word	0x080094e1
 8006264:	0800b0f4 	.word	0x0800b0f4
	...

08006270 <cmd_mem>:
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8006270:	b530      	push	{r4, r5, lr}
  if (argc > 0) {
 8006272:	2900      	cmp	r1, #0
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8006274:	b083      	sub	sp, #12
  if (argc > 0) {
 8006276:	dd05      	ble.n	8006284 <cmd_mem+0x14>
    shellUsage(chp, "mem");
 8006278:	4a13      	ldr	r2, [pc, #76]	; (80062c8 <cmd_mem+0x58>)
 800627a:	4914      	ldr	r1, [pc, #80]	; (80062cc <cmd_mem+0x5c>)
 800627c:	f7ff fdd8 	bl	8005e30 <chprintf>
}
 8006280:	b003      	add	sp, #12
 8006282:	bd30      	pop	{r4, r5, pc}
 8006284:	4604      	mov	r4, r0
  n = chHeapStatus(NULL, &total, &largest);
 8006286:	aa01      	add	r2, sp, #4
 8006288:	4669      	mov	r1, sp
 800628a:	2000      	movs	r0, #0
 800628c:	f7fe fa88 	bl	80047a0 <chHeapStatus>
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 8006290:	4a0f      	ldr	r2, [pc, #60]	; (80062d0 <cmd_mem+0x60>)
 8006292:	4b10      	ldr	r3, [pc, #64]	; (80062d4 <cmd_mem+0x64>)
 8006294:	6812      	ldr	r2, [r2, #0]
 8006296:	681b      	ldr	r3, [r3, #0]
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
 8006298:	490f      	ldr	r1, [pc, #60]	; (80062d8 <cmd_mem+0x68>)
 800629a:	1ad2      	subs	r2, r2, r3
  n = chHeapStatus(NULL, &total, &largest);
 800629c:	4605      	mov	r5, r0
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
 800629e:	4620      	mov	r0, r4
 80062a0:	f7ff fdc6 	bl	8005e30 <chprintf>
  chprintf(chp, "heap fragments   : %u"SHELL_NEWLINE_STR, n);
 80062a4:	462a      	mov	r2, r5
 80062a6:	490d      	ldr	r1, [pc, #52]	; (80062dc <cmd_mem+0x6c>)
 80062a8:	4620      	mov	r0, r4
 80062aa:	f7ff fdc1 	bl	8005e30 <chprintf>
  chprintf(chp, "heap free total  : %u bytes"SHELL_NEWLINE_STR, total);
 80062ae:	9a00      	ldr	r2, [sp, #0]
 80062b0:	490b      	ldr	r1, [pc, #44]	; (80062e0 <cmd_mem+0x70>)
 80062b2:	4620      	mov	r0, r4
 80062b4:	f7ff fdbc 	bl	8005e30 <chprintf>
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
 80062b8:	4620      	mov	r0, r4
 80062ba:	9a01      	ldr	r2, [sp, #4]
 80062bc:	4909      	ldr	r1, [pc, #36]	; (80062e4 <cmd_mem+0x74>)
 80062be:	f7ff fdb7 	bl	8005e30 <chprintf>
}
 80062c2:	b003      	add	sp, #12
 80062c4:	bd30      	pop	{r4, r5, pc}
 80062c6:	bf00      	nop
 80062c8:	0800b068 	.word	0x0800b068
 80062cc:	0800ae88 	.word	0x0800ae88
 80062d0:	20001590 	.word	0x20001590
 80062d4:	20001594 	.word	0x20001594
 80062d8:	0800b06c 	.word	0x0800b06c
 80062dc:	0800b08c 	.word	0x0800b08c
 80062e0:	0800b0a4 	.word	0x0800b0a4
 80062e4:	0800b0c4 	.word	0x0800b0c4
	...

080062f0 <cmd_echo>:
  if (argc != 1) {
 80062f0:	2901      	cmp	r1, #1
 80062f2:	d003      	beq.n	80062fc <cmd_echo+0xc>
    shellUsage(chp, "echo \"message\"");
 80062f4:	4a03      	ldr	r2, [pc, #12]	; (8006304 <cmd_echo+0x14>)
 80062f6:	4904      	ldr	r1, [pc, #16]	; (8006308 <cmd_echo+0x18>)
 80062f8:	f7ff bd9a 	b.w	8005e30 <chprintf>
  chprintf(chp, "%s"SHELL_NEWLINE_STR, argv[0]);
 80062fc:	6812      	ldr	r2, [r2, #0]
 80062fe:	4903      	ldr	r1, [pc, #12]	; (800630c <cmd_echo+0x1c>)
 8006300:	f7ff bd96 	b.w	8005e30 <chprintf>
 8006304:	0800aeb4 	.word	0x0800aeb4
 8006308:	0800ae88 	.word	0x0800ae88
 800630c:	0800aec4 	.word	0x0800aec4

08006310 <cmd_info>:
  if (argc > 0) {
 8006310:	2900      	cmp	r1, #0
 8006312:	dd03      	ble.n	800631c <cmd_info+0xc>
    shellUsage(chp, "info");
 8006314:	4a19      	ldr	r2, [pc, #100]	; (800637c <cmd_info+0x6c>)
 8006316:	491a      	ldr	r1, [pc, #104]	; (8006380 <cmd_info+0x70>)
 8006318:	f7ff bd8a 	b.w	8005e30 <chprintf>
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 800631c:	b510      	push	{r4, lr}
  chprintf(chp, "Kernel:       %s"SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 800631e:	4a19      	ldr	r2, [pc, #100]	; (8006384 <cmd_info+0x74>)
 8006320:	4919      	ldr	r1, [pc, #100]	; (8006388 <cmd_info+0x78>)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8006322:	b082      	sub	sp, #8
 8006324:	4604      	mov	r4, r0
  chprintf(chp, "Kernel:       %s"SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8006326:	f7ff fd83 	bl	8005e30 <chprintf>
  chprintf(chp, "Compiler:     %s"SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
 800632a:	4a18      	ldr	r2, [pc, #96]	; (800638c <cmd_info+0x7c>)
 800632c:	4918      	ldr	r1, [pc, #96]	; (8006390 <cmd_info+0x80>)
 800632e:	4620      	mov	r0, r4
 8006330:	f7ff fd7e 	bl	8005e30 <chprintf>
  chprintf(chp, "Architecture: %s"SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 8006334:	4a17      	ldr	r2, [pc, #92]	; (8006394 <cmd_info+0x84>)
 8006336:	4918      	ldr	r1, [pc, #96]	; (8006398 <cmd_info+0x88>)
 8006338:	4620      	mov	r0, r4
 800633a:	f7ff fd79 	bl	8005e30 <chprintf>
  chprintf(chp, "Core Variant: %s"SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
 800633e:	4a17      	ldr	r2, [pc, #92]	; (800639c <cmd_info+0x8c>)
 8006340:	4917      	ldr	r1, [pc, #92]	; (80063a0 <cmd_info+0x90>)
 8006342:	4620      	mov	r0, r4
 8006344:	f7ff fd74 	bl	8005e30 <chprintf>
  chprintf(chp, "Port Info:    %s"SHELL_NEWLINE_STR, PORT_INFO);
 8006348:	4a16      	ldr	r2, [pc, #88]	; (80063a4 <cmd_info+0x94>)
 800634a:	4917      	ldr	r1, [pc, #92]	; (80063a8 <cmd_info+0x98>)
 800634c:	4620      	mov	r0, r4
 800634e:	f7ff fd6f 	bl	8005e30 <chprintf>
  chprintf(chp, "Platform:     %s"SHELL_NEWLINE_STR, PLATFORM_NAME);
 8006352:	4a16      	ldr	r2, [pc, #88]	; (80063ac <cmd_info+0x9c>)
 8006354:	4916      	ldr	r1, [pc, #88]	; (80063b0 <cmd_info+0xa0>)
 8006356:	4620      	mov	r0, r4
 8006358:	f7ff fd6a 	bl	8005e30 <chprintf>
  chprintf(chp, "Board:        %s"SHELL_NEWLINE_STR, BOARD_NAME);
 800635c:	4a15      	ldr	r2, [pc, #84]	; (80063b4 <cmd_info+0xa4>)
 800635e:	4916      	ldr	r1, [pc, #88]	; (80063b8 <cmd_info+0xa8>)
 8006360:	4620      	mov	r0, r4
 8006362:	f7ff fd65 	bl	8005e30 <chprintf>
  chprintf(chp, "Build time:   %s%s%s"SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8006366:	4b15      	ldr	r3, [pc, #84]	; (80063bc <cmd_info+0xac>)
 8006368:	9300      	str	r3, [sp, #0]
 800636a:	4620      	mov	r0, r4
 800636c:	4b14      	ldr	r3, [pc, #80]	; (80063c0 <cmd_info+0xb0>)
 800636e:	4a15      	ldr	r2, [pc, #84]	; (80063c4 <cmd_info+0xb4>)
 8006370:	4915      	ldr	r1, [pc, #84]	; (80063c8 <cmd_info+0xb8>)
 8006372:	f7ff fd5d 	bl	8005e30 <chprintf>
}
 8006376:	b002      	add	sp, #8
 8006378:	bd10      	pop	{r4, pc}
 800637a:	bf00      	nop
 800637c:	0800aecc 	.word	0x0800aecc
 8006380:	0800ae88 	.word	0x0800ae88
 8006384:	0800aed4 	.word	0x0800aed4
 8006388:	0800aedc 	.word	0x0800aedc
 800638c:	0800aef0 	.word	0x0800aef0
 8006390:	0800af38 	.word	0x0800af38
 8006394:	0800af4c 	.word	0x0800af4c
 8006398:	0800af58 	.word	0x0800af58
 800639c:	0800af6c 	.word	0x0800af6c
 80063a0:	0800af78 	.word	0x0800af78
 80063a4:	0800af8c 	.word	0x0800af8c
 80063a8:	0800afa4 	.word	0x0800afa4
 80063ac:	0800afb8 	.word	0x0800afb8
 80063b0:	0800afe4 	.word	0x0800afe4
 80063b4:	0800aff8 	.word	0x0800aff8
 80063b8:	0800b020 	.word	0x0800b020
 80063bc:	0800b05c 	.word	0x0800b05c
 80063c0:	0800b034 	.word	0x0800b034
 80063c4:	0800b038 	.word	0x0800b038
 80063c8:	0800b044 	.word	0x0800b044
 80063cc:	00000000 	.word	0x00000000

080063d0 <shellThread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
 80063d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int n;
  ShellConfig *scfg = p;
  BaseSequentialStream *chp = scfg->sc_channel;
 80063d4:	6807      	ldr	r7, [r0, #0]
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
 80063d6:	4977      	ldr	r1, [pc, #476]	; (80065b4 <shellThread+0x1e4>)
  const ShellCommand *scp = scfg->sc_commands;
 80063d8:	6843      	ldr	r3, [r0, #4]
  chprintf(chp, "ChibiOS/RT Shell"SHELL_NEWLINE_STR);
  chprintf(chp, "John Broadbent's copy of Chibios 2"SHELL_NEWLINE_STR);

  while (true) {
    chprintf(chp, SHELL_PROMPT_STR);
 80063da:	f8df 9214 	ldr.w	r9, [pc, #532]	; 80065f0 <shellThread+0x220>
THD_FUNCTION(shellThread, p) {
 80063de:	b09b      	sub	sp, #108	; 0x6c
 80063e0:	4680      	mov	r8, r0
  chprintf(chp, SHELL_NEWLINE_STR);
 80063e2:	4638      	mov	r0, r7
  const ShellCommand *scp = scfg->sc_commands;
 80063e4:	9301      	str	r3, [sp, #4]
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
 80063e6:	468a      	mov	sl, r1
  chprintf(chp, SHELL_NEWLINE_STR);
 80063e8:	f7ff fd22 	bl	8005e30 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell"SHELL_NEWLINE_STR);
 80063ec:	4972      	ldr	r1, [pc, #456]	; (80065b8 <shellThread+0x1e8>)
 80063ee:	4638      	mov	r0, r7
 80063f0:	f7ff fd1e 	bl	8005e30 <chprintf>
  chprintf(chp, "John Broadbent's copy of Chibios 2"SHELL_NEWLINE_STR);
 80063f4:	4638      	mov	r0, r7
 80063f6:	4971      	ldr	r1, [pc, #452]	; (80065bc <shellThread+0x1ec>)
 80063f8:	f7ff fd1a 	bl	8005e30 <chprintf>
 80063fc:	ae0a      	add	r6, sp, #40	; 0x28
    chprintf(chp, SHELL_PROMPT_STR);
 80063fe:	4649      	mov	r1, r9
 8006400:	4638      	mov	r0, r7
 8006402:	f7ff fd15 	bl	8005e30 <chprintf>
  BaseSequentialStream *chp = scfg->sc_channel;
 8006406:	f8d8 4000 	ldr.w	r4, [r8]
  char *p = line;
 800640a:	4635      	mov	r5, r6
    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 800640c:	6823      	ldr	r3, [r4, #0]
 800640e:	2201      	movs	r2, #1
 8006410:	685b      	ldr	r3, [r3, #4]
 8006412:	f10d 010f 	add.w	r1, sp, #15
 8006416:	4620      	mov	r0, r4
 8006418:	4798      	blx	r3
 800641a:	2800      	cmp	r0, #0
 800641c:	d061      	beq.n	80064e2 <shellThread+0x112>
    if (c == 4) {
 800641e:	f89d 100f 	ldrb.w	r1, [sp, #15]
 8006422:	2904      	cmp	r1, #4
 8006424:	d059      	beq.n	80064da <shellThread+0x10a>
    if ((c == 8) || (c == 127)) {
 8006426:	2908      	cmp	r1, #8
 8006428:	d012      	beq.n	8006450 <shellThread+0x80>
 800642a:	297f      	cmp	r1, #127	; 0x7f
 800642c:	d010      	beq.n	8006450 <shellThread+0x80>
    if (c == '\r') {
 800642e:	290d      	cmp	r1, #13
      continue;
    }
#endif
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8006430:	f10d 0367 	add.w	r3, sp, #103	; 0x67
    if (c == '\r') {
 8006434:	d020      	beq.n	8006478 <shellThread+0xa8>
    if (c < 0x20)
 8006436:	291f      	cmp	r1, #31
 8006438:	d9e8      	bls.n	800640c <shellThread+0x3c>
    if (p < line + size - 1) {
 800643a:	429d      	cmp	r5, r3
 800643c:	d2e6      	bcs.n	800640c <shellThread+0x3c>
      streamPut(chp, c);
 800643e:	6823      	ldr	r3, [r4, #0]
 8006440:	4620      	mov	r0, r4
 8006442:	689b      	ldr	r3, [r3, #8]
 8006444:	4798      	blx	r3
      *p++ = (char)c;
 8006446:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800644a:	702b      	strb	r3, [r5, #0]
 800644c:	3501      	adds	r5, #1
 800644e:	e7dd      	b.n	800640c <shellThread+0x3c>
      if (p != line) {
 8006450:	42b5      	cmp	r5, r6
        streamPut(chp, 0x08);
 8006452:	f04f 0108 	mov.w	r1, #8
 8006456:	4620      	mov	r0, r4
      if (p != line) {
 8006458:	d0d8      	beq.n	800640c <shellThread+0x3c>
        streamPut(chp, 0x08);
 800645a:	6823      	ldr	r3, [r4, #0]
 800645c:	689b      	ldr	r3, [r3, #8]
 800645e:	4798      	blx	r3
        streamPut(chp, 0x20);
 8006460:	6823      	ldr	r3, [r4, #0]
 8006462:	2120      	movs	r1, #32
 8006464:	689b      	ldr	r3, [r3, #8]
 8006466:	4620      	mov	r0, r4
 8006468:	4798      	blx	r3
        streamPut(chp, 0x08);
 800646a:	6823      	ldr	r3, [r4, #0]
 800646c:	2108      	movs	r1, #8
 800646e:	689b      	ldr	r3, [r3, #8]
 8006470:	4620      	mov	r0, r4
        p--;
 8006472:	3d01      	subs	r5, #1
        streamPut(chp, 0x08);
 8006474:	4798      	blx	r3
 8006476:	e7c9      	b.n	800640c <shellThread+0x3c>
      chprintf(chp, SHELL_NEWLINE_STR);
 8006478:	4620      	mov	r0, r4
 800647a:	4651      	mov	r1, sl
      *p = 0;
 800647c:	2400      	movs	r4, #0
      chprintf(chp, SHELL_NEWLINE_STR);
 800647e:	f7ff fcd7 	bl	8005e30 <chprintf>
    lp = parse_arguments(line, &tokp);
 8006482:	a904      	add	r1, sp, #16
      *p = 0;
 8006484:	702c      	strb	r4, [r5, #0]
    lp = parse_arguments(line, &tokp);
 8006486:	4630      	mov	r0, r6
 8006488:	f7ff fb82 	bl	8005b90 <parse_arguments>
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 800648c:	a904      	add	r1, sp, #16
    lp = parse_arguments(line, &tokp);
 800648e:	4683      	mov	fp, r0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8006490:	2000      	movs	r0, #0
 8006492:	ad05      	add	r5, sp, #20
 8006494:	f7ff fb7c 	bl	8005b90 <parse_arguments>
 8006498:	b150      	cbz	r0, 80064b0 <shellThread+0xe0>
      if (n >= SHELL_MAX_ARGUMENTS) {
 800649a:	2c04      	cmp	r4, #4
 800649c:	d038      	beq.n	8006510 <shellThread+0x140>
      args[n++] = lp;
 800649e:	f845 0b04 	str.w	r0, [r5], #4
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 80064a2:	a904      	add	r1, sp, #16
 80064a4:	2000      	movs	r0, #0
      args[n++] = lp;
 80064a6:	3401      	adds	r4, #1
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 80064a8:	f7ff fb72 	bl	8005b90 <parse_arguments>
 80064ac:	2800      	cmp	r0, #0
 80064ae:	d1f4      	bne.n	800649a <shellThread+0xca>
    args[n] = NULL;
 80064b0:	ab1a      	add	r3, sp, #104	; 0x68
 80064b2:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80064b6:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 80064ba:	f1bb 0f00 	cmp.w	fp, #0
 80064be:	d09e      	beq.n	80063fe <shellThread+0x2e>
      if (strcmp(cmd, "help") == 0) {
 80064c0:	493f      	ldr	r1, [pc, #252]	; (80065c0 <shellThread+0x1f0>)
 80064c2:	4658      	mov	r0, fp
 80064c4:	f7f9 ffa0 	bl	8000408 <strcmp>
 80064c8:	bb48      	cbnz	r0, 800651e <shellThread+0x14e>
        if (n > 0) {
 80064ca:	2c00      	cmp	r4, #0
 80064cc:	d038      	beq.n	8006540 <shellThread+0x170>
          shellUsage(chp, "help");
 80064ce:	4a3c      	ldr	r2, [pc, #240]	; (80065c0 <shellThread+0x1f0>)
 80064d0:	493c      	ldr	r1, [pc, #240]	; (80065c4 <shellThread+0x1f4>)
 80064d2:	4638      	mov	r0, r7
 80064d4:	f7ff fcac 	bl	8005e30 <chprintf>
 80064d8:	e791      	b.n	80063fe <shellThread+0x2e>
      chprintf(chp, "^D");
 80064da:	4620      	mov	r0, r4
 80064dc:	493a      	ldr	r1, [pc, #232]	; (80065c8 <shellThread+0x1f8>)
 80064de:	f7ff fca7 	bl	8005e30 <chprintf>
      chprintf(chp, SHELL_NEWLINE_STR);
 80064e2:	4934      	ldr	r1, [pc, #208]	; (80065b4 <shellThread+0x1e4>)
 80064e4:	4638      	mov	r0, r7
 80064e6:	f7ff fca3 	bl	8005e30 <chprintf>
      chprintf(chp, "logout");
 80064ea:	4638      	mov	r0, r7
 80064ec:	4937      	ldr	r1, [pc, #220]	; (80065cc <shellThread+0x1fc>)
 80064ee:	f7ff fc9f 	bl	8005e30 <chprintf>
 80064f2:	2320      	movs	r3, #32
 80064f4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80064f8:	f7fa feb2 	bl	8001260 <_dbg_check_lock>
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 80064fc:	2100      	movs	r1, #0
 80064fe:	4834      	ldr	r0, [pc, #208]	; (80065d0 <shellThread+0x200>)
 8006500:	f7fa faf6 	bl	8000af0 <chEvtBroadcastFlagsI>
  chThdExitS(msg);
 8006504:	2000      	movs	r0, #0
 8006506:	f7fa fbfb 	bl	8000d00 <chThdExitS>
}
 800650a:	b01b      	add	sp, #108	; 0x6c
 800650c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
 8006510:	4930      	ldr	r1, [pc, #192]	; (80065d4 <shellThread+0x204>)
 8006512:	4638      	mov	r0, r7
 8006514:	f7ff fc8c 	bl	8005e30 <chprintf>
    args[n] = NULL;
 8006518:	2300      	movs	r3, #0
 800651a:	9309      	str	r3, [sp, #36]	; 0x24
 800651c:	e76f      	b.n	80063fe <shellThread+0x2e>
 800651e:	4d2e      	ldr	r5, [pc, #184]	; (80065d8 <shellThread+0x208>)
      if (strcmp(cmd, "help") == 0) {
 8006520:	482e      	ldr	r0, [pc, #184]	; (80065dc <shellThread+0x20c>)
 8006522:	e002      	b.n	800652a <shellThread+0x15a>
  while (scp->sc_name != NULL) {
 8006524:	f855 0f08 	ldr.w	r0, [r5, #8]!
 8006528:	b360      	cbz	r0, 8006584 <shellThread+0x1b4>
    if (strcmp(scp->sc_name, name) == 0) {
 800652a:	4659      	mov	r1, fp
 800652c:	f7f9 ff6c 	bl	8000408 <strcmp>
 8006530:	2800      	cmp	r0, #0
 8006532:	d1f7      	bne.n	8006524 <shellThread+0x154>
      scp->sc_function(chp, argc, argv);
 8006534:	686b      	ldr	r3, [r5, #4]
 8006536:	aa05      	add	r2, sp, #20
 8006538:	4621      	mov	r1, r4
 800653a:	4638      	mov	r0, r7
 800653c:	4798      	blx	r3
 800653e:	e75e      	b.n	80063fe <shellThread+0x2e>
        chprintf(chp, "Commands: help ");
 8006540:	4927      	ldr	r1, [pc, #156]	; (80065e0 <shellThread+0x210>)
 8006542:	4c25      	ldr	r4, [pc, #148]	; (80065d8 <shellThread+0x208>)
    chprintf(chp, "%s ", scp->sc_name);
 8006544:	4d27      	ldr	r5, [pc, #156]	; (80065e4 <shellThread+0x214>)
        chprintf(chp, "Commands: help ");
 8006546:	4638      	mov	r0, r7
 8006548:	f7ff fc72 	bl	8005e30 <chprintf>
 800654c:	4a23      	ldr	r2, [pc, #140]	; (80065dc <shellThread+0x20c>)
    chprintf(chp, "%s ", scp->sc_name);
 800654e:	4629      	mov	r1, r5
 8006550:	4638      	mov	r0, r7
 8006552:	f7ff fc6d 	bl	8005e30 <chprintf>
  while (scp->sc_name != NULL) {
 8006556:	f854 2f08 	ldr.w	r2, [r4, #8]!
 800655a:	2a00      	cmp	r2, #0
 800655c:	d1f7      	bne.n	800654e <shellThread+0x17e>
        if (scp != NULL)
 800655e:	9b01      	ldr	r3, [sp, #4]
 8006560:	b15b      	cbz	r3, 800657a <shellThread+0x1aa>
  while (scp->sc_name != NULL) {
 8006562:	9c01      	ldr	r4, [sp, #4]
 8006564:	6822      	ldr	r2, [r4, #0]
 8006566:	b142      	cbz	r2, 800657a <shellThread+0x1aa>
    chprintf(chp, "%s ", scp->sc_name);
 8006568:	4d1e      	ldr	r5, [pc, #120]	; (80065e4 <shellThread+0x214>)
 800656a:	4629      	mov	r1, r5
 800656c:	4638      	mov	r0, r7
 800656e:	f7ff fc5f 	bl	8005e30 <chprintf>
  while (scp->sc_name != NULL) {
 8006572:	f854 2f08 	ldr.w	r2, [r4, #8]!
 8006576:	2a00      	cmp	r2, #0
 8006578:	d1f7      	bne.n	800656a <shellThread+0x19a>
        chprintf(chp, SHELL_NEWLINE_STR);
 800657a:	4651      	mov	r1, sl
 800657c:	4638      	mov	r0, r7
 800657e:	f7ff fc57 	bl	8005e30 <chprintf>
 8006582:	e73c      	b.n	80063fe <shellThread+0x2e>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 8006584:	9d01      	ldr	r5, [sp, #4]
 8006586:	b15d      	cbz	r5, 80065a0 <shellThread+0x1d0>
  while (scp->sc_name != NULL) {
 8006588:	6828      	ldr	r0, [r5, #0]
 800658a:	b918      	cbnz	r0, 8006594 <shellThread+0x1c4>
 800658c:	e008      	b.n	80065a0 <shellThread+0x1d0>
 800658e:	f855 0f08 	ldr.w	r0, [r5, #8]!
 8006592:	b128      	cbz	r0, 80065a0 <shellThread+0x1d0>
    if (strcmp(scp->sc_name, name) == 0) {
 8006594:	4659      	mov	r1, fp
 8006596:	f7f9 ff37 	bl	8000408 <strcmp>
 800659a:	2800      	cmp	r0, #0
 800659c:	d1f7      	bne.n	800658e <shellThread+0x1be>
 800659e:	e7c9      	b.n	8006534 <shellThread+0x164>
        chprintf(chp, "%s", cmd);
 80065a0:	465a      	mov	r2, fp
 80065a2:	4911      	ldr	r1, [pc, #68]	; (80065e8 <shellThread+0x218>)
 80065a4:	4638      	mov	r0, r7
 80065a6:	f7ff fc43 	bl	8005e30 <chprintf>
        chprintf(chp, " ?"SHELL_NEWLINE_STR);
 80065aa:	4910      	ldr	r1, [pc, #64]	; (80065ec <shellThread+0x21c>)
 80065ac:	4638      	mov	r0, r7
 80065ae:	f7ff fc3f 	bl	8005e30 <chprintf>
 80065b2:	e724      	b.n	80063fe <shellThread+0x2e>
 80065b4:	0800a8dc 	.word	0x0800a8dc
 80065b8:	0800b1c8 	.word	0x0800b1c8
 80065bc:	0800b1dc 	.word	0x0800b1dc
 80065c0:	0800b228 	.word	0x0800b228
 80065c4:	0800ae88 	.word	0x0800ae88
 80065c8:	0800b20c 	.word	0x0800b20c
 80065cc:	0800b250 	.word	0x0800b250
 80065d0:	20001598 	.word	0x20001598
 80065d4:	0800b210 	.word	0x0800b210
 80065d8:	0800b258 	.word	0x0800b258
 80065dc:	0800b1c0 	.word	0x0800b1c0
 80065e0:	0800b230 	.word	0x0800b230
 80065e4:	0800b240 	.word	0x0800b240
 80065e8:	0800b244 	.word	0x0800b244
 80065ec:	0800b248 	.word	0x0800b248
 80065f0:	0800b204 	.word	0x0800b204
	...

08006600 <cmd_exit>:
  if (argc > 0) {
 8006600:	2900      	cmp	r1, #0
 8006602:	dd03      	ble.n	800660c <cmd_exit+0xc>
    shellUsage(chp, "exit");
 8006604:	4a09      	ldr	r2, [pc, #36]	; (800662c <cmd_exit+0x2c>)
 8006606:	490a      	ldr	r1, [pc, #40]	; (8006630 <cmd_exit+0x30>)
 8006608:	f7ff bc12 	b.w	8005e30 <chprintf>
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {
 800660c:	b508      	push	{r3, lr}
 800660e:	2320      	movs	r3, #32
 8006610:	f383 8811 	msr	BASEPRI, r3
 8006614:	f7fa fe24 	bl	8001260 <_dbg_check_lock>
 8006618:	4806      	ldr	r0, [pc, #24]	; (8006634 <cmd_exit+0x34>)
 800661a:	2100      	movs	r1, #0
 800661c:	f7fa fa68 	bl	8000af0 <chEvtBroadcastFlagsI>
  chThdExitS(msg);
 8006620:	2000      	movs	r0, #0
}
 8006622:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8006626:	f7fa bb6b 	b.w	8000d00 <chThdExitS>
 800662a:	bf00      	nop
 800662c:	0800b1c0 	.word	0x0800b1c0
 8006630:	0800ae88 	.word	0x0800ae88
 8006634:	20001598 	.word	0x20001598
	...

08006640 <cmd_threads>:
  if (argc > 0) {
 8006640:	2900      	cmp	r1, #0
 8006642:	dd03      	ble.n	800664c <cmd_threads+0xc>
    shellUsage(chp, "threads");
 8006644:	4a26      	ldr	r2, [pc, #152]	; (80066e0 <cmd_threads+0xa0>)
 8006646:	4927      	ldr	r1, [pc, #156]	; (80066e4 <cmd_threads+0xa4>)
 8006648:	f7ff bbf2 	b.w	8005e30 <chprintf>
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 800664c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n"SHELL_NEWLINE_STR);
 8006650:	4925      	ldr	r1, [pc, #148]	; (80066e8 <cmd_threads+0xa8>)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8006652:	b086      	sub	sp, #24
 8006654:	4606      	mov	r6, r0
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n"SHELL_NEWLINE_STR);
 8006656:	f7ff fbeb 	bl	8005e30 <chprintf>
 800665a:	2320      	movs	r3, #32
 800665c:	f383 8811 	msr	BASEPRI, r3
  tp = ch.rlist.newer;
 8006660:	4d22      	ldr	r5, [pc, #136]	; (80066ec <cmd_threads+0xac>)
 8006662:	f7fa fdfd 	bl	8001260 <_dbg_check_lock>
 8006666:	692c      	ldr	r4, [r5, #16]
  tp->refs++;
 8006668:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 800666c:	3301      	adds	r3, #1
 800666e:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  _dbg_check_unlock();
 8006672:	f7fa fdcd 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006676:	682b      	ldr	r3, [r5, #0]
 8006678:	42ab      	cmp	r3, r5
 800667a:	d004      	beq.n	8006686 <cmd_threads+0x46>
 800667c:	69aa      	ldr	r2, [r5, #24]
 800667e:	689b      	ldr	r3, [r3, #8]
 8006680:	6892      	ldr	r2, [r2, #8]
 8006682:	429a      	cmp	r2, r3
 8006684:	d328      	bcc.n	80066d8 <cmd_threads+0x98>
 8006686:	2300      	movs	r3, #0
 8006688:	f383 8811 	msr	BASEPRI, r3
 800668c:	f8df 9064 	ldr.w	r9, [pc, #100]	; 80066f4 <cmd_threads+0xb4>
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8006690:	f8df 8064 	ldr.w	r8, [pc, #100]	; 80066f8 <cmd_threads+0xb8>
 8006694:	f8df a064 	ldr.w	sl, [pc, #100]	; 80066fc <cmd_threads+0xbc>
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8006698:	f894 5022 	ldrb.w	r5, [r4, #34]	; 0x22
 800669c:	f894 0020 	ldrb.w	r0, [r4, #32]
             tp->name == NULL ? "" : tp->name);
 80066a0:	69a1      	ldr	r1, [r4, #24]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 80066a2:	68a7      	ldr	r7, [r4, #8]
 80066a4:	f859 0020 	ldr.w	r0, [r9, r0, lsl #2]
    uint32_t stklimit = (uint32_t)tp->wabase;
 80066a8:	69e2      	ldr	r2, [r4, #28]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 80066aa:	68e3      	ldr	r3, [r4, #12]
 80066ac:	9003      	str	r0, [sp, #12]
 80066ae:	2900      	cmp	r1, #0
 80066b0:	bf08      	it	eq
 80066b2:	4641      	moveq	r1, r8
 80066b4:	3d01      	subs	r5, #1
 80066b6:	9104      	str	r1, [sp, #16]
 80066b8:	9400      	str	r4, [sp, #0]
 80066ba:	4651      	mov	r1, sl
 80066bc:	9702      	str	r7, [sp, #8]
 80066be:	9501      	str	r5, [sp, #4]
 80066c0:	4630      	mov	r0, r6
 80066c2:	f7ff fbb5 	bl	8005e30 <chprintf>
    tp = chRegNextThread(tp);
 80066c6:	4620      	mov	r0, r4
 80066c8:	f7fb f97a 	bl	80019c0 <chRegNextThread>
  } while (tp != NULL);
 80066cc:	4604      	mov	r4, r0
 80066ce:	2800      	cmp	r0, #0
 80066d0:	d1e2      	bne.n	8006698 <cmd_threads+0x58>
}
 80066d2:	b006      	add	sp, #24
 80066d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80066d8:	4805      	ldr	r0, [pc, #20]	; (80066f0 <cmd_threads+0xb0>)
 80066da:	f7fa f8a1 	bl	8000820 <chSysHalt>
 80066de:	bf00      	nop
 80066e0:	0800b104 	.word	0x0800b104
 80066e4:	0800ae88 	.word	0x0800ae88
 80066e8:	0800b10c 	.word	0x0800b10c
 80066ec:	20001e68 	.word	0x20001e68
 80066f0:	0800ae5c 	.word	0x0800ae5c
 80066f4:	0800b2a0 	.word	0x0800b2a0
 80066f8:	0800b200 	.word	0x0800b200
 80066fc:	0800b14c 	.word	0x0800b14c

08006700 <cmd_systime>:
  if (argc > 0) {
 8006700:	2900      	cmp	r1, #0
 8006702:	dd03      	ble.n	800670c <cmd_systime+0xc>
    shellUsage(chp, "systime");
 8006704:	4a12      	ldr	r2, [pc, #72]	; (8006750 <cmd_systime+0x50>)
 8006706:	4913      	ldr	r1, [pc, #76]	; (8006754 <cmd_systime+0x54>)
 8006708:	f7ff bb92 	b.w	8005e30 <chprintf>
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 800670c:	b538      	push	{r3, r4, r5, lr}
 800670e:	4604      	mov	r4, r0
 8006710:	2320      	movs	r3, #32
 8006712:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8006716:	f7fa fda3 	bl	8001260 <_dbg_check_lock>
 800671a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800671e:	6a5d      	ldr	r5, [r3, #36]	; 0x24
  _dbg_check_unlock();
 8006720:	f7fa fd76 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006724:	4b0c      	ldr	r3, [pc, #48]	; (8006758 <cmd_systime+0x58>)
 8006726:	681a      	ldr	r2, [r3, #0]
 8006728:	429a      	cmp	r2, r3
 800672a:	d004      	beq.n	8006736 <cmd_systime+0x36>
 800672c:	6999      	ldr	r1, [r3, #24]
 800672e:	6893      	ldr	r3, [r2, #8]
 8006730:	688a      	ldr	r2, [r1, #8]
 8006732:	429a      	cmp	r2, r3
 8006734:	d309      	bcc.n	800674a <cmd_systime+0x4a>
 8006736:	2300      	movs	r3, #0
 8006738:	f383 8811 	msr	BASEPRI, r3
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 800673c:	4907      	ldr	r1, [pc, #28]	; (800675c <cmd_systime+0x5c>)
 800673e:	462a      	mov	r2, r5
 8006740:	4620      	mov	r0, r4
}
 8006742:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 8006746:	f7ff bb73 	b.w	8005e30 <chprintf>
 800674a:	4805      	ldr	r0, [pc, #20]	; (8006760 <cmd_systime+0x60>)
 800674c:	f7fa f868 	bl	8000820 <chSysHalt>
 8006750:	0800b0e4 	.word	0x0800b0e4
 8006754:	0800ae88 	.word	0x0800ae88
 8006758:	20001e68 	.word	0x20001e68
 800675c:	0800b0ec 	.word	0x0800b0ec
 8006760:	0800ae68 	.word	0x0800ae68
	...

08006770 <test_012_009_execute.lto_priv.254>:
static void test_012_009_execute(void) {
 8006770:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  test_set_step(1);
 8006774:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 8006830 <test_012_009_execute.lto_priv.254+0xc0>
 8006778:	4c26      	ldr	r4, [pc, #152]	; (8006814 <test_012_009_execute.lto_priv.254+0xa4>)
      chVTDoSetI(&vt1, 1, tmo, NULL);
 800677a:	4f27      	ldr	r7, [pc, #156]	; (8006818 <test_012_009_execute.lto_priv.254+0xa8>)
 800677c:	4e27      	ldr	r6, [pc, #156]	; (800681c <test_012_009_execute.lto_priv.254+0xac>)
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 800677e:	4d28      	ldr	r5, [pc, #160]	; (8006820 <test_012_009_execute.lto_priv.254+0xb0>)
  test_set_step(1);
 8006780:	2301      	movs	r3, #1
 8006782:	f8ca 3000 	str.w	r3, [sl]
    start = test_wait_tick();
 8006786:	f002 fd33 	bl	80091f0 <test_wait_tick>
    n = 0;
 800678a:	f04f 0800 	mov.w	r8, #0
    start = test_wait_tick();
 800678e:	4681      	mov	r9, r0
 8006790:	2320      	movs	r3, #32
 8006792:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8006796:	f7fa fd63 	bl	8001260 <_dbg_check_lock>
      chVTDoSetI(&vt1, 1, tmo, NULL);
 800679a:	463a      	mov	r2, r7
 800679c:	4630      	mov	r0, r6
 800679e:	2300      	movs	r3, #0
 80067a0:	2101      	movs	r1, #1
 80067a2:	f7fa fb5d 	bl	8000e60 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 80067a6:	2300      	movs	r3, #0
 80067a8:	463a      	mov	r2, r7
 80067aa:	f242 7110 	movw	r1, #10000	; 0x2710
 80067ae:	4628      	mov	r0, r5
 80067b0:	f7fa fb56 	bl	8000e60 <chVTDoSetI>
      chVTDoResetI(&vt1);
 80067b4:	4630      	mov	r0, r6
 80067b6:	f7fa fb0b 	bl	8000dd0 <chVTDoResetI>
      chVTDoResetI(&vt2);
 80067ba:	4628      	mov	r0, r5
 80067bc:	f7fa fb08 	bl	8000dd0 <chVTDoResetI>
  _dbg_check_unlock();
 80067c0:	f7fa fd26 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80067c4:	6823      	ldr	r3, [r4, #0]
 80067c6:	42a3      	cmp	r3, r4
 80067c8:	d004      	beq.n	80067d4 <test_012_009_execute.lto_priv.254+0x64>
 80067ca:	69a2      	ldr	r2, [r4, #24]
 80067cc:	689b      	ldr	r3, [r3, #8]
 80067ce:	6892      	ldr	r2, [r2, #8]
 80067d0:	429a      	cmp	r2, r3
 80067d2:	d31c      	bcc.n	800680e <test_012_009_execute.lto_priv.254+0x9e>
 80067d4:	2300      	movs	r3, #0
 80067d6:	f383 8811 	msr	BASEPRI, r3
 80067da:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    } while (chVTIsSystemTimeWithinX(start, end));
 80067de:	f242 720f 	movw	r2, #9999	; 0x270f
 80067e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80067e4:	eba3 0309 	sub.w	r3, r3, r9
 80067e8:	4293      	cmp	r3, r2
      n++;
 80067ea:	f108 0801 	add.w	r8, r8, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 80067ee:	d9cf      	bls.n	8006790 <test_012_009_execute.lto_priv.254+0x20>
  test_set_step(2);
 80067f0:	2302      	movs	r3, #2
    test_print("--- Score : ");
 80067f2:	480c      	ldr	r0, [pc, #48]	; (8006824 <test_012_009_execute.lto_priv.254+0xb4>)
  test_set_step(2);
 80067f4:	f8ca 3000 	str.w	r3, [sl]
    test_print("--- Score : ");
 80067f8:	f002 fe2a 	bl	8009450 <test_print>
    test_printn(n * 2);
 80067fc:	ea4f 0048 	mov.w	r0, r8, lsl #1
 8006800:	f002 fe3e 	bl	8009480 <test_printn>
    test_println(" timers/S");
 8006804:	4808      	ldr	r0, [pc, #32]	; (8006828 <test_012_009_execute.lto_priv.254+0xb8>)
}
 8006806:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_println(" timers/S");
 800680a:	f002 be01 	b.w	8009410 <test_println>
 800680e:	4807      	ldr	r0, [pc, #28]	; (800682c <test_012_009_execute.lto_priv.254+0xbc>)
 8006810:	f7fa f806 	bl	8000820 <chSysHalt>
 8006814:	20001e68 	.word	0x20001e68
 8006818:	08003311 	.word	0x08003311
 800681c:	20001dfc 	.word	0x20001dfc
 8006820:	20001e10 	.word	0x20001e10
 8006824:	0800ac3c 	.word	0x0800ac3c
 8006828:	0800b380 	.word	0x0800b380
 800682c:	0800ae50 	.word	0x0800ae50
 8006830:	20001df8 	.word	0x20001df8
	...

08006840 <otg_epout_handler>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8006840:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8006844:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8006846:	eb07 1341 	add.w	r3, r7, r1, lsl #5
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800684a:	4605      	mov	r5, r0
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800684c:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08
  otgp->oe[ep].DOEPINT = epint;
 8006850:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8006854:	0722      	lsls	r2, r4, #28
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8006856:	460e      	mov	r6, r1
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8006858:	d503      	bpl.n	8006862 <otg_epout_handler+0x22>
 800685a:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800685e:	071b      	lsls	r3, r3, #28
 8006860:	d43d      	bmi.n	80068de <otg_epout_handler+0x9e>
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8006862:	07e2      	lsls	r2, r4, #31
 8006864:	d527      	bpl.n	80068b6 <otg_epout_handler+0x76>
 8006866:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800686a:	07db      	lsls	r3, r3, #31
 800686c:	d523      	bpl.n	80068b6 <otg_epout_handler+0x76>
    if ((ep == 0) && (usbp->ep0state == USB_EP0_WAITING_SETUP))
 800686e:	bb26      	cbnz	r6, 80068ba <otg_epout_handler+0x7a>
 8006870:	f895 304c 	ldrb.w	r3, [r5, #76]	; 0x4c
 8006874:	2b00      	cmp	r3, #0
 8006876:	d038      	beq.n	80068ea <otg_epout_handler+0xaa>
    osp = usbp->epc[ep]->out_state;
 8006878:	68e9      	ldr	r1, [r5, #12]
 800687a:	698a      	ldr	r2, [r1, #24]
        ((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800687c:	8a48      	ldrh	r0, [r1, #18]
 800687e:	6854      	ldr	r4, [r2, #4]
 8006880:	fbb4 f3f0 	udiv	r3, r4, r0
 8006884:	fb00 4313 	mls	r3, r0, r3, r4
    if ((ep == 0) &&
 8006888:	b9d3      	cbnz	r3, 80068c0 <otg_epout_handler+0x80>
        (osp->rxsize < osp->totsize)) {
 800688a:	6810      	ldr	r0, [r2, #0]
 800688c:	68d3      	ldr	r3, [r2, #12]
        ((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800688e:	4298      	cmp	r0, r3
 8006890:	d216      	bcs.n	80068c0 <otg_epout_handler+0x80>
      osp->rxsize = osp->totsize - osp->rxsize;
 8006892:	1a1b      	subs	r3, r3, r0
      osp->rxcnt  = 0;
 8006894:	e882 0048 	stmia.w	r2, {r3, r6}
 8006898:	2320      	movs	r3, #32
 800689a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800689e:	f7fa fc67 	bl	8001170 <_dbg_check_lock_from_isr>
      usb_lld_start_out(usbp, ep);
 80068a2:	4631      	mov	r1, r6
 80068a4:	4628      	mov	r0, r5
 80068a6:	f003 f87b 	bl	80099a0 <usb_lld_start_out>
  _dbg_check_unlock_from_isr();
 80068aa:	f7fa fc49 	bl	8001140 <_dbg_check_unlock_from_isr>
 80068ae:	f386 8811 	msr	BASEPRI, r6
 80068b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80068b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    osp = usbp->epc[ep]->out_state;
 80068ba:	eb05 0386 	add.w	r3, r5, r6, lsl #2
 80068be:	68d9      	ldr	r1, [r3, #12]
      _usb_isr_invoke_out_cb(usbp, ep);
 80068c0:	896b      	ldrh	r3, [r5, #10]
 80068c2:	68cc      	ldr	r4, [r1, #12]
 80068c4:	2201      	movs	r2, #1
 80068c6:	40b2      	lsls	r2, r6
 80068c8:	ea23 0302 	bic.w	r3, r3, r2
 80068cc:	816b      	strh	r3, [r5, #10]
 80068ce:	2c00      	cmp	r4, #0
 80068d0:	d0f1      	beq.n	80068b6 <otg_epout_handler+0x76>
 80068d2:	4631      	mov	r1, r6
 80068d4:	4628      	mov	r0, r5
 80068d6:	4623      	mov	r3, r4
}
 80068d8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      _usb_isr_invoke_out_cb(usbp, ep);
 80068dc:	4718      	bx	r3
    _usb_isr_invoke_setup_cb(usbp, ep);
 80068de:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 80068e2:	68db      	ldr	r3, [r3, #12]
 80068e4:	685b      	ldr	r3, [r3, #4]
 80068e6:	4798      	blx	r3
 80068e8:	e7bb      	b.n	8006862 <otg_epout_handler+0x22>
 80068ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80068ee:	bf00      	nop

080068f0 <otg_epin_handler>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80068f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 80068f4:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80068f6:	eb05 1341 	add.w	r3, r5, r1, lsl #5
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80068fa:	4606      	mov	r6, r0
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80068fc:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908
  otgp->ie[ep].DIEPINT = epint;
 8006900:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8006904:	07e3      	lsls	r3, r4, #31
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8006906:	460f      	mov	r7, r1
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8006908:	d503      	bpl.n	8006912 <otg_epin_handler+0x22>
 800690a:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
 800690e:	07da      	lsls	r2, r3, #31
 8006910:	d40a      	bmi.n	8006928 <otg_epin_handler+0x38>
  if ((epint & DIEPINT_TXFE) &&
 8006912:	0623      	lsls	r3, r4, #24
 8006914:	d506      	bpl.n	8006924 <otg_epin_handler+0x34>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8006916:	2301      	movs	r3, #1
 8006918:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
 800691c:	fa03 f707 	lsl.w	r7, r3, r7
  if ((epint & DIEPINT_TXFE) &&
 8006920:	4217      	tst	r7, r2
 8006922:	d119      	bne.n	8006958 <otg_epin_handler+0x68>
 8006924:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8006928:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 800692c:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 8006930:	f8de 3014 	ldr.w	r3, [lr, #20]
    if (isp->txsize < isp->totsize) {
 8006934:	f8d3 c000 	ldr.w	ip, [r3]
 8006938:	68da      	ldr	r2, [r3, #12]
 800693a:	4594      	cmp	ip, r2
 800693c:	d325      	bcc.n	800698a <otg_epin_handler+0x9a>
      _usb_isr_invoke_in_cb(usbp, ep);
 800693e:	8903      	ldrh	r3, [r0, #8]
 8006940:	f8de 8008 	ldr.w	r8, [lr, #8]
 8006944:	2201      	movs	r2, #1
 8006946:	408a      	lsls	r2, r1
 8006948:	ea23 0302 	bic.w	r3, r3, r2
 800694c:	8103      	strh	r3, [r0, #8]
 800694e:	f1b8 0f00 	cmp.w	r8, #0
 8006952:	d0de      	beq.n	8006912 <otg_epin_handler+0x22>
 8006954:	47c0      	blx	r8
 8006956:	e7dc      	b.n	8006912 <otg_epin_handler+0x22>
 8006958:	2320      	movs	r3, #32
 800695a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800695e:	f7fa fc07 	bl	8001170 <_dbg_check_lock_from_isr>
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8006962:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
    usbp->txpending |= (1 << ep);
 8006966:	6fb2      	ldr	r2, [r6, #120]	; 0x78
 8006968:	433a      	orrs	r2, r7
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800696a:	ea23 0707 	bic.w	r7, r3, r7
    usbp->txpending |= (1 << ep);
 800696e:	67b2      	str	r2, [r6, #120]	; 0x78
  chThdResumeI(trp, msg);
 8006970:	f106 007c 	add.w	r0, r6, #124	; 0x7c
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8006974:	f8c5 7834 	str.w	r7, [r5, #2100]	; 0x834
 8006978:	f003 f9ea 	bl	8009d50 <chThdResumeI.constprop.70>
  _dbg_check_unlock_from_isr();
 800697c:	f7fa fbe0 	bl	8001140 <_dbg_check_unlock_from_isr>
 8006980:	2300      	movs	r3, #0
 8006982:	f383 8811 	msr	BASEPRI, r3
 8006986:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      isp->txsize = isp->totsize - isp->txsize;
 800698a:	eba2 020c 	sub.w	r2, r2, ip
      isp->txcnt  = 0;
 800698e:	f04f 0800 	mov.w	r8, #0
 8006992:	e883 0104 	stmia.w	r3, {r2, r8}
 8006996:	2320      	movs	r3, #32
 8006998:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800699c:	f7fa fbe8 	bl	8001170 <_dbg_check_lock_from_isr>
      usb_lld_start_in(usbp, ep);
 80069a0:	4639      	mov	r1, r7
 80069a2:	4630      	mov	r0, r6
 80069a4:	f002 ffa4 	bl	80098f0 <usb_lld_start_in>
  _dbg_check_unlock_from_isr();
 80069a8:	f7fa fbca 	bl	8001140 <_dbg_check_unlock_from_isr>
 80069ac:	f388 8811 	msr	BASEPRI, r8
 80069b0:	e7af      	b.n	8006912 <otg_epin_handler+0x22>
 80069b2:	bf00      	nop
	...

080069c0 <usb_lld_serve_interrupt.lto_priv.260>:
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 80069c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
 80069c4:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  sts  = otgp->GINTSTS;
 80069c6:	6977      	ldr	r7, [r6, #20]
  sts &= otgp->GINTMSK;
 80069c8:	69b3      	ldr	r3, [r6, #24]
 80069ca:	401f      	ands	r7, r3
  if (sts & GINTSTS_USBRST) {
 80069cc:	f417 5880 	ands.w	r8, r7, #4096	; 0x1000
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 80069d0:	b081      	sub	sp, #4
 80069d2:	4605      	mov	r5, r0
  otgp->GINTSTS = sts;
 80069d4:	6177      	str	r7, [r6, #20]
  if (sts & GINTSTS_USBRST) {
 80069d6:	f040 8118 	bne.w	8006c0a <usb_lld_serve_interrupt.lto_priv.260+0x24a>
  if (sts & GINTSTS_WKUPINT) {
 80069da:	2f00      	cmp	r7, #0
 80069dc:	f2c0 80f9 	blt.w	8006bd2 <usb_lld_serve_interrupt.lto_priv.260+0x212>
  if (sts & GINTSTS_USBSUSP) {
 80069e0:	053b      	lsls	r3, r7, #20
 80069e2:	f100 80e6 	bmi.w	8006bb2 <usb_lld_serve_interrupt.lto_priv.260+0x1f2>
  if (sts & GINTSTS_ENUMDNE) {
 80069e6:	04bc      	lsls	r4, r7, #18
 80069e8:	d50c      	bpl.n	8006a04 <usb_lld_serve_interrupt.lto_priv.260+0x44>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 80069ea:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
 80069ee:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 80069f2:	68f3      	ldr	r3, [r6, #12]
 80069f4:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 80069f8:	bf0c      	ite	eq
 80069fa:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 80069fe:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 8006a02:	60f3      	str	r3, [r6, #12]
  if (sts & GINTSTS_SOF) {
 8006a04:	0738      	lsls	r0, r7, #28
 8006a06:	d434      	bmi.n	8006a72 <usb_lld_serve_interrupt.lto_priv.260+0xb2>
  if (sts & GINTSTS_IISOIXFR) {
 8006a08:	02f9      	lsls	r1, r7, #11
 8006a0a:	d43a      	bmi.n	8006a82 <usb_lld_serve_interrupt.lto_priv.260+0xc2>
  if (sts & GINTSTS_IISOOXFR) {
 8006a0c:	02ba      	lsls	r2, r7, #10
 8006a0e:	f100 80a4 	bmi.w	8006b5a <usb_lld_serve_interrupt.lto_priv.260+0x19a>
  if (sts & GINTSTS_RXFLVL) {
 8006a12:	06f8      	lsls	r0, r7, #27
 8006a14:	f100 808e 	bmi.w	8006b34 <usb_lld_serve_interrupt.lto_priv.260+0x174>
  if (sts & GINTSTS_OEPINT) {
 8006a18:	0339      	lsls	r1, r7, #12
  src = otgp->DAINT;
 8006a1a:	f8d6 4818 	ldr.w	r4, [r6, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 8006a1e:	d511      	bpl.n	8006a44 <usb_lld_serve_interrupt.lto_priv.260+0x84>
    if (src & (1 << 16))
 8006a20:	03e2      	lsls	r2, r4, #15
 8006a22:	f100 81ab 	bmi.w	8006d7c <usb_lld_serve_interrupt.lto_priv.260+0x3bc>
    if (src & (1 << 17))
 8006a26:	03a3      	lsls	r3, r4, #14
 8006a28:	f100 81a3 	bmi.w	8006d72 <usb_lld_serve_interrupt.lto_priv.260+0x3b2>
    if (src & (1 << 18))
 8006a2c:	0366      	lsls	r6, r4, #13
 8006a2e:	f100 819b 	bmi.w	8006d68 <usb_lld_serve_interrupt.lto_priv.260+0x3a8>
    if (src & (1 << 19))
 8006a32:	0320      	lsls	r0, r4, #12
 8006a34:	f100 8193 	bmi.w	8006d5e <usb_lld_serve_interrupt.lto_priv.260+0x39e>
    if (src & (1 << 20))
 8006a38:	02e1      	lsls	r1, r4, #11
 8006a3a:	f100 818b 	bmi.w	8006d54 <usb_lld_serve_interrupt.lto_priv.260+0x394>
    if (src & (1 << 21))
 8006a3e:	02a2      	lsls	r2, r4, #10
 8006a40:	f100 8160 	bmi.w	8006d04 <usb_lld_serve_interrupt.lto_priv.260+0x344>
  if (sts & GINTSTS_IEPINT) {
 8006a44:	037b      	lsls	r3, r7, #13
 8006a46:	d511      	bpl.n	8006a6c <usb_lld_serve_interrupt.lto_priv.260+0xac>
    if (src & (1 << 0))
 8006a48:	07e7      	lsls	r7, r4, #31
 8006a4a:	f100 8170 	bmi.w	8006d2e <usb_lld_serve_interrupt.lto_priv.260+0x36e>
    if (src & (1 << 1))
 8006a4e:	07a6      	lsls	r6, r4, #30
 8006a50:	f100 8174 	bmi.w	8006d3c <usb_lld_serve_interrupt.lto_priv.260+0x37c>
    if (src & (1 << 2))
 8006a54:	0760      	lsls	r0, r4, #29
 8006a56:	f100 8178 	bmi.w	8006d4a <usb_lld_serve_interrupt.lto_priv.260+0x38a>
    if (src & (1 << 3))
 8006a5a:	0721      	lsls	r1, r4, #28
 8006a5c:	f100 8162 	bmi.w	8006d24 <usb_lld_serve_interrupt.lto_priv.260+0x364>
    if (src & (1 << 4))
 8006a60:	06e2      	lsls	r2, r4, #27
 8006a62:	f100 815a 	bmi.w	8006d1a <usb_lld_serve_interrupt.lto_priv.260+0x35a>
    if (src & (1 << 5))
 8006a66:	06a3      	lsls	r3, r4, #26
 8006a68:	f100 8145 	bmi.w	8006cf6 <usb_lld_serve_interrupt.lto_priv.260+0x336>
}
 8006a6c:	b001      	add	sp, #4
 8006a6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    _usb_isr_invoke_sof_cb(usbp);
 8006a72:	686b      	ldr	r3, [r5, #4]
 8006a74:	68db      	ldr	r3, [r3, #12]
 8006a76:	2b00      	cmp	r3, #0
 8006a78:	d0c6      	beq.n	8006a08 <usb_lld_serve_interrupt.lto_priv.260+0x48>
 8006a7a:	4628      	mov	r0, r5
 8006a7c:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
 8006a7e:	02f9      	lsls	r1, r7, #11
 8006a80:	d5c4      	bpl.n	8006a0c <usb_lld_serve_interrupt.lto_priv.260+0x4c>
  stm32_otg_t *otgp = usbp->otg;
 8006a82:	f8d5 906c 	ldr.w	r9, [r5, #108]	; 0x6c
 8006a86:	2400      	movs	r4, #0
      _usb_isr_invoke_in_cb(usbp, ep);
 8006a88:	f04f 0a01 	mov.w	sl, #1
 8006a8c:	e006      	b.n	8006a9c <usb_lld_serve_interrupt.lto_priv.260+0xdc>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8006a8e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8006a90:	3401      	adds	r4, #1
 8006a92:	689b      	ldr	r3, [r3, #8]
 8006a94:	b2e4      	uxtb	r4, r4
 8006a96:	429c      	cmp	r4, r3
 8006a98:	46a0      	mov	r8, r4
 8006a9a:	d8b7      	bhi.n	8006a0c <usb_lld_serve_interrupt.lto_priv.260+0x4c>
 8006a9c:	eb09 1144 	add.w	r1, r9, r4, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8006aa0:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8006aa4:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8006aa8:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8006aac:	d1ef      	bne.n	8006a8e <usb_lld_serve_interrupt.lto_priv.260+0xce>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8006aae:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8006ab2:	2b00      	cmp	r3, #0
 8006ab4:	daeb      	bge.n	8006a8e <usb_lld_serve_interrupt.lto_priv.260+0xce>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8006ab6:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8006aba:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
 8006abe:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8006ac2:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8006ac6:	2b00      	cmp	r3, #0
 8006ac8:	dbfb      	blt.n	8006ac2 <usb_lld_serve_interrupt.lto_priv.260+0x102>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8006aca:	ea4f 1888 	mov.w	r8, r8, lsl #6
 8006ace:	6ee9      	ldr	r1, [r5, #108]	; 0x6c
 8006ad0:	f048 0320 	orr.w	r3, r8, #32
 8006ad4:	610b      	str	r3, [r1, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8006ad6:	690b      	ldr	r3, [r1, #16]
 8006ad8:	069b      	lsls	r3, r3, #26
 8006ada:	d4fc      	bmi.n	8006ad6 <usb_lld_serve_interrupt.lto_priv.260+0x116>
  chSysPolledDelayX(cycles);
 8006adc:	2012      	movs	r0, #18
 8006ade:	f7f9 fe8f 	bl	8000800 <chSysPolledDelayX>
      _usb_isr_invoke_in_cb(usbp, ep);
 8006ae2:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8006ae6:	8929      	ldrh	r1, [r5, #8]
 8006ae8:	68db      	ldr	r3, [r3, #12]
 8006aea:	fa0a fb04 	lsl.w	fp, sl, r4
 8006aee:	689b      	ldr	r3, [r3, #8]
 8006af0:	ea6f 080b 	mvn.w	r8, fp
 8006af4:	ea08 0101 	and.w	r1, r8, r1
 8006af8:	8129      	strh	r1, [r5, #8]
 8006afa:	b113      	cbz	r3, 8006b02 <usb_lld_serve_interrupt.lto_priv.260+0x142>
 8006afc:	4621      	mov	r1, r4
 8006afe:	4628      	mov	r0, r5
 8006b00:	4798      	blx	r3
 8006b02:	2320      	movs	r3, #32
 8006b04:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8006b08:	f7fa fb32 	bl	8001170 <_dbg_check_lock_from_isr>
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8006b0c:	f8d9 3834 	ldr.w	r3, [r9, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 8006b10:	6fa9      	ldr	r1, [r5, #120]	; 0x78
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8006b12:	ea08 0303 	and.w	r3, r8, r3
      usbp->txpending |= (1 << ep);
 8006b16:	ea41 010b 	orr.w	r1, r1, fp
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8006b1a:	f8c9 3834 	str.w	r3, [r9, #2100]	; 0x834
  chThdResumeI(trp, msg);
 8006b1e:	f105 007c 	add.w	r0, r5, #124	; 0x7c
      usbp->txpending |= (1 << ep);
 8006b22:	67a9      	str	r1, [r5, #120]	; 0x78
 8006b24:	f003 f914 	bl	8009d50 <chThdResumeI.constprop.70>
  _dbg_check_unlock_from_isr();
 8006b28:	f7fa fb0a 	bl	8001140 <_dbg_check_unlock_from_isr>
 8006b2c:	2300      	movs	r3, #0
 8006b2e:	f383 8811 	msr	BASEPRI, r3
 8006b32:	e7ac      	b.n	8006a8e <usb_lld_serve_interrupt.lto_priv.260+0xce>
 8006b34:	2320      	movs	r3, #32
 8006b36:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8006b3a:	f7fa fb19 	bl	8001170 <_dbg_check_lock_from_isr>
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8006b3e:	69b3      	ldr	r3, [r6, #24]
 8006b40:	f023 0310 	bic.w	r3, r3, #16
 8006b44:	61b3      	str	r3, [r6, #24]
 8006b46:	f105 007c 	add.w	r0, r5, #124	; 0x7c
 8006b4a:	f003 f901 	bl	8009d50 <chThdResumeI.constprop.70>
  _dbg_check_unlock_from_isr();
 8006b4e:	f7fa faf7 	bl	8001140 <_dbg_check_unlock_from_isr>
 8006b52:	2300      	movs	r3, #0
 8006b54:	f383 8811 	msr	BASEPRI, r3
 8006b58:	e75e      	b.n	8006a18 <usb_lld_serve_interrupt.lto_priv.260+0x58>
  stm32_otg_t *otgp = usbp->otg;
 8006b5a:	f8d5 806c 	ldr.w	r8, [r5, #108]	; 0x6c
 8006b5e:	2400      	movs	r4, #0
      _usb_isr_invoke_out_cb(usbp, ep);
 8006b60:	f04f 0901 	mov.w	r9, #1
 8006b64:	e006      	b.n	8006b74 <usb_lld_serve_interrupt.lto_priv.260+0x1b4>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8006b66:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8006b68:	3401      	adds	r4, #1
 8006b6a:	689b      	ldr	r3, [r3, #8]
 8006b6c:	b2e4      	uxtb	r4, r4
 8006b6e:	429c      	cmp	r4, r3
 8006b70:	f63f af4f 	bhi.w	8006a12 <usb_lld_serve_interrupt.lto_priv.260+0x52>
 8006b74:	eb08 1244 	add.w	r2, r8, r4, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8006b78:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8006b7c:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8006b80:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8006b84:	d1ef      	bne.n	8006b66 <usb_lld_serve_interrupt.lto_priv.260+0x1a6>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8006b86:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8006b8a:	2b00      	cmp	r3, #0
 8006b8c:	daeb      	bge.n	8006b66 <usb_lld_serve_interrupt.lto_priv.260+0x1a6>
      _usb_isr_invoke_out_cb(usbp, ep);
 8006b8e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8006b92:	896a      	ldrh	r2, [r5, #10]
 8006b94:	68d9      	ldr	r1, [r3, #12]
 8006b96:	fa09 f304 	lsl.w	r3, r9, r4
 8006b9a:	f8d1 a00c 	ldr.w	sl, [r1, #12]
 8006b9e:	ea22 0303 	bic.w	r3, r2, r3
 8006ba2:	816b      	strh	r3, [r5, #10]
 8006ba4:	f1ba 0f00 	cmp.w	sl, #0
 8006ba8:	d0dd      	beq.n	8006b66 <usb_lld_serve_interrupt.lto_priv.260+0x1a6>
 8006baa:	4621      	mov	r1, r4
 8006bac:	4628      	mov	r0, r5
 8006bae:	47d0      	blx	sl
 8006bb0:	e7d9      	b.n	8006b66 <usb_lld_serve_interrupt.lto_priv.260+0x1a6>
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8006bb2:	782a      	ldrb	r2, [r5, #0]
 8006bb4:	f885 2068 	strb.w	r2, [r5, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8006bb8:	686b      	ldr	r3, [r5, #4]
  usbp->state       = USB_SUSPENDED;
 8006bba:	2205      	movs	r2, #5
 8006bbc:	702a      	strb	r2, [r5, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8006bbe:	681b      	ldr	r3, [r3, #0]
    usbp->txpending = 0;
 8006bc0:	2200      	movs	r2, #0
 8006bc2:	67aa      	str	r2, [r5, #120]	; 0x78
 8006bc4:	2b00      	cmp	r3, #0
 8006bc6:	f43f af0e 	beq.w	80069e6 <usb_lld_serve_interrupt.lto_priv.260+0x26>
 8006bca:	2104      	movs	r1, #4
 8006bcc:	4628      	mov	r0, r5
 8006bce:	4798      	blx	r3
 8006bd0:	e709      	b.n	80069e6 <usb_lld_serve_interrupt.lto_priv.260+0x26>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8006bd2:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
 8006bd6:	079a      	lsls	r2, r3, #30
 8006bd8:	d005      	beq.n	8006be6 <usb_lld_serve_interrupt.lto_priv.260+0x226>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8006bda:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
 8006bde:	f023 0303 	bic.w	r3, r3, #3
 8006be2:	f8c6 3e00 	str.w	r3, [r6, #3584]	; 0xe00
    otgp->DCTL |= DCTL_RWUSIG;
 8006be6:	f8d6 3804 	ldr.w	r3, [r6, #2052]	; 0x804

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8006bea:	686a      	ldr	r2, [r5, #4]
 8006bec:	f043 0301 	orr.w	r3, r3, #1
 8006bf0:	f8c6 3804 	str.w	r3, [r6, #2052]	; 0x804
  usbp->state = usbp->saved_state;
 8006bf4:	f895 3068 	ldrb.w	r3, [r5, #104]	; 0x68
 8006bf8:	702b      	strb	r3, [r5, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8006bfa:	6813      	ldr	r3, [r2, #0]
 8006bfc:	2b00      	cmp	r3, #0
 8006bfe:	f43f aeef 	beq.w	80069e0 <usb_lld_serve_interrupt.lto_priv.260+0x20>
 8006c02:	2105      	movs	r1, #5
 8006c04:	4628      	mov	r0, r5
 8006c06:	4798      	blx	r3
 8006c08:	e6ea      	b.n	80069e0 <usb_lld_serve_interrupt.lto_priv.260+0x20>
    usbp->txpending = 0;
 8006c0a:	2300      	movs	r3, #0
  usbp->state         = USB_READY;
 8006c0c:	2102      	movs	r1, #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8006c0e:	2220      	movs	r2, #32
    usbp->txpending = 0;
 8006c10:	6783      	str	r3, [r0, #120]	; 0x78
  usbp->status        = 0;
 8006c12:	f8a0 3064 	strh.w	r3, [r0, #100]	; 0x64
  usbp->address       = 0;
 8006c16:	f880 3066 	strb.w	r3, [r0, #102]	; 0x66
  usbp->configuration = 0;
 8006c1a:	f880 3067 	strb.w	r3, [r0, #103]	; 0x67
  usbp->transmitting  = 0;
 8006c1e:	8103      	strh	r3, [r0, #8]
  usbp->receiving     = 0;
 8006c20:	8143      	strh	r3, [r0, #10]
    usbp->epc[i] = NULL;
 8006c22:	60c3      	str	r3, [r0, #12]
 8006c24:	6103      	str	r3, [r0, #16]
 8006c26:	6143      	str	r3, [r0, #20]
 8006c28:	6183      	str	r3, [r0, #24]
 8006c2a:	61c3      	str	r3, [r0, #28]
 8006c2c:	6203      	str	r3, [r0, #32]
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006c2e:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  usbp->state         = USB_READY;
 8006c32:	7001      	strb	r1, [r0, #0]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8006c34:	6132      	str	r2, [r6, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8006c36:	6934      	ldr	r4, [r6, #16]
 8006c38:	f014 0420 	ands.w	r4, r4, #32
 8006c3c:	d1fb      	bne.n	8006c36 <usb_lld_serve_interrupt.lto_priv.260+0x276>
  chSysPolledDelayX(cycles);
 8006c3e:	2012      	movs	r0, #18
 8006c40:	f7f9 fdde 	bl	8000800 <chSysPolledDelayX>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8006c44:	6f2f      	ldr	r7, [r5, #112]	; 0x70
  otgp->DIEPEMPMSK = 0;
 8006c46:	f8c6 4834 	str.w	r4, [r6, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8006c4a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8006c4e:	68b8      	ldr	r0, [r7, #8]
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8006c50:	f8c6 381c 	str.w	r3, [r6, #2076]	; 0x81c
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8006c54:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8006c58:	f04f 32ff 	mov.w	r2, #4294967295
 8006c5c:	eb06 1344 	add.w	r3, r6, r4, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8006c60:	3401      	adds	r4, #1
 8006c62:	4284      	cmp	r4, r0
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8006c64:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8006c68:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8006c6c:	f8c3 2908 	str.w	r2, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8006c70:	f8c3 2b08 	str.w	r2, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8006c74:	d9f2      	bls.n	8006c5c <usb_lld_serve_interrupt.lto_priv.260+0x29c>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8006c76:	683b      	ldr	r3, [r7, #0]
 8006c78:	676b      	str	r3, [r5, #116]	; 0x74
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8006c7a:	683a      	ldr	r2, [r7, #0]
 8006c7c:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 8006c7e:	6272      	str	r2, [r6, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8006c80:	2210      	movs	r2, #16
 8006c82:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8006c84:	691c      	ldr	r4, [r3, #16]
 8006c86:	f014 0410 	ands.w	r4, r4, #16
 8006c8a:	d1fb      	bne.n	8006c84 <usb_lld_serve_interrupt.lto_priv.260+0x2c4>
 8006c8c:	2012      	movs	r0, #18
 8006c8e:	f7f9 fdb7 	bl	8000800 <chSysPolledDelayX>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8006c92:	f8d6 3800 	ldr.w	r3, [r6, #2048]	; 0x800
 8006c96:	6f28      	ldr	r0, [r5, #112]	; 0x70
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8006c98:	4a3b      	ldr	r2, [pc, #236]	; (8006d88 <usb_lld_serve_interrupt.lto_priv.260+0x3c8>)
  usbp->epc[0] = &ep0config;
 8006c9a:	4f3c      	ldr	r7, [pc, #240]	; (8006d8c <usb_lld_serve_interrupt.lto_priv.260+0x3cc>)
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8006c9c:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8006ca0:	f8c6 3800 	str.w	r3, [r6, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8006ca4:	69b3      	ldr	r3, [r6, #24]
 8006ca6:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8006caa:	2109      	movs	r1, #9
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8006cac:	f043 0310 	orr.w	r3, r3, #16
 8006cb0:	61b3      	str	r3, [r6, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8006cb2:	f8c6 1810 	str.w	r1, [r6, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8006cb6:	f8c6 1814 	str.w	r1, [r6, #2068]	; 0x814
  usbp->epc[0] = &ep0config;
 8006cba:	60ef      	str	r7, [r5, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 8006cbc:	f8c6 4b10 	str.w	r4, [r6, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8006cc0:	f8c6 2b00 	str.w	r2, [r6, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 8006cc4:	f8c6 4910 	str.w	r4, [r6, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8006cc8:	f8c6 2900 	str.w	r2, [r6, #2304]	; 0x900
  next = usbp->pmnext;
 8006ccc:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  usbp->pmnext += size;
 8006cce:	f103 0210 	add.w	r2, r3, #16
 8006cd2:	676a      	str	r2, [r5, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8006cd4:	6841      	ldr	r1, [r0, #4]
 8006cd6:	428a      	cmp	r2, r1
 8006cd8:	d81c      	bhi.n	8006d14 <usb_lld_serve_interrupt.lto_priv.260+0x354>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8006cda:	686a      	ldr	r2, [r5, #4]
 8006cdc:	6812      	ldr	r2, [r2, #0]
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8006cde:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8006ce2:	62b3      	str	r3, [r6, #40]	; 0x28
 8006ce4:	2a00      	cmp	r2, #0
 8006ce6:	f43f aec1 	beq.w	8006a6c <usb_lld_serve_interrupt.lto_priv.260+0xac>
 8006cea:	4621      	mov	r1, r4
 8006cec:	4628      	mov	r0, r5
}
 8006cee:	b001      	add	sp, #4
 8006cf0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006cf4:	4710      	bx	r2
      otg_epin_handler(usbp, 5);
 8006cf6:	4628      	mov	r0, r5
 8006cf8:	2105      	movs	r1, #5
}
 8006cfa:	b001      	add	sp, #4
 8006cfc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      otg_epin_handler(usbp, 5);
 8006d00:	f7ff bdf6 	b.w	80068f0 <otg_epin_handler>
      otg_epout_handler(usbp, 5);
 8006d04:	2105      	movs	r1, #5
 8006d06:	4628      	mov	r0, r5
 8006d08:	f7ff fd9a 	bl	8006840 <otg_epout_handler>
  if (sts & GINTSTS_IEPINT) {
 8006d0c:	037b      	lsls	r3, r7, #13
 8006d0e:	f57f aead 	bpl.w	8006a6c <usb_lld_serve_interrupt.lto_priv.260+0xac>
 8006d12:	e699      	b.n	8006a48 <usb_lld_serve_interrupt.lto_priv.260+0x88>
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8006d14:	481e      	ldr	r0, [pc, #120]	; (8006d90 <usb_lld_serve_interrupt.lto_priv.260+0x3d0>)
 8006d16:	f7f9 fd83 	bl	8000820 <chSysHalt>
      otg_epin_handler(usbp, 4);
 8006d1a:	2104      	movs	r1, #4
 8006d1c:	4628      	mov	r0, r5
 8006d1e:	f7ff fde7 	bl	80068f0 <otg_epin_handler>
 8006d22:	e6a0      	b.n	8006a66 <usb_lld_serve_interrupt.lto_priv.260+0xa6>
      otg_epin_handler(usbp, 3);
 8006d24:	2103      	movs	r1, #3
 8006d26:	4628      	mov	r0, r5
 8006d28:	f7ff fde2 	bl	80068f0 <otg_epin_handler>
 8006d2c:	e698      	b.n	8006a60 <usb_lld_serve_interrupt.lto_priv.260+0xa0>
      otg_epin_handler(usbp, 0);
 8006d2e:	2100      	movs	r1, #0
 8006d30:	4628      	mov	r0, r5
 8006d32:	f7ff fddd 	bl	80068f0 <otg_epin_handler>
    if (src & (1 << 1))
 8006d36:	07a6      	lsls	r6, r4, #30
 8006d38:	f57f ae8c 	bpl.w	8006a54 <usb_lld_serve_interrupt.lto_priv.260+0x94>
      otg_epin_handler(usbp, 1);
 8006d3c:	4628      	mov	r0, r5
 8006d3e:	2101      	movs	r1, #1
 8006d40:	f7ff fdd6 	bl	80068f0 <otg_epin_handler>
    if (src & (1 << 2))
 8006d44:	0760      	lsls	r0, r4, #29
 8006d46:	f57f ae88 	bpl.w	8006a5a <usb_lld_serve_interrupt.lto_priv.260+0x9a>
      otg_epin_handler(usbp, 2);
 8006d4a:	2102      	movs	r1, #2
 8006d4c:	4628      	mov	r0, r5
 8006d4e:	f7ff fdcf 	bl	80068f0 <otg_epin_handler>
 8006d52:	e682      	b.n	8006a5a <usb_lld_serve_interrupt.lto_priv.260+0x9a>
      otg_epout_handler(usbp, 4);
 8006d54:	2104      	movs	r1, #4
 8006d56:	4628      	mov	r0, r5
 8006d58:	f7ff fd72 	bl	8006840 <otg_epout_handler>
 8006d5c:	e66f      	b.n	8006a3e <usb_lld_serve_interrupt.lto_priv.260+0x7e>
      otg_epout_handler(usbp, 3);
 8006d5e:	2103      	movs	r1, #3
 8006d60:	4628      	mov	r0, r5
 8006d62:	f7ff fd6d 	bl	8006840 <otg_epout_handler>
 8006d66:	e667      	b.n	8006a38 <usb_lld_serve_interrupt.lto_priv.260+0x78>
      otg_epout_handler(usbp, 2);
 8006d68:	2102      	movs	r1, #2
 8006d6a:	4628      	mov	r0, r5
 8006d6c:	f7ff fd68 	bl	8006840 <otg_epout_handler>
 8006d70:	e65f      	b.n	8006a32 <usb_lld_serve_interrupt.lto_priv.260+0x72>
      otg_epout_handler(usbp, 1);
 8006d72:	2101      	movs	r1, #1
 8006d74:	4628      	mov	r0, r5
 8006d76:	f7ff fd63 	bl	8006840 <otg_epout_handler>
 8006d7a:	e657      	b.n	8006a2c <usb_lld_serve_interrupt.lto_priv.260+0x6c>
      otg_epout_handler(usbp, 0);
 8006d7c:	2100      	movs	r1, #0
 8006d7e:	4628      	mov	r0, r5
 8006d80:	f7ff fd5e 	bl	8006840 <otg_epout_handler>
 8006d84:	e64f      	b.n	8006a26 <usb_lld_serve_interrupt.lto_priv.260+0x66>
 8006d86:	bf00      	nop
 8006d88:	10008040 	.word	0x10008040
 8006d8c:	0800b5a4 	.word	0x0800b5a4
 8006d90:	0800b538 	.word	0x0800b538
	...

08006da0 <usbStartTransmitI>:
                       const uint8_t *buf, size_t n) {
 8006da0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006da4:	4605      	mov	r5, r0
 8006da6:	460e      	mov	r6, r1
 8006da8:	4690      	mov	r8, r2
 8006daa:	4699      	mov	r9, r3
  osalDbgCheckClassI();
 8006dac:	f7f9 fd88 	bl	80008c0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8006db0:	b1cd      	cbz	r5, 8006de6 <usbStartTransmitI+0x46>
 8006db2:	2e05      	cmp	r6, #5
 8006db4:	d817      	bhi.n	8006de6 <usbStartTransmitI+0x46>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8006db6:	2401      	movs	r4, #1
 8006db8:	40b4      	lsls	r4, r6
 8006dba:	8928      	ldrh	r0, [r5, #8]
 8006dbc:	b2a4      	uxth	r4, r4
 8006dbe:	ea10 0704 	ands.w	r7, r0, r4
 8006dc2:	d110      	bne.n	8006de6 <usbStartTransmitI+0x46>
  isp = usbp->epc[ep]->in_state;
 8006dc4:	eb05 0386 	add.w	r3, r5, r6, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006dc8:	4304      	orrs	r4, r0
  isp = usbp->epc[ep]->in_state;
 8006dca:	68db      	ldr	r3, [r3, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006dcc:	812c      	strh	r4, [r5, #8]
  isp = usbp->epc[ep]->in_state;
 8006dce:	6958      	ldr	r0, [r3, #20]
  usb_lld_start_in(usbp, ep);
 8006dd0:	4631      	mov	r1, r6
  isp->txbuf  = buf;
 8006dd2:	f8c0 8008 	str.w	r8, [r0, #8]
  isp->txsize = n;
 8006dd6:	f8c0 9000 	str.w	r9, [r0]
  isp->txcnt  = 0;
 8006dda:	6047      	str	r7, [r0, #4]
  usb_lld_start_in(usbp, ep);
 8006ddc:	4628      	mov	r0, r5
}
 8006dde:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  usb_lld_start_in(usbp, ep);
 8006de2:	f002 bd85 	b.w	80098f0 <usb_lld_start_in>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8006de6:	4801      	ldr	r0, [pc, #4]	; (8006dec <usbStartTransmitI+0x4c>)
 8006de8:	f7f9 fd1a 	bl	8000820 <chSysHalt>
 8006dec:	0800b574 	.word	0x0800b574

08006df0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8006df0:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8006df2:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8006df6:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8006df8:	2b06      	cmp	r3, #6
 8006dfa:	d805      	bhi.n	8006e08 <_usb_ep0out+0x18>
 8006dfc:	e8df f003 	tbb	[pc, r3]
 8006e00:	1b040404 	.word	0x1b040404
 8006e04:	0407      	.short	0x0407
 8006e06:	26          	.byte	0x26
 8006e07:	00          	.byte	0x00
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8006e08:	481c      	ldr	r0, [pc, #112]	; (8006e7c <_usb_ep0out+0x8c>)
 8006e0a:	f7f9 fd09 	bl	8000820 <chSysHalt>
    usbp->ep0state = USB_EP0_SENDING_STS;
 8006e0e:	2305      	movs	r3, #5
 8006e10:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
 8006e14:	2320      	movs	r3, #32
 8006e16:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8006e1a:	f7fa f9a9 	bl	8001170 <_dbg_check_lock_from_isr>
    usbStartTransmitI(usbp, 0, NULL, 0);
 8006e1e:	2300      	movs	r3, #0
 8006e20:	461a      	mov	r2, r3
 8006e22:	4619      	mov	r1, r3
 8006e24:	4620      	mov	r0, r4
 8006e26:	f7ff ffbb 	bl	8006da0 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8006e2a:	f7fa f989 	bl	8001140 <_dbg_check_unlock_from_isr>
 8006e2e:	2300      	movs	r3, #0
 8006e30:	f383 8811 	msr	BASEPRI, r3
 8006e34:	bd38      	pop	{r3, r4, r5, pc}
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8006e36:	68c3      	ldr	r3, [r0, #12]
 8006e38:	699b      	ldr	r3, [r3, #24]
 8006e3a:	685b      	ldr	r3, [r3, #4]
 8006e3c:	b9e3      	cbnz	r3, 8006e78 <_usb_ep0out+0x88>
    if (usbp->ep0endcb != NULL) {
 8006e3e:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8006e40:	b103      	cbz	r3, 8006e44 <_usb_ep0out+0x54>
      usbp->ep0endcb(usbp);
 8006e42:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006e44:	2300      	movs	r3, #0
 8006e46:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006e4a:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8006e4c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8006e4e:	6841      	ldr	r1, [r0, #4]
 8006e50:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8006e54:	680d      	ldr	r5, [r1, #0]
 8006e56:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8006e5a:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8006e5e:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8006e62:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8006e66:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8006e6a:	b10d      	cbz	r5, 8006e70 <_usb_ep0out+0x80>
 8006e6c:	2106      	movs	r1, #6
 8006e6e:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8006e70:	2306      	movs	r3, #6
 8006e72:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006e76:	bd38      	pop	{r3, r4, r5, pc}
 8006e78:	bd38      	pop	{r3, r4, r5, pc}
 8006e7a:	bf00      	nop
 8006e7c:	0800b594 	.word	0x0800b594

08006e80 <usbStartReceiveI>:
                      uint8_t *buf, size_t n) {
 8006e80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006e84:	4605      	mov	r5, r0
 8006e86:	460e      	mov	r6, r1
 8006e88:	4690      	mov	r8, r2
 8006e8a:	4699      	mov	r9, r3
  osalDbgCheckClassI();
 8006e8c:	f7f9 fd18 	bl	80008c0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8006e90:	b1cd      	cbz	r5, 8006ec6 <usbStartReceiveI+0x46>
 8006e92:	2e05      	cmp	r6, #5
 8006e94:	d817      	bhi.n	8006ec6 <usbStartReceiveI+0x46>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8006e96:	2401      	movs	r4, #1
 8006e98:	40b4      	lsls	r4, r6
 8006e9a:	8968      	ldrh	r0, [r5, #10]
 8006e9c:	b2a4      	uxth	r4, r4
 8006e9e:	ea10 0704 	ands.w	r7, r0, r4
 8006ea2:	d110      	bne.n	8006ec6 <usbStartReceiveI+0x46>
  osp = usbp->epc[ep]->out_state;
 8006ea4:	eb05 0386 	add.w	r3, r5, r6, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006ea8:	4304      	orrs	r4, r0
  osp = usbp->epc[ep]->out_state;
 8006eaa:	68db      	ldr	r3, [r3, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006eac:	816c      	strh	r4, [r5, #10]
  osp = usbp->epc[ep]->out_state;
 8006eae:	6998      	ldr	r0, [r3, #24]
  usb_lld_start_out(usbp, ep);
 8006eb0:	4631      	mov	r1, r6
  osp->rxbuf  = buf;
 8006eb2:	f8c0 8008 	str.w	r8, [r0, #8]
  osp->rxsize = n;
 8006eb6:	f8c0 9000 	str.w	r9, [r0]
  osp->rxcnt  = 0;
 8006eba:	6047      	str	r7, [r0, #4]
  usb_lld_start_out(usbp, ep);
 8006ebc:	4628      	mov	r0, r5
}
 8006ebe:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  usb_lld_start_out(usbp, ep);
 8006ec2:	f002 bd6d 	b.w	80099a0 <usb_lld_start_out>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8006ec6:	4801      	ldr	r0, [pc, #4]	; (8006ecc <usbStartReceiveI+0x4c>)
 8006ec8:	f7f9 fcaa 	bl	8000820 <chSysHalt>
 8006ecc:	0800b560 	.word	0x0800b560

08006ed0 <_usb_ep0in>:
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8006ed0:	b538      	push	{r3, r4, r5, lr}
  switch (usbp->ep0state) {
 8006ed2:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8006ed6:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8006ed8:	2b06      	cmp	r3, #6
 8006eda:	d805      	bhi.n	8006ee8 <_usb_ep0in+0x18>
 8006edc:	e8df f003 	tbb	[pc, r3]
 8006ee0:	04170704 	.word	0x04170704
 8006ee4:	2b04      	.short	0x2b04
 8006ee6:	32          	.byte	0x32
 8006ee7:	00          	.byte	0x00
    osalDbgAssert(false, "EP0 state machine invalid state");
 8006ee8:	482b      	ldr	r0, [pc, #172]	; (8006f98 <_usb_ep0in+0xc8>)
 8006eea:	f7f9 fc99 	bl	8000820 <chSysHalt>
  hw |= (uint16_t)*p << 8U;
 8006eee:	f890 1063 	ldrb.w	r1, [r0, #99]	; 0x63
 8006ef2:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
    if ((usbp->ep0n < max) &&
 8006ef6:	6d42      	ldr	r2, [r0, #84]	; 0x54
    max = (size_t)get_hword(&usbp->setup[6]);
 8006ef8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    if ((usbp->ep0n < max) &&
 8006efc:	4293      	cmp	r3, r2
 8006efe:	d906      	bls.n	8006f0e <_usb_ep0in+0x3e>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8006f00:	68c3      	ldr	r3, [r0, #12]
 8006f02:	8a1b      	ldrh	r3, [r3, #16]
 8006f04:	fbb2 f5f3 	udiv	r5, r2, r3
 8006f08:	fb03 2515 	mls	r5, r3, r5, r2
    if ((usbp->ep0n < max) &&
 8006f0c:	b385      	cbz	r5, 8006f70 <_usb_ep0in+0xa0>
    usbp->ep0state = USB_EP0_WAITING_STS;
 8006f0e:	2303      	movs	r3, #3
 8006f10:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006f14:	2320      	movs	r3, #32
 8006f16:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8006f1a:	f7fa f929 	bl	8001170 <_dbg_check_lock_from_isr>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8006f1e:	2300      	movs	r3, #0
 8006f20:	461a      	mov	r2, r3
 8006f22:	4619      	mov	r1, r3
 8006f24:	4620      	mov	r0, r4
 8006f26:	f7ff ffab 	bl	8006e80 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
 8006f2a:	f7fa f909 	bl	8001140 <_dbg_check_unlock_from_isr>
 8006f2e:	2300      	movs	r3, #0
 8006f30:	f383 8811 	msr	BASEPRI, r3
 8006f34:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
 8006f36:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8006f38:	b103      	cbz	r3, 8006f3c <_usb_ep0in+0x6c>
      usbp->ep0endcb(usbp);
 8006f3a:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006f3c:	2300      	movs	r3, #0
 8006f3e:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006f42:	bd38      	pop	{r3, r4, r5, pc}
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8006f44:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8006f46:	6841      	ldr	r1, [r0, #4]
 8006f48:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8006f4c:	680d      	ldr	r5, [r1, #0]
 8006f4e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8006f52:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8006f56:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8006f5a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8006f5e:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8006f62:	b10d      	cbz	r5, 8006f68 <_usb_ep0in+0x98>
 8006f64:	2106      	movs	r1, #6
 8006f66:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8006f68:	2306      	movs	r3, #6
 8006f6a:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006f6e:	bd38      	pop	{r3, r4, r5, pc}
 8006f70:	2320      	movs	r3, #32
 8006f72:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8006f76:	f7fa f8fb 	bl	8001170 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8006f7a:	462b      	mov	r3, r5
 8006f7c:	462a      	mov	r2, r5
 8006f7e:	4629      	mov	r1, r5
 8006f80:	4620      	mov	r0, r4
 8006f82:	f7ff ff0d 	bl	8006da0 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8006f86:	f7fa f8db 	bl	8001140 <_dbg_check_unlock_from_isr>
 8006f8a:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8006f8e:	2302      	movs	r3, #2
 8006f90:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006f94:	bd38      	pop	{r3, r4, r5, pc}
 8006f96:	bf00      	nop
 8006f98:	0800b588 	.word	0x0800b588
 8006f9c:	00000000 	.word	0x00000000

08006fa0 <_usb_ep0setup>:
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8006fa0:	eb00 0181 	add.w	r1, r0, r1, lsl #2
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006fa4:	2300      	movs	r3, #0
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8006fa6:	b570      	push	{r4, r5, r6, lr}
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006fa8:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
 8006fac:	68cb      	ldr	r3, [r1, #12]
  if ((usbp->config->requests_hook_cb == NULL) ||
 8006fae:	6842      	ldr	r2, [r0, #4]
 8006fb0:	6a1b      	ldr	r3, [r3, #32]
 8006fb2:	6819      	ldr	r1, [r3, #0]
 8006fb4:	685b      	ldr	r3, [r3, #4]
 8006fb6:	6603      	str	r3, [r0, #96]	; 0x60
 8006fb8:	65c1      	str	r1, [r0, #92]	; 0x5c
 8006fba:	6893      	ldr	r3, [r2, #8]
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8006fbc:	4604      	mov	r4, r0
  if ((usbp->config->requests_hook_cb == NULL) ||
 8006fbe:	b33b      	cbz	r3, 8007010 <_usb_ep0setup+0x70>
      !(usbp->config->requests_hook_cb(usbp))) {
 8006fc0:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 8006fc2:	b328      	cbz	r0, 8007010 <_usb_ep0setup+0x70>
 8006fc4:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8006fc6:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
  hw |= (uint16_t)*p << 8U;
 8006fca:	f894 0063 	ldrb.w	r0, [r4, #99]	; 0x63
 8006fce:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
  max = (size_t)get_hword(&usbp->setup[6]);
 8006fd2:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  if (usbp->ep0n > max) {
 8006fd6:	428a      	cmp	r2, r1
 8006fd8:	bf2c      	ite	cs
 8006fda:	460a      	movcs	r2, r1
    usbp->ep0n = max;
 8006fdc:	6562      	strcc	r2, [r4, #84]	; 0x54
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8006fde:	0619      	lsls	r1, r3, #24
 8006fe0:	f100 808b 	bmi.w	80070fa <_usb_ep0setup+0x15a>
    if (usbp->ep0n != 0U) {
 8006fe4:	2a00      	cmp	r2, #0
 8006fe6:	d152      	bne.n	800708e <_usb_ep0setup+0xee>
      usbp->ep0state = USB_EP0_SENDING_STS;
 8006fe8:	2305      	movs	r3, #5
 8006fea:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006fee:	2320      	movs	r3, #32
 8006ff0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8006ff4:	f7fa f8bc 	bl	8001170 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8006ff8:	2300      	movs	r3, #0
 8006ffa:	4620      	mov	r0, r4
 8006ffc:	461a      	mov	r2, r3
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8006ffe:	2100      	movs	r1, #0
 8007000:	f7ff fece 	bl	8006da0 <usbStartTransmitI>
  _dbg_check_unlock_from_isr();
 8007004:	f7fa f89c 	bl	8001140 <_dbg_check_unlock_from_isr>
 8007008:	2300      	movs	r3, #0
 800700a:	f383 8811 	msr	BASEPRI, r3
 800700e:	bd70      	pop	{r4, r5, r6, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8007010:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 8007014:	f013 0560 	ands.w	r5, r3, #96	; 0x60
 8007018:	4619      	mov	r1, r3
 800701a:	d016      	beq.n	800704a <_usb_ep0setup+0xaa>
 800701c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800701e:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8007022:	6861      	ldr	r1, [r4, #4]
 8007024:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8007028:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800702c:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8007030:	680d      	ldr	r5, [r1, #0]
 8007032:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8007036:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 800703a:	b115      	cbz	r5, 8007042 <_usb_ep0setup+0xa2>
 800703c:	2106      	movs	r1, #6
 800703e:	4620      	mov	r0, r4
 8007040:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
 8007042:	2306      	movs	r3, #6
 8007044:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8007048:	bd70      	pop	{r4, r5, r6, pc}
           ((uint32_t)usbp->setup[1] << 8U))) {
 800704a:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800704e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 8007052:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8007056:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 800705a:	f000 8104 	beq.w	8007266 <_usb_ep0setup+0x2c6>
 800705e:	d92a      	bls.n	80070b6 <_usb_ep0setup+0x116>
 8007060:	f5b2 6fc0 	cmp.w	r2, #1536	; 0x600
 8007064:	f000 80e6 	beq.w	8007234 <_usb_ep0setup+0x294>
 8007068:	d954      	bls.n	8007114 <_usb_ep0setup+0x174>
 800706a:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
 800706e:	d072      	beq.n	8007156 <_usb_ep0setup+0x1b6>
 8007070:	f640 4102 	movw	r1, #3074	; 0xc02
 8007074:	428a      	cmp	r2, r1
 8007076:	f000 80c4 	beq.w	8007202 <_usb_ep0setup+0x262>
 800707a:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800707e:	d1cd      	bne.n	800701c <_usb_ep0setup+0x7c>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8007080:	f104 0267 	add.w	r2, r4, #103	; 0x67
 8007084:	2101      	movs	r1, #1
 8007086:	65a5      	str	r5, [r4, #88]	; 0x58
 8007088:	6522      	str	r2, [r4, #80]	; 0x50
 800708a:	6561      	str	r1, [r4, #84]	; 0x54
 800708c:	e79d      	b.n	8006fca <_usb_ep0setup+0x2a>
      usbp->ep0state = USB_EP0_RX;
 800708e:	2304      	movs	r3, #4
 8007090:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8007094:	2320      	movs	r3, #32
 8007096:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 800709a:	f7fa f869 	bl	8001170 <_dbg_check_lock_from_isr>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800709e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80070a0:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80070a2:	4620      	mov	r0, r4
 80070a4:	2100      	movs	r1, #0
 80070a6:	f7ff feeb 	bl	8006e80 <usbStartReceiveI>
  _dbg_check_unlock_from_isr();
 80070aa:	f7fa f849 	bl	8001140 <_dbg_check_unlock_from_isr>
 80070ae:	2300      	movs	r3, #0
 80070b0:	f383 8811 	msr	BASEPRI, r3
 80070b4:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80070b6:	2a02      	cmp	r2, #2
 80070b8:	f000 80aa 	beq.w	8007210 <_usb_ep0setup+0x270>
 80070bc:	f240 8096 	bls.w	80071ec <_usb_ep0setup+0x24c>
 80070c0:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80070c4:	d076      	beq.n	80071b4 <_usb_ep0setup+0x214>
 80070c6:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
 80070ca:	d1a7      	bne.n	800701c <_usb_ep0setup+0x7c>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80070cc:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 80070d0:	2b00      	cmp	r3, #0
 80070d2:	d1a3      	bne.n	800701c <_usb_ep0setup+0x7c>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80070d4:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
 80070d8:	f013 020f 	ands.w	r2, r3, #15
 80070dc:	d028      	beq.n	8007130 <_usb_ep0setup+0x190>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80070de:	f013 0f80 	tst.w	r3, #128	; 0x80
 80070e2:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80070e4:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80070e8:	f040 80e6 	bne.w	80072b8 <_usb_ep0setup+0x318>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 80070ec:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80070f0:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80070f4:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 80070f8:	e01a      	b.n	8007130 <_usb_ep0setup+0x190>
    if (usbp->ep0n != 0U) {
 80070fa:	b302      	cbz	r2, 800713e <_usb_ep0setup+0x19e>
      usbp->ep0state = USB_EP0_TX;
 80070fc:	2301      	movs	r3, #1
 80070fe:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8007102:	2320      	movs	r3, #32
 8007104:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8007108:	f7fa f832 	bl	8001170 <_dbg_check_lock_from_isr>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800710c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800710e:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8007110:	4620      	mov	r0, r4
 8007112:	e774      	b.n	8006ffe <_usb_ep0setup+0x5e>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8007114:	f240 3302 	movw	r3, #770	; 0x302
 8007118:	429a      	cmp	r2, r3
 800711a:	d033      	beq.n	8007184 <_usb_ep0setup+0x1e4>
 800711c:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8007120:	f47f af7c 	bne.w	800701c <_usb_ep0setup+0x7c>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8007124:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 8007128:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800712c:	f000 80ac 	beq.w	8007288 <_usb_ep0setup+0x2e8>
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8007130:	2300      	movs	r3, #0
 8007132:	6523      	str	r3, [r4, #80]	; 0x50
 8007134:	6563      	str	r3, [r4, #84]	; 0x54
 8007136:	65a3      	str	r3, [r4, #88]	; 0x58
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8007138:	060b      	lsls	r3, r1, #24
 800713a:	f57f af55 	bpl.w	8006fe8 <_usb_ep0setup+0x48>
      usbp->ep0state = USB_EP0_WAITING_STS;
 800713e:	2303      	movs	r3, #3
 8007140:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8007144:	2320      	movs	r3, #32
 8007146:	f383 8811 	msr	BASEPRI, r3
 800714a:	f7fa f811 	bl	8001170 <_dbg_check_lock_from_isr>
      usbStartReceiveI(usbp, 0, NULL, 0);
 800714e:	2300      	movs	r3, #0
 8007150:	4620      	mov	r0, r4
 8007152:	461a      	mov	r2, r3
 8007154:	e7a6      	b.n	80070a4 <_usb_ep0setup+0x104>
    if (usbp->configuration != usbp->setup[2]) {
 8007156:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 800715a:	f894 2067 	ldrb.w	r2, [r4, #103]	; 0x67
 800715e:	429a      	cmp	r2, r3
 8007160:	d0e6      	beq.n	8007130 <_usb_ep0setup+0x190>
      if (usbp->state == USB_ACTIVE) {
 8007162:	7822      	ldrb	r2, [r4, #0]
 8007164:	2a04      	cmp	r2, #4
 8007166:	d034      	beq.n	80071d2 <_usb_ep0setup+0x232>
      if (usbp->setup[2] != 0U) {
 8007168:	b14b      	cbz	r3, 800717e <_usb_ep0setup+0x1de>
        usbp->state = USB_ACTIVE;
 800716a:	2104      	movs	r1, #4
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800716c:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
 800716e:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 8007172:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8007174:	6813      	ldr	r3, [r2, #0]
 8007176:	b113      	cbz	r3, 800717e <_usb_ep0setup+0x1de>
 8007178:	2102      	movs	r1, #2
 800717a:	4620      	mov	r0, r4
 800717c:	4798      	blx	r3
 800717e:	f894 105c 	ldrb.w	r1, [r4, #92]	; 0x5c
 8007182:	e7d5      	b.n	8007130 <_usb_ep0setup+0x190>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8007184:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 8007188:	2b00      	cmp	r3, #0
 800718a:	f47f af47 	bne.w	800701c <_usb_ep0setup+0x7c>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800718e:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
 8007192:	f013 020f 	ands.w	r2, r3, #15
 8007196:	d0cb      	beq.n	8007130 <_usb_ep0setup+0x190>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8007198:	f013 0f80 	tst.w	r3, #128	; 0x80
 800719c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800719e:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80071a2:	f040 8090 	bne.w	80072c6 <_usb_ep0setup+0x326>
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80071a6:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80071aa:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80071ae:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 80071b2:	e7bd      	b.n	8007130 <_usb_ep0setup+0x190>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80071b4:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 80071b8:	2b01      	cmp	r3, #1
 80071ba:	f47f af2f 	bne.w	800701c <_usb_ep0setup+0x7c>
      usbp->status &= ~2U;
 80071be:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80071c2:	6525      	str	r5, [r4, #80]	; 0x50
      usbp->status &= ~2U;
 80071c4:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80071c8:	6565      	str	r5, [r4, #84]	; 0x54
 80071ca:	65a5      	str	r5, [r4, #88]	; 0x58
      usbp->status &= ~2U;
 80071cc:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 80071d0:	e7b2      	b.n	8007138 <_usb_ep0setup+0x198>
 80071d2:	2320      	movs	r3, #32
 80071d4:	f383 8811 	msr	BASEPRI, r3
 80071d8:	f7f9 ffca 	bl	8001170 <_dbg_check_lock_from_isr>
  osalDbgCheckClassI();
 80071dc:	f7f9 fb70 	bl	80008c0 <chDbgCheckClassI>
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 80071e0:	7823      	ldrb	r3, [r4, #0]
 80071e2:	2b04      	cmp	r3, #4
 80071e4:	d076      	beq.n	80072d4 <_usb_ep0setup+0x334>
 80071e6:	4858      	ldr	r0, [pc, #352]	; (8007348 <_usb_ep0setup+0x3a8>)
 80071e8:	f7f9 fb1a 	bl	8000820 <chSysHalt>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80071ec:	b932      	cbnz	r2, 80071fc <_usb_ep0setup+0x25c>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 80071ee:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80071f2:	2102      	movs	r1, #2
 80071f4:	65a2      	str	r2, [r4, #88]	; 0x58
 80071f6:	6520      	str	r0, [r4, #80]	; 0x50
 80071f8:	6561      	str	r1, [r4, #84]	; 0x54
 80071fa:	e6e6      	b.n	8006fca <_usb_ep0setup+0x2a>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80071fc:	2a01      	cmp	r2, #1
 80071fe:	f47f af0d 	bne.w	800701c <_usb_ep0setup+0x7c>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8007202:	4a52      	ldr	r2, [pc, #328]	; (800734c <_usb_ep0setup+0x3ac>)
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8007204:	6522      	str	r2, [r4, #80]	; 0x50
 8007206:	2102      	movs	r1, #2
 8007208:	2200      	movs	r2, #0
 800720a:	6561      	str	r1, [r4, #84]	; 0x54
 800720c:	65a2      	str	r2, [r4, #88]	; 0x58
 800720e:	e6dc      	b.n	8006fca <_usb_ep0setup+0x2a>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8007210:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
  ctl = usbp->otg->ie[ep].DIEPCTL;
 8007214:	f002 010f 	and.w	r1, r2, #15
 8007218:	0616      	lsls	r6, r2, #24
 800721a:	bf4c      	ite	mi
 800721c:	3148      	addmi	r1, #72	; 0x48
  ctl = usbp->otg->oe[ep].DOEPCTL;
 800721e:	3158      	addpl	r1, #88	; 0x58
 8007220:	0149      	lsls	r1, r1, #5
 8007222:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8007224:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8007226:	040d      	lsls	r5, r1, #16
 8007228:	f57f aef9 	bpl.w	800701e <_usb_ep0setup+0x7e>
  if (ctl & DOEPCTL_STALL)
 800722c:	0288      	lsls	r0, r1, #10
 800722e:	d429      	bmi.n	8007284 <_usb_ep0setup+0x2e4>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8007230:	4a47      	ldr	r2, [pc, #284]	; (8007350 <_usb_ep0setup+0x3b0>)
 8007232:	e7e7      	b.n	8007204 <_usb_ep0setup+0x264>
  hw |= (uint16_t)*p << 8U;
 8007234:	f894 0061 	ldrb.w	r0, [r4, #97]	; 0x61
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8007238:	6861      	ldr	r1, [r4, #4]
  hw |= (uint16_t)*p << 8U;
 800723a:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800723e:	684e      	ldr	r6, [r1, #4]
 8007240:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
 8007244:	f894 105f 	ldrb.w	r1, [r4, #95]	; 0x5f
 8007248:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800724c:	4620      	mov	r0, r4
 800724e:	47b0      	blx	r6
    if (dp == NULL) {
 8007250:	2800      	cmp	r0, #0
 8007252:	f43f aee3 	beq.w	800701c <_usb_ep0setup+0x7c>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8007256:	e890 000a 	ldmia.w	r0, {r1, r3}
 800725a:	65a5      	str	r5, [r4, #88]	; 0x58
 800725c:	6523      	str	r3, [r4, #80]	; 0x50
 800725e:	6561      	str	r1, [r4, #84]	; 0x54
 8007260:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 8007264:	e6b1      	b.n	8006fca <_usb_ep0setup+0x2a>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8007266:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 800726a:	2b01      	cmp	r3, #1
 800726c:	f47f aed6 	bne.w	800701c <_usb_ep0setup+0x7c>
      usbp->status |= 2U;
 8007270:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8007274:	6525      	str	r5, [r4, #80]	; 0x50
      usbp->status |= 2U;
 8007276:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800727a:	6565      	str	r5, [r4, #84]	; 0x54
 800727c:	65a5      	str	r5, [r4, #88]	; 0x58
      usbp->status |= 2U;
 800727e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 8007282:	e759      	b.n	8007138 <_usb_ep0setup+0x198>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8007284:	4a33      	ldr	r2, [pc, #204]	; (8007354 <_usb_ep0setup+0x3b4>)
 8007286:	e7bd      	b.n	8007204 <_usb_ep0setup+0x264>
  usbp->address = usbp->setup[2];
 8007288:	f894 005e 	ldrb.w	r0, [r4, #94]	; 0x5e
  stm32_otg_t *otgp = usbp->otg;
 800728c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800728e:	f884 0066 	strb.w	r0, [r4, #102]	; 0x66
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8007292:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8007296:	6865      	ldr	r5, [r4, #4]
 8007298:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 800729c:	682d      	ldr	r5, [r5, #0]
 800729e:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 80072a2:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 80072a6:	b125      	cbz	r5, 80072b2 <_usb_ep0setup+0x312>
 80072a8:	2101      	movs	r1, #1
 80072aa:	4620      	mov	r0, r4
 80072ac:	47a8      	blx	r5
 80072ae:	f894 105c 	ldrb.w	r1, [r4, #92]	; 0x5c
  usbp->state = USB_SELECTED;
 80072b2:	2303      	movs	r3, #3
 80072b4:	7023      	strb	r3, [r4, #0]
 80072b6:	e73b      	b.n	8007130 <_usb_ep0setup+0x190>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 80072b8:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80072bc:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80072c0:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 80072c4:	e734      	b.n	8007130 <_usb_ep0setup+0x190>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80072c6:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80072ca:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80072ce:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 80072d2:	e72d      	b.n	8007130 <_usb_ep0setup+0x190>
 80072d4:	6f20      	ldr	r0, [r4, #112]	; 0x70
  usbp->transmitting &= 1U;
 80072d6:	8921      	ldrh	r1, [r4, #8]
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80072d8:	6802      	ldr	r2, [r0, #0]
  usbp->receiving    &= 1U;
 80072da:	8963      	ldrh	r3, [r4, #10]
 80072dc:	6762      	str	r2, [r4, #116]	; 0x74
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80072de:	6886      	ldr	r6, [r0, #8]
 80072e0:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    usbp->epc[i] = NULL;
 80072e2:	6125      	str	r5, [r4, #16]
  usbp->transmitting &= 1U;
 80072e4:	f001 0101 	and.w	r1, r1, #1
  usbp->receiving    &= 1U;
 80072e8:	f003 0301 	and.w	r3, r3, #1
  usbp->transmitting &= 1U;
 80072ec:	8121      	strh	r1, [r4, #8]
 80072ee:	462a      	mov	r2, r5
    usbp->epc[i] = NULL;
 80072f0:	6165      	str	r5, [r4, #20]
 80072f2:	61a5      	str	r5, [r4, #24]
 80072f4:	61e5      	str	r5, [r4, #28]
 80072f6:	6225      	str	r5, [r4, #32]
  usbp->receiving    &= 1U;
 80072f8:	8163      	strh	r3, [r4, #10]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80072fa:	f04f 31ff 	mov.w	r1, #4294967295
 80072fe:	eb00 1342 	add.w	r3, r0, r2, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8007302:	3201      	adds	r2, #1
 8007304:	4296      	cmp	r6, r2
    otgp->ie[i].DIEPCTL = 0;
 8007306:	f8c3 5900 	str.w	r5, [r3, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
 800730a:	f8c3 5910 	str.w	r5, [r3, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800730e:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
 8007312:	f8c3 5b00 	str.w	r5, [r3, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 8007316:	f8c3 5b10 	str.w	r5, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800731a:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800731e:	d2ee      	bcs.n	80072fe <_usb_ep0setup+0x35e>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8007320:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8007324:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
  _dbg_check_unlock_from_isr();
 8007328:	f7f9 ff0a 	bl	8001140 <_dbg_check_unlock_from_isr>
 800732c:	f385 8811 	msr	BASEPRI, r5
        usbp->state = USB_SELECTED;
 8007330:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8007332:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
 8007334:	f884 5067 	strb.w	r5, [r4, #103]	; 0x67
        usbp->state = USB_SELECTED;
 8007338:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 800733a:	681b      	ldr	r3, [r3, #0]
 800733c:	b10b      	cbz	r3, 8007342 <_usb_ep0setup+0x3a2>
 800733e:	4620      	mov	r0, r4
 8007340:	4798      	blx	r3
 8007342:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 8007346:	e70f      	b.n	8007168 <_usb_ep0setup+0x1c8>
 8007348:	0800b548 	.word	0x0800b548
 800734c:	0800b5cc 	.word	0x0800b5cc
 8007350:	0800b5a0 	.word	0x0800b5a0
 8007354:	0800b5c8 	.word	0x0800b5c8
	...

08007360 <test_008_002_teardown.lto_priv.229>:
 8007360:	f000 bdd6 	b.w	8007f10 <test_008_003_teardown.lto_priv.140>
	...

08007370 <test_008_001_teardown.lto_priv.226>:
 8007370:	f000 bdce 	b.w	8007f10 <test_008_003_teardown.lto_priv.140>
	...

08007380 <test_008_002_setup.lto_priv.228>:
 8007380:	f000 bda6 	b.w	8007ed0 <test_008_003_setup.lto_priv.141>
	...

08007390 <test_008_001_setup.lto_priv.225>:
 8007390:	f000 bd9e 	b.w	8007ed0 <test_008_003_setup.lto_priv.141>
	...

080073a0 <test_007_007_setup.lto_priv.223>:
 *   has been emptied.
 * - [7.7.4] Unregistering from the Event Sources.
 * .
 */

static void test_007_007_setup(void) {
 80073a0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80073a2:	f002 ff0d 	bl	800a1c0 <chEvtGetAndClearEvents.constprop.51>
  esp->next = (event_listener_t *)esp;
 80073a6:	4a02      	ldr	r2, [pc, #8]	; (80073b0 <test_007_007_setup.lto_priv.223+0x10>)
 80073a8:	4b02      	ldr	r3, [pc, #8]	; (80073b4 <test_007_007_setup.lto_priv.223+0x14>)
 80073aa:	6012      	str	r2, [r2, #0]
 80073ac:	601b      	str	r3, [r3, #0]
 80073ae:	bd08      	pop	{r3, pc}
 80073b0:	20000c34 	.word	0x20000c34
 80073b4:	20000c38 	.word	0x20000c38
	...

080073c0 <test_007_006_setup.lto_priv.156>:
  chEvtGetAndClearEvents(ALL_EVENTS);
 80073c0:	f002 befe 	b.w	800a1c0 <chEvtGetAndClearEvents.constprop.51>
	...

080073d0 <test_007_005_setup.lto_priv.220>:
 80073d0:	f7ff bff6 	b.w	80073c0 <test_007_006_setup.lto_priv.156>
	...

080073e0 <test_007_004_setup.lto_priv.218>:
 80073e0:	f7ff bfee 	b.w	80073c0 <test_007_006_setup.lto_priv.156>
	...

080073f0 <test_007_005_execute.lto_priv.221>:
static void test_007_005_execute(void) {
 80073f0:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 80073f2:	4c2b      	ldr	r4, [pc, #172]	; (80074a0 <test_007_005_execute.lto_priv.221+0xb0>)
 80073f4:	2301      	movs	r3, #1
    chEvtAddEvents(5);
 80073f6:	2005      	movs	r0, #5
  test_set_step(1);
 80073f8:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(5);
 80073fa:	f7fa f831 	bl	8001460 <chEvtAddEvents>
  test_set_step(2);
 80073fe:	2302      	movs	r3, #2
 8007400:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAll(5);
 8007402:	f002 ff65 	bl	800a2d0 <chEvtWaitAll.constprop.45>
    test_assert(m == 5, "unexpected pending bit");
 8007406:	f1a0 0005 	sub.w	r0, r0, #5
 800740a:	fab0 f080 	clz	r0, r0
 800740e:	4925      	ldr	r1, [pc, #148]	; (80074a4 <test_007_005_execute.lto_priv.221+0xb4>)
 8007410:	0940      	lsrs	r0, r0, #5
 8007412:	f002 f9dd 	bl	80097d0 <_test_assert>
 8007416:	b100      	cbz	r0, 800741a <test_007_005_execute.lto_priv.221+0x2a>
 8007418:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800741a:	f002 fed1 	bl	800a1c0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 800741e:	fab0 f080 	clz	r0, r0
 8007422:	0940      	lsrs	r0, r0, #5
 8007424:	4920      	ldr	r1, [pc, #128]	; (80074a8 <test_007_005_execute.lto_priv.221+0xb8>)
 8007426:	f002 f9d3 	bl	80097d0 <_test_assert>
 800742a:	2800      	cmp	r0, #0
 800742c:	d1f4      	bne.n	8007418 <test_007_005_execute.lto_priv.221+0x28>
  test_set_step(3);
 800742e:	2303      	movs	r3, #3
    chEvtAddEvents(4);
 8007430:	2004      	movs	r0, #4
  test_set_step(3);
 8007432:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(4);
 8007434:	f7fa f814 	bl	8001460 <chEvtAddEvents>
  test_set_step(4);
 8007438:	2304      	movs	r3, #4
 800743a:	6023      	str	r3, [r4, #0]
    target_time = test_wait_tick() + MS2ST(50);
 800743c:	f001 fed8 	bl	80091f0 <test_wait_tick>
  return ch.rlist.current;
 8007440:	4b1a      	ldr	r3, [pc, #104]	; (80074ac <test_007_005_execute.lto_priv.221+0xbc>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007442:	4a1b      	ldr	r2, [pc, #108]	; (80074b0 <test_007_005_execute.lto_priv.221+0xc0>)
 8007444:	699b      	ldr	r3, [r3, #24]
 8007446:	6899      	ldr	r1, [r3, #8]
    target_time = test_wait_tick() + MS2ST(50);
 8007448:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800744a:	3901      	subs	r1, #1
 800744c:	4819      	ldr	r0, [pc, #100]	; (80074b4 <test_007_005_execute.lto_priv.221+0xc4>)
 800744e:	f002 fd8f 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8007452:	4a19      	ldr	r2, [pc, #100]	; (80074b8 <test_007_005_execute.lto_priv.221+0xc8>)
  test_set_step(5);
 8007454:	2305      	movs	r3, #5
 8007456:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007458:	6010      	str	r0, [r2, #0]
    m = chEvtWaitAll(5);
 800745a:	f002 ff39 	bl	800a2d0 <chEvtWaitAll.constprop.45>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800745e:	f505 7102 	add.w	r1, r5, #520	; 0x208
    m = chEvtWaitAll(5);
 8007462:	4604      	mov	r4, r0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8007464:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8007468:	f7fa fcd2 	bl	8001e10 <_test_assert_time_window.constprop.3>
 800746c:	2800      	cmp	r0, #0
 800746e:	d1d3      	bne.n	8007418 <test_007_005_execute.lto_priv.221+0x28>
    test_assert(m == 5, "event flags error");
 8007470:	f1a4 0005 	sub.w	r0, r4, #5
 8007474:	fab0 f080 	clz	r0, r0
 8007478:	0940      	lsrs	r0, r0, #5
 800747a:	4910      	ldr	r1, [pc, #64]	; (80074bc <test_007_005_execute.lto_priv.221+0xcc>)
 800747c:	f002 f9a8 	bl	80097d0 <_test_assert>
 8007480:	2800      	cmp	r0, #0
 8007482:	d1c9      	bne.n	8007418 <test_007_005_execute.lto_priv.221+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007484:	f002 fe9c 	bl	800a1c0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 8007488:	fab0 f080 	clz	r0, r0
 800748c:	0940      	lsrs	r0, r0, #5
 800748e:	4906      	ldr	r1, [pc, #24]	; (80074a8 <test_007_005_execute.lto_priv.221+0xb8>)
 8007490:	f002 f99e 	bl	80097d0 <_test_assert>
 8007494:	2800      	cmp	r0, #0
 8007496:	d1bf      	bne.n	8007418 <test_007_005_execute.lto_priv.221+0x28>
}
 8007498:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
 800749c:	f001 ba80 	b.w	80089a0 <test_wait_threads>
 80074a0:	20001df8 	.word	0x20001df8
 80074a4:	0800b5f8 	.word	0x0800b5f8
 80074a8:	0800b610 	.word	0x0800b610
 80074ac:	20001e68 	.word	0x20001e68
 80074b0:	080054e1 	.word	0x080054e1
 80074b4:	20001710 	.word	0x20001710
 80074b8:	20001d98 	.word	0x20001d98
 80074bc:	0800b61c 	.word	0x0800b61c

080074c0 <test_007_004_execute.lto_priv.219>:
static void test_007_004_execute(void) {
 80074c0:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 80074c2:	4c29      	ldr	r4, [pc, #164]	; (8007568 <test_007_004_execute.lto_priv.219+0xa8>)
 80074c4:	2301      	movs	r3, #1
    chEvtAddEvents(5);
 80074c6:	2005      	movs	r0, #5
  test_set_step(1);
 80074c8:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(5);
 80074ca:	f7f9 ffc9 	bl	8001460 <chEvtAddEvents>
  test_set_step(2);
 80074ce:	2302      	movs	r3, #2
 80074d0:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 80074d2:	f002 fecd 	bl	800a270 <chEvtWaitAny.constprop.46>
    test_assert(m == 5, "unexpected pending bit");
 80074d6:	f1a0 0005 	sub.w	r0, r0, #5
 80074da:	fab0 f080 	clz	r0, r0
 80074de:	4923      	ldr	r1, [pc, #140]	; (800756c <test_007_004_execute.lto_priv.219+0xac>)
 80074e0:	0940      	lsrs	r0, r0, #5
 80074e2:	f002 f975 	bl	80097d0 <_test_assert>
 80074e6:	b100      	cbz	r0, 80074ea <test_007_004_execute.lto_priv.219+0x2a>
 80074e8:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 80074ea:	f002 fe69 	bl	800a1c0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 80074ee:	fab0 f080 	clz	r0, r0
 80074f2:	0940      	lsrs	r0, r0, #5
 80074f4:	491e      	ldr	r1, [pc, #120]	; (8007570 <test_007_004_execute.lto_priv.219+0xb0>)
 80074f6:	f002 f96b 	bl	80097d0 <_test_assert>
 80074fa:	2800      	cmp	r0, #0
 80074fc:	d1f4      	bne.n	80074e8 <test_007_004_execute.lto_priv.219+0x28>
  test_set_step(3);
 80074fe:	2303      	movs	r3, #3
 8007500:	6023      	str	r3, [r4, #0]
    target_time = test_wait_tick() + MS2ST(50);
 8007502:	f001 fe75 	bl	80091f0 <test_wait_tick>
 8007506:	4b1b      	ldr	r3, [pc, #108]	; (8007574 <test_007_004_execute.lto_priv.219+0xb4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007508:	4a1b      	ldr	r2, [pc, #108]	; (8007578 <test_007_004_execute.lto_priv.219+0xb8>)
 800750a:	699b      	ldr	r3, [r3, #24]
 800750c:	6899      	ldr	r1, [r3, #8]
    target_time = test_wait_tick() + MS2ST(50);
 800750e:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007510:	3901      	subs	r1, #1
 8007512:	481a      	ldr	r0, [pc, #104]	; (800757c <test_007_004_execute.lto_priv.219+0xbc>)
 8007514:	f002 fd2c 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8007518:	4a19      	ldr	r2, [pc, #100]	; (8007580 <test_007_004_execute.lto_priv.219+0xc0>)
  test_set_step(4);
 800751a:	2304      	movs	r3, #4
 800751c:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800751e:	6010      	str	r0, [r2, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 8007520:	f002 fea6 	bl	800a270 <chEvtWaitAny.constprop.46>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8007524:	f505 7102 	add.w	r1, r5, #520	; 0x208
    m = chEvtWaitAny(ALL_EVENTS);
 8007528:	4604      	mov	r4, r0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800752a:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 800752e:	f7fa fc6f 	bl	8001e10 <_test_assert_time_window.constprop.3>
 8007532:	2800      	cmp	r0, #0
 8007534:	d1d8      	bne.n	80074e8 <test_007_004_execute.lto_priv.219+0x28>
    test_assert(m == 1, "event flag error");
 8007536:	f1a4 0001 	sub.w	r0, r4, #1
 800753a:	fab0 f080 	clz	r0, r0
 800753e:	0940      	lsrs	r0, r0, #5
 8007540:	4910      	ldr	r1, [pc, #64]	; (8007584 <test_007_004_execute.lto_priv.219+0xc4>)
 8007542:	f002 f945 	bl	80097d0 <_test_assert>
 8007546:	2800      	cmp	r0, #0
 8007548:	d1ce      	bne.n	80074e8 <test_007_004_execute.lto_priv.219+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800754a:	f002 fe39 	bl	800a1c0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 800754e:	fab0 f080 	clz	r0, r0
 8007552:	0940      	lsrs	r0, r0, #5
 8007554:	4906      	ldr	r1, [pc, #24]	; (8007570 <test_007_004_execute.lto_priv.219+0xb0>)
 8007556:	f002 f93b 	bl	80097d0 <_test_assert>
 800755a:	2800      	cmp	r0, #0
 800755c:	d1c4      	bne.n	80074e8 <test_007_004_execute.lto_priv.219+0x28>
}
 800755e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
 8007562:	f001 ba1d 	b.w	80089a0 <test_wait_threads>
 8007566:	bf00      	nop
 8007568:	20001df8 	.word	0x20001df8
 800756c:	0800b5f8 	.word	0x0800b5f8
 8007570:	0800b610 	.word	0x0800b610
 8007574:	20001e68 	.word	0x20001e68
 8007578:	080054e1 	.word	0x080054e1
 800757c:	20001710 	.word	0x20001710
 8007580:	20001d98 	.word	0x20001d98
 8007584:	0800b5e4 	.word	0x0800b5e4
	...

08007590 <test_007_003_execute.lto_priv.217>:
static void test_007_003_execute(void) {
 8007590:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 8007592:	4c35      	ldr	r4, [pc, #212]	; (8007668 <test_007_003_execute.lto_priv.217+0xd8>)
 8007594:	2301      	movs	r3, #1
    chEvtAddEvents(7);
 8007596:	2007      	movs	r0, #7
  test_set_step(1);
 8007598:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(7);
 800759a:	f7f9 ff61 	bl	8001460 <chEvtAddEvents>
  test_set_step(2);
 800759e:	2302      	movs	r3, #2
 80075a0:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 80075a2:	f002 fe35 	bl	800a210 <chEvtWaitOne.constprop.47>
    test_assert(m == 1, "single event error");
 80075a6:	f1a0 0001 	sub.w	r0, r0, #1
 80075aa:	fab0 f080 	clz	r0, r0
 80075ae:	492f      	ldr	r1, [pc, #188]	; (800766c <test_007_003_execute.lto_priv.217+0xdc>)
 80075b0:	0940      	lsrs	r0, r0, #5
 80075b2:	f002 f90d 	bl	80097d0 <_test_assert>
 80075b6:	b100      	cbz	r0, 80075ba <test_007_003_execute.lto_priv.217+0x2a>
 80075b8:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtWaitOne(ALL_EVENTS);
 80075ba:	f002 fe29 	bl	800a210 <chEvtWaitOne.constprop.47>
    test_assert(m == 2, "single event error");
 80075be:	f1a0 0002 	sub.w	r0, r0, #2
 80075c2:	fab0 f080 	clz	r0, r0
 80075c6:	4929      	ldr	r1, [pc, #164]	; (800766c <test_007_003_execute.lto_priv.217+0xdc>)
 80075c8:	0940      	lsrs	r0, r0, #5
 80075ca:	f002 f901 	bl	80097d0 <_test_assert>
 80075ce:	2800      	cmp	r0, #0
 80075d0:	d1f2      	bne.n	80075b8 <test_007_003_execute.lto_priv.217+0x28>
    m = chEvtWaitOne(ALL_EVENTS);
 80075d2:	f002 fe1d 	bl	800a210 <chEvtWaitOne.constprop.47>
    test_assert(m == 4, "single event error");
 80075d6:	f1a0 0004 	sub.w	r0, r0, #4
 80075da:	fab0 f080 	clz	r0, r0
 80075de:	4923      	ldr	r1, [pc, #140]	; (800766c <test_007_003_execute.lto_priv.217+0xdc>)
 80075e0:	0940      	lsrs	r0, r0, #5
 80075e2:	f002 f8f5 	bl	80097d0 <_test_assert>
 80075e6:	2800      	cmp	r0, #0
 80075e8:	d1e6      	bne.n	80075b8 <test_007_003_execute.lto_priv.217+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 80075ea:	f002 fde9 	bl	800a1c0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 80075ee:	fab0 f080 	clz	r0, r0
 80075f2:	0940      	lsrs	r0, r0, #5
 80075f4:	491e      	ldr	r1, [pc, #120]	; (8007670 <test_007_003_execute.lto_priv.217+0xe0>)
 80075f6:	f002 f8eb 	bl	80097d0 <_test_assert>
 80075fa:	2800      	cmp	r0, #0
 80075fc:	d1dc      	bne.n	80075b8 <test_007_003_execute.lto_priv.217+0x28>
  test_set_step(3);
 80075fe:	2303      	movs	r3, #3
 8007600:	6023      	str	r3, [r4, #0]
    target_time = test_wait_tick() + MS2ST(50);
 8007602:	f001 fdf5 	bl	80091f0 <test_wait_tick>
 8007606:	4b1b      	ldr	r3, [pc, #108]	; (8007674 <test_007_003_execute.lto_priv.217+0xe4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007608:	4a1b      	ldr	r2, [pc, #108]	; (8007678 <test_007_003_execute.lto_priv.217+0xe8>)
 800760a:	699b      	ldr	r3, [r3, #24]
 800760c:	6899      	ldr	r1, [r3, #8]
    target_time = test_wait_tick() + MS2ST(50);
 800760e:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007610:	3901      	subs	r1, #1
 8007612:	481a      	ldr	r0, [pc, #104]	; (800767c <test_007_003_execute.lto_priv.217+0xec>)
 8007614:	f002 fcac 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8007618:	4a19      	ldr	r2, [pc, #100]	; (8007680 <test_007_003_execute.lto_priv.217+0xf0>)
  test_set_step(4);
 800761a:	2304      	movs	r3, #4
 800761c:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800761e:	6010      	str	r0, [r2, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 8007620:	f002 fdf6 	bl	800a210 <chEvtWaitOne.constprop.47>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8007624:	f505 7102 	add.w	r1, r5, #520	; 0x208
    m = chEvtWaitOne(ALL_EVENTS);
 8007628:	4604      	mov	r4, r0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800762a:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 800762e:	f7fa fbef 	bl	8001e10 <_test_assert_time_window.constprop.3>
 8007632:	2800      	cmp	r0, #0
 8007634:	d1c0      	bne.n	80075b8 <test_007_003_execute.lto_priv.217+0x28>
    test_assert(m == 1, "event flag error");
 8007636:	f1a4 0001 	sub.w	r0, r4, #1
 800763a:	fab0 f080 	clz	r0, r0
 800763e:	0940      	lsrs	r0, r0, #5
 8007640:	4910      	ldr	r1, [pc, #64]	; (8007684 <test_007_003_execute.lto_priv.217+0xf4>)
 8007642:	f002 f8c5 	bl	80097d0 <_test_assert>
 8007646:	2800      	cmp	r0, #0
 8007648:	d1b6      	bne.n	80075b8 <test_007_003_execute.lto_priv.217+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800764a:	f002 fdb9 	bl	800a1c0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 800764e:	fab0 f080 	clz	r0, r0
 8007652:	0940      	lsrs	r0, r0, #5
 8007654:	4906      	ldr	r1, [pc, #24]	; (8007670 <test_007_003_execute.lto_priv.217+0xe0>)
 8007656:	f002 f8bb 	bl	80097d0 <_test_assert>
 800765a:	2800      	cmp	r0, #0
 800765c:	d1ac      	bne.n	80075b8 <test_007_003_execute.lto_priv.217+0x28>
}
 800765e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_wait_threads();
 8007662:	f001 b99d 	b.w	80089a0 <test_wait_threads>
 8007666:	bf00      	nop
 8007668:	20001df8 	.word	0x20001df8
 800766c:	0800b5d0 	.word	0x0800b5d0
 8007670:	0800b610 	.word	0x0800b610
 8007674:	20001e68 	.word	0x20001e68
 8007678:	080054e1 	.word	0x080054e1
 800767c:	20001710 	.word	0x20001710
 8007680:	20001d98 	.word	0x20001d98
 8007684:	0800b5e4 	.word	0x0800b5e4
	...

08007690 <chSysUnlock.lto_priv.135>:
static inline void chSysUnlock(void) {
 8007690:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8007692:	f7f9 fdbd 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007696:	4b08      	ldr	r3, [pc, #32]	; (80076b8 <chSysUnlock.lto_priv.135+0x28>)
 8007698:	681a      	ldr	r2, [r3, #0]
 800769a:	429a      	cmp	r2, r3
 800769c:	d004      	beq.n	80076a8 <chSysUnlock.lto_priv.135+0x18>
 800769e:	6999      	ldr	r1, [r3, #24]
 80076a0:	6893      	ldr	r3, [r2, #8]
 80076a2:	688a      	ldr	r2, [r1, #8]
 80076a4:	429a      	cmp	r2, r3
 80076a6:	d303      	bcc.n	80076b0 <chSysUnlock.lto_priv.135+0x20>
 80076a8:	2300      	movs	r3, #0
 80076aa:	f383 8811 	msr	BASEPRI, r3
 80076ae:	bd08      	pop	{r3, pc}
 80076b0:	4802      	ldr	r0, [pc, #8]	; (80076bc <chSysUnlock.lto_priv.135+0x2c>)
 80076b2:	f7f9 f8b5 	bl	8000820 <chSysHalt>
 80076b6:	bf00      	nop
 80076b8:	20001e68 	.word	0x20001e68
 80076bc:	0800b6f8 	.word	0x0800b6f8

080076c0 <test_008_001_execute.lto_priv.227>:

static void test_008_001_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_001_execute(void) {
 80076c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.1.1] Testing the mailbox size.*/
  test_set_step(1);
 80076c2:	4ec3      	ldr	r6, [pc, #780]	; (80079d0 <test_008_001_execute.lto_priv.227+0x310>)
 80076c4:	2301      	movs	r3, #1
static void test_008_001_execute(void) {
 80076c6:	b083      	sub	sp, #12
  test_set_step(1);
 80076c8:	6033      	str	r3, [r6, #0]
 80076ca:	2320      	movs	r3, #32
 80076cc:	f383 8811 	msr	BASEPRI, r3
  return (cnt_t)(mbp->top - mbp->buffer);
 80076d0:	4cc0      	ldr	r4, [pc, #768]	; (80079d4 <test_008_001_execute.lto_priv.227+0x314>)
  _dbg_check_lock();
 80076d2:	f7f9 fdc5 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 80076d6:	f7f9 f8f3 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheckClassI();
 80076da:	f7f9 f8f1 	bl	80008c0 <chDbgCheckClassI>
  return (cnt_t)(mbp->top - mbp->buffer);
 80076de:	e894 000c 	ldmia.w	r4, {r2, r3}
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80076e2:	6920      	ldr	r0, [r4, #16]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80076e4:	49bc      	ldr	r1, [pc, #752]	; (80079d8 <test_008_001_execute.lto_priv.227+0x318>)
  return (cnt_t)(mbp->top - mbp->buffer);
 80076e6:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80076e8:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 80076ec:	f1a0 0004 	sub.w	r0, r0, #4
 80076f0:	fab0 f080 	clz	r0, r0
 80076f4:	0940      	lsrs	r0, r0, #5
 80076f6:	f002 f86b 	bl	80097d0 <_test_assert>
 80076fa:	2800      	cmp	r0, #0
 80076fc:	f040 81d1 	bne.w	8007aa2 <test_008_001_execute.lto_priv.227+0x3e2>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007700:	4db6      	ldr	r5, [pc, #728]	; (80079dc <test_008_001_execute.lto_priv.227+0x31c>)
  _dbg_check_unlock();
 8007702:	f7f9 fd85 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007706:	682b      	ldr	r3, [r5, #0]
 8007708:	42ab      	cmp	r3, r5
 800770a:	d005      	beq.n	8007718 <test_008_001_execute.lto_priv.227+0x58>
 800770c:	69aa      	ldr	r2, [r5, #24]
 800770e:	689b      	ldr	r3, [r3, #8]
 8007710:	6892      	ldr	r2, [r2, #8]
 8007712:	429a      	cmp	r2, r3
 8007714:	f0c0 81c2 	bcc.w	8007a9c <test_008_001_execute.lto_priv.227+0x3dc>
 8007718:	2300      	movs	r3, #0
 800771a:	f383 8811 	msr	BASEPRI, r3
  }

  /* [8.1.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 800771e:	2302      	movs	r3, #2
 8007720:	6033      	str	r3, [r6, #0]
  {
    chMBReset(&mb1);
 8007722:	f7fa fbed 	bl	8001f00 <chMBReset.constprop.34>
 8007726:	2320      	movs	r3, #32
 8007728:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800772c:	f7f9 fd98 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8007730:	f7f9 f8c6 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheckClassI();
 8007734:	f7f9 f8c4 	bl	80008c0 <chDbgCheckClassI>
  return (cnt_t)(mbp->top - mbp->buffer);
 8007738:	e894 000c 	ldmia.w	r4, {r2, r3}
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800773c:	6920      	ldr	r0, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800773e:	49a8      	ldr	r1, [pc, #672]	; (80079e0 <test_008_001_execute.lto_priv.227+0x320>)
  return (cnt_t)(mbp->top - mbp->buffer);
 8007740:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8007742:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 8007746:	f1a0 0004 	sub.w	r0, r0, #4
 800774a:	fab0 f080 	clz	r0, r0
 800774e:	0940      	lsrs	r0, r0, #5
 8007750:	f002 f83e 	bl	80097d0 <_test_assert>
 8007754:	2800      	cmp	r0, #0
 8007756:	f040 8197 	bne.w	8007a88 <test_008_001_execute.lto_priv.227+0x3c8>
  _dbg_check_unlock();
 800775a:	f7f9 fd59 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800775e:	682b      	ldr	r3, [r5, #0]
 8007760:	42ab      	cmp	r3, r5
 8007762:	d005      	beq.n	8007770 <test_008_001_execute.lto_priv.227+0xb0>
 8007764:	69aa      	ldr	r2, [r5, #24]
 8007766:	689b      	ldr	r3, [r3, #8]
 8007768:	6892      	ldr	r2, [r2, #8]
 800776a:	429a      	cmp	r2, r3
 800776c:	f0c0 8196 	bcc.w	8007a9c <test_008_001_execute.lto_priv.227+0x3dc>
 8007770:	2300      	movs	r3, #0
 8007772:	f383 8811 	msr	BASEPRI, r3
 8007776:	2320      	movs	r3, #32
 8007778:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800777c:	f7f9 fd70 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8007780:	f7f9 f89e 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8007784:	6920      	ldr	r0, [r4, #16]
 8007786:	4997      	ldr	r1, [pc, #604]	; (80079e4 <test_008_001_execute.lto_priv.227+0x324>)
 8007788:	fab0 f080 	clz	r0, r0
 800778c:	0940      	lsrs	r0, r0, #5
 800778e:	f002 f81f 	bl	80097d0 <_test_assert>
 8007792:	2800      	cmp	r0, #0
 8007794:	f040 8178 	bne.w	8007a88 <test_008_001_execute.lto_priv.227+0x3c8>
  _dbg_check_unlock();
 8007798:	f7f9 fd3a 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800779c:	682b      	ldr	r3, [r5, #0]
 800779e:	42ab      	cmp	r3, r5
 80077a0:	d005      	beq.n	80077ae <test_008_001_execute.lto_priv.227+0xee>
 80077a2:	69aa      	ldr	r2, [r5, #24]
 80077a4:	689b      	ldr	r3, [r3, #8]
 80077a6:	6892      	ldr	r2, [r2, #8]
 80077a8:	429a      	cmp	r2, r3
 80077aa:	f0c0 8177 	bcc.w	8007a9c <test_008_001_execute.lto_priv.227+0x3dc>
 80077ae:	2300      	movs	r3, #0
 80077b0:	f383 8811 	msr	BASEPRI, r3
 80077b4:	2320      	movs	r3, #32
 80077b6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80077ba:	f7f9 fd51 	bl	8001260 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80077be:	6820      	ldr	r0, [r4, #0]
 80077c0:	68a3      	ldr	r3, [r4, #8]
 80077c2:	4989      	ldr	r1, [pc, #548]	; (80079e8 <test_008_001_execute.lto_priv.227+0x328>)
 80077c4:	1ac0      	subs	r0, r0, r3
 80077c6:	fab0 f080 	clz	r0, r0
 80077ca:	0940      	lsrs	r0, r0, #5
 80077cc:	f002 f800 	bl	80097d0 <_test_assert>
 80077d0:	2800      	cmp	r0, #0
 80077d2:	f040 8159 	bne.w	8007a88 <test_008_001_execute.lto_priv.227+0x3c8>
  _dbg_check_unlock();
 80077d6:	f7f9 fd1b 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80077da:	682b      	ldr	r3, [r5, #0]
 80077dc:	42ab      	cmp	r3, r5
 80077de:	d005      	beq.n	80077ec <test_008_001_execute.lto_priv.227+0x12c>
 80077e0:	69aa      	ldr	r2, [r5, #24]
 80077e2:	689b      	ldr	r3, [r3, #8]
 80077e4:	6892      	ldr	r2, [r2, #8]
 80077e6:	429a      	cmp	r2, r3
 80077e8:	f0c0 8158 	bcc.w	8007a9c <test_008_001_execute.lto_priv.227+0x3dc>
 80077ec:	2300      	movs	r3, #0
 80077ee:	f383 8811 	msr	BASEPRI, r3
 80077f2:	2320      	movs	r3, #32
 80077f4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80077f8:	f7f9 fd32 	bl	8001260 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80077fc:	6820      	ldr	r0, [r4, #0]
 80077fe:	68e3      	ldr	r3, [r4, #12]
 8007800:	497a      	ldr	r1, [pc, #488]	; (80079ec <test_008_001_execute.lto_priv.227+0x32c>)
 8007802:	1ac0      	subs	r0, r0, r3
 8007804:	fab0 f080 	clz	r0, r0
 8007808:	0940      	lsrs	r0, r0, #5
 800780a:	f001 ffe1 	bl	80097d0 <_test_assert>
 800780e:	2800      	cmp	r0, #0
 8007810:	f040 813a 	bne.w	8007a88 <test_008_001_execute.lto_priv.227+0x3c8>
  _dbg_check_unlock();
 8007814:	f7f9 fcfc 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007818:	682b      	ldr	r3, [r5, #0]
 800781a:	42ab      	cmp	r3, r5
 800781c:	d005      	beq.n	800782a <test_008_001_execute.lto_priv.227+0x16a>
 800781e:	69aa      	ldr	r2, [r5, #24]
 8007820:	689b      	ldr	r3, [r3, #8]
 8007822:	6892      	ldr	r2, [r2, #8]
 8007824:	429a      	cmp	r2, r3
 8007826:	f0c0 8139 	bcc.w	8007a9c <test_008_001_execute.lto_priv.227+0x3dc>
 800782a:	2000      	movs	r0, #0
 800782c:	f380 8811 	msr	BASEPRI, r0
  }

  /* [8.1.3] Testing the behavior of API when the mailbox is in reset
     state then return in active state.*/
  test_set_step(3);
 8007830:	2303      	movs	r3, #3
  {
    msg1 = chMBPost(&mb1, (msg_t)0, TIME_INFINITE);
 8007832:	f04f 31ff 	mov.w	r1, #4294967295
  test_set_step(3);
 8007836:	6033      	str	r3, [r6, #0]
    msg1 = chMBPost(&mb1, (msg_t)0, TIME_INFINITE);
 8007838:	f7fa fb82 	bl	8001f40 <chMBPost.constprop.32>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800783c:	1c85      	adds	r5, r0, #2
 800783e:	bf14      	ite	ne
 8007840:	2000      	movne	r0, #0
 8007842:	2001      	moveq	r0, #1
 8007844:	496a      	ldr	r1, [pc, #424]	; (80079f0 <test_008_001_execute.lto_priv.227+0x330>)
 8007846:	f001 ffc3 	bl	80097d0 <_test_assert>
 800784a:	2800      	cmp	r0, #0
 800784c:	f040 8137 	bne.w	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
    msg1 = chMBPostAhead(&mb1, (msg_t)0, TIME_INFINITE);
 8007850:	f04f 31ff 	mov.w	r1, #4294967295
 8007854:	f7fa fbcc 	bl	8001ff0 <chMBPostAhead.constprop.29>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8007858:	1c82      	adds	r2, r0, #2
 800785a:	bf14      	ite	ne
 800785c:	2000      	movne	r0, #0
 800785e:	2001      	moveq	r0, #1
 8007860:	4963      	ldr	r1, [pc, #396]	; (80079f0 <test_008_001_execute.lto_priv.227+0x330>)
 8007862:	f001 ffb5 	bl	80097d0 <_test_assert>
 8007866:	2800      	cmp	r0, #0
 8007868:	f040 8129 	bne.w	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800786c:	f04f 31ff 	mov.w	r1, #4294967295
 8007870:	a801      	add	r0, sp, #4
 8007872:	f7fa faed 	bl	8001e50 <chMBFetch.constprop.26>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8007876:	1c83      	adds	r3, r0, #2
 8007878:	bf14      	ite	ne
 800787a:	2000      	movne	r0, #0
 800787c:	2001      	moveq	r0, #1
 800787e:	495c      	ldr	r1, [pc, #368]	; (80079f0 <test_008_001_execute.lto_priv.227+0x330>)
 8007880:	f001 ffa6 	bl	80097d0 <_test_assert>
 8007884:	2800      	cmp	r0, #0
 8007886:	f040 811a 	bne.w	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
    chMBResumeX(&mb1);
  }

  /* [8.1.4] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(4);
 800788a:	2304      	movs	r3, #4
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800788c:	4f59      	ldr	r7, [pc, #356]	; (80079f4 <test_008_001_execute.lto_priv.227+0x334>)
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {

  mbp->reset = false;
 800788e:	7520      	strb	r0, [r4, #20]
  test_set_step(4);
 8007890:	6033      	str	r3, [r6, #0]
 8007892:	2542      	movs	r5, #66	; 0x42
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8007894:	f04f 31ff 	mov.w	r1, #4294967295
 8007898:	4628      	mov	r0, r5
 800789a:	f7fa fb51 	bl	8001f40 <chMBPost.constprop.32>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800789e:	fab0 f080 	clz	r0, r0
 80078a2:	4639      	mov	r1, r7
 80078a4:	0940      	lsrs	r0, r0, #5
 80078a6:	f001 ff93 	bl	80097d0 <_test_assert>
 80078aa:	2800      	cmp	r0, #0
 80078ac:	f040 8107 	bne.w	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
 80078b0:	3501      	adds	r5, #1
    for (i = 0; i < MB_SIZE - 1; i++) {
 80078b2:	2d45      	cmp	r5, #69	; 0x45
 80078b4:	d1ee      	bne.n	8007894 <test_008_001_execute.lto_priv.227+0x1d4>
    }
    msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 80078b6:	f04f 31ff 	mov.w	r1, #4294967295
 80078ba:	2041      	movs	r0, #65	; 0x41
 80078bc:	f7fa fb98 	bl	8001ff0 <chMBPostAhead.constprop.29>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80078c0:	fab0 f080 	clz	r0, r0
 80078c4:	0940      	lsrs	r0, r0, #5
 80078c6:	494b      	ldr	r1, [pc, #300]	; (80079f4 <test_008_001_execute.lto_priv.227+0x334>)
 80078c8:	f001 ff82 	bl	80097d0 <_test_assert>
 80078cc:	2800      	cmp	r0, #0
 80078ce:	f040 80f6 	bne.w	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
  }

  /* [8.1.5] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(5);
 80078d2:	2305      	movs	r3, #5
 80078d4:	6033      	str	r3, [r6, #0]
 80078d6:	2520      	movs	r5, #32
 80078d8:	f385 8811 	msr	BASEPRI, r5
  _dbg_check_lock();
 80078dc:	f7f9 fcc0 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 80078e0:	f7f8 ffee 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheckClassI();
 80078e4:	f7f8 ffec 	bl	80008c0 <chDbgCheckClassI>
  return (cnt_t)(mbp->top - mbp->buffer);
 80078e8:	e894 0009 	ldmia.w	r4, {r0, r3}
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 80078ec:	6922      	ldr	r2, [r4, #16]
 80078ee:	4942      	ldr	r1, [pc, #264]	; (80079f8 <test_008_001_execute.lto_priv.227+0x338>)
 80078f0:	1a1b      	subs	r3, r3, r0
 80078f2:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 80078f6:	bf0c      	ite	eq
 80078f8:	2001      	moveq	r0, #1
 80078fa:	2000      	movne	r0, #0
 80078fc:	f001 ff68 	bl	80097d0 <_test_assert>
 8007900:	2800      	cmp	r0, #0
 8007902:	f040 80de 	bne.w	8007ac2 <test_008_001_execute.lto_priv.227+0x402>
  chSysUnlock();
 8007906:	f7ff fec3 	bl	8007690 <chSysUnlock.lto_priv.135>
 800790a:	f385 8811 	msr	BASEPRI, r5
 800790e:	f7f9 fca7 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8007912:	f7f8 ffd5 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8007916:	6920      	ldr	r0, [r4, #16]
 8007918:	4938      	ldr	r1, [pc, #224]	; (80079fc <test_008_001_execute.lto_priv.227+0x33c>)
 800791a:	f1a0 0e04 	sub.w	lr, r0, #4
 800791e:	f1de 0000 	rsbs	r0, lr, #0
 8007922:	eb40 000e 	adc.w	r0, r0, lr
 8007926:	f001 ff53 	bl	80097d0 <_test_assert>
 800792a:	2800      	cmp	r0, #0
 800792c:	f040 80c9 	bne.w	8007ac2 <test_008_001_execute.lto_priv.227+0x402>
 8007930:	f7ff feae 	bl	8007690 <chSysUnlock.lto_priv.135>
 8007934:	f385 8811 	msr	BASEPRI, r5
 8007938:	f7f9 fc92 	bl	8001260 <_dbg_check_lock>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 800793c:	68e0      	ldr	r0, [r4, #12]
 800793e:	68a3      	ldr	r3, [r4, #8]
 8007940:	492f      	ldr	r1, [pc, #188]	; (8007a00 <test_008_001_execute.lto_priv.227+0x340>)
 8007942:	1ac7      	subs	r7, r0, r3
 8007944:	4278      	negs	r0, r7
 8007946:	4178      	adcs	r0, r7
 8007948:	f001 ff42 	bl	80097d0 <_test_assert>
 800794c:	2800      	cmp	r0, #0
 800794e:	f040 80b8 	bne.w	8007ac2 <test_008_001_execute.lto_priv.227+0x402>
 8007952:	f7ff fe9d 	bl	8007690 <chSysUnlock.lto_priv.135>
     expected.*/
  test_set_step(6);
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8007956:	4f27      	ldr	r7, [pc, #156]	; (80079f4 <test_008_001_execute.lto_priv.227+0x334>)
  test_set_step(6);
 8007958:	2306      	movs	r3, #6
 800795a:	6033      	str	r3, [r6, #0]
 800795c:	2504      	movs	r5, #4
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800795e:	f04f 31ff 	mov.w	r1, #4294967295
 8007962:	a801      	add	r0, sp, #4
 8007964:	f7fa fa74 	bl	8001e50 <chMBFetch.constprop.26>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8007968:	fab0 f080 	clz	r0, r0
 800796c:	4639      	mov	r1, r7
 800796e:	0940      	lsrs	r0, r0, #5
 8007970:	f001 ff2e 	bl	80097d0 <_test_assert>
 8007974:	2800      	cmp	r0, #0
 8007976:	f040 80a2 	bne.w	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
      test_emit_token(msg2);
 800797a:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800797e:	f002 f84f 	bl	8009a20 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 8007982:	3d01      	subs	r5, #1
 8007984:	d1eb      	bne.n	800795e <test_008_001_execute.lto_priv.227+0x29e>
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 8007986:	491f      	ldr	r1, [pc, #124]	; (8007a04 <test_008_001_execute.lto_priv.227+0x344>)
 8007988:	481f      	ldr	r0, [pc, #124]	; (8007a08 <test_008_001_execute.lto_priv.227+0x348>)
 800798a:	f001 fef9 	bl	8009780 <_test_assert_sequence>
 800798e:	2800      	cmp	r0, #0
 8007990:	f040 8095 	bne.w	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
  }

  /* [8.1.7] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(7);
 8007994:	2307      	movs	r3, #7
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8007996:	f04f 31ff 	mov.w	r1, #4294967295
 800799a:	2046      	movs	r0, #70	; 0x46
  test_set_step(7);
 800799c:	6033      	str	r3, [r6, #0]
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800799e:	f7fa facf 	bl	8001f40 <chMBPost.constprop.32>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80079a2:	fab0 f080 	clz	r0, r0
 80079a6:	0940      	lsrs	r0, r0, #5
 80079a8:	4912      	ldr	r1, [pc, #72]	; (80079f4 <test_008_001_execute.lto_priv.227+0x334>)
 80079aa:	f001 ff11 	bl	80097d0 <_test_assert>
 80079ae:	2800      	cmp	r0, #0
 80079b0:	f040 8085 	bne.w	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80079b4:	f04f 31ff 	mov.w	r1, #4294967295
 80079b8:	a801      	add	r0, sp, #4
 80079ba:	f7fa fa49 	bl	8001e50 <chMBFetch.constprop.26>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80079be:	fab0 f080 	clz	r0, r0
 80079c2:	0940      	lsrs	r0, r0, #5
 80079c4:	490b      	ldr	r1, [pc, #44]	; (80079f4 <test_008_001_execute.lto_priv.227+0x334>)
 80079c6:	f001 ff03 	bl	80097d0 <_test_assert>
 80079ca:	2800      	cmp	r0, #0
 80079cc:	d177      	bne.n	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
 80079ce:	e01d      	b.n	8007a0c <test_008_001_execute.lto_priv.227+0x34c>
 80079d0:	20001df8 	.word	0x20001df8
 80079d4:	20000c60 	.word	0x20000c60
 80079d8:	0800b640 	.word	0x0800b640
 80079dc:	20001e68 	.word	0x20001e68
 80079e0:	0800aad8 	.word	0x0800aad8
 80079e4:	0800b64c 	.word	0x0800b64c
 80079e8:	0800b658 	.word	0x0800b658
 80079ec:	0800b67c 	.word	0x0800b67c
 80079f0:	0800b6a0 	.word	0x0800b6a0
 80079f4:	0800aa04 	.word	0x0800aa04
 80079f8:	0800b6b4 	.word	0x0800b6b4
 80079fc:	0800b6c0 	.word	0x0800b6c0
 8007a00:	0800b6cc 	.word	0x0800b6cc
 8007a04:	0800b6e4 	.word	0x0800b6e4
 8007a08:	0800abe4 	.word	0x0800abe4
  }

  /* [8.1.8] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(8);
 8007a0c:	2308      	movs	r3, #8
 8007a0e:	6033      	str	r3, [r6, #0]
 8007a10:	2520      	movs	r5, #32
 8007a12:	f385 8811 	msr	BASEPRI, r5
 8007a16:	f7f9 fc23 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8007a1a:	f7f8 ff51 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheckClassI();
 8007a1e:	f7f8 ff4f 	bl	80008c0 <chDbgCheckClassI>
  return (cnt_t)(mbp->top - mbp->buffer);
 8007a22:	e894 0005 	ldmia.w	r4, {r0, r2}
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8007a26:	6923      	ldr	r3, [r4, #16]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8007a28:	4927      	ldr	r1, [pc, #156]	; (8007ac8 <test_008_001_execute.lto_priv.227+0x408>)
  return (cnt_t)(mbp->top - mbp->buffer);
 8007a2a:	1a12      	subs	r2, r2, r0
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8007a2c:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8007a30:	1f1e      	subs	r6, r3, #4
 8007a32:	4270      	negs	r0, r6
 8007a34:	4170      	adcs	r0, r6
 8007a36:	f001 fecb 	bl	80097d0 <_test_assert>
 8007a3a:	2800      	cmp	r0, #0
 8007a3c:	d141      	bne.n	8007ac2 <test_008_001_execute.lto_priv.227+0x402>
 8007a3e:	f7ff fe27 	bl	8007690 <chSysUnlock.lto_priv.135>
 8007a42:	f385 8811 	msr	BASEPRI, r5
 8007a46:	f7f9 fc0b 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8007a4a:	f7f8 ff39 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8007a4e:	6920      	ldr	r0, [r4, #16]
 8007a50:	491e      	ldr	r1, [pc, #120]	; (8007acc <test_008_001_execute.lto_priv.227+0x40c>)
 8007a52:	fab0 f080 	clz	r0, r0
 8007a56:	0940      	lsrs	r0, r0, #5
 8007a58:	f001 feba 	bl	80097d0 <_test_assert>
 8007a5c:	2800      	cmp	r0, #0
 8007a5e:	d130      	bne.n	8007ac2 <test_008_001_execute.lto_priv.227+0x402>
 8007a60:	f7ff fe16 	bl	8007690 <chSysUnlock.lto_priv.135>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8007a64:	6820      	ldr	r0, [r4, #0]
 8007a66:	68a3      	ldr	r3, [r4, #8]
 8007a68:	4919      	ldr	r1, [pc, #100]	; (8007ad0 <test_008_001_execute.lto_priv.227+0x410>)
 8007a6a:	1ac2      	subs	r2, r0, r3
 8007a6c:	4250      	negs	r0, r2
 8007a6e:	4150      	adcs	r0, r2
 8007a70:	f001 feae 	bl	80097d0 <_test_assert>
 8007a74:	bb18      	cbnz	r0, 8007abe <test_008_001_execute.lto_priv.227+0x3fe>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8007a76:	6820      	ldr	r0, [r4, #0]
 8007a78:	68e3      	ldr	r3, [r4, #12]
 8007a7a:	4916      	ldr	r1, [pc, #88]	; (8007ad4 <test_008_001_execute.lto_priv.227+0x414>)
 8007a7c:	1ac3      	subs	r3, r0, r3
 8007a7e:	4258      	negs	r0, r3
 8007a80:	4158      	adcs	r0, r3
 8007a82:	f001 fea5 	bl	80097d0 <_test_assert>
 8007a86:	e01a      	b.n	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
  _dbg_check_unlock();
 8007a88:	f7f9 fbc2 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007a8c:	682b      	ldr	r3, [r5, #0]
 8007a8e:	42ab      	cmp	r3, r5
 8007a90:	d012      	beq.n	8007ab8 <test_008_001_execute.lto_priv.227+0x3f8>
 8007a92:	69aa      	ldr	r2, [r5, #24]
 8007a94:	689b      	ldr	r3, [r3, #8]
 8007a96:	6892      	ldr	r2, [r2, #8]
 8007a98:	429a      	cmp	r2, r3
 8007a9a:	d20d      	bcs.n	8007ab8 <test_008_001_execute.lto_priv.227+0x3f8>
 8007a9c:	480e      	ldr	r0, [pc, #56]	; (8007ad8 <test_008_001_execute.lto_priv.227+0x418>)
 8007a9e:	f7f8 febf 	bl	8000820 <chSysHalt>
  _dbg_check_unlock();
 8007aa2:	f7f9 fbb5 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007aa6:	4b0d      	ldr	r3, [pc, #52]	; (8007adc <test_008_001_execute.lto_priv.227+0x41c>)
 8007aa8:	681a      	ldr	r2, [r3, #0]
 8007aaa:	429a      	cmp	r2, r3
 8007aac:	d004      	beq.n	8007ab8 <test_008_001_execute.lto_priv.227+0x3f8>
 8007aae:	6999      	ldr	r1, [r3, #24]
 8007ab0:	6893      	ldr	r3, [r2, #8]
 8007ab2:	688a      	ldr	r2, [r1, #8]
 8007ab4:	429a      	cmp	r2, r3
 8007ab6:	d3f1      	bcc.n	8007a9c <test_008_001_execute.lto_priv.227+0x3dc>
 8007ab8:	2300      	movs	r3, #0
 8007aba:	f383 8811 	msr	BASEPRI, r3
  }
}
 8007abe:	b003      	add	sp, #12
 8007ac0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007ac2:	f7ff fde5 	bl	8007690 <chSysUnlock.lto_priv.135>
 8007ac6:	e7fa      	b.n	8007abe <test_008_001_execute.lto_priv.227+0x3fe>
 8007ac8:	0800aad8 	.word	0x0800aad8
 8007acc:	0800b64c 	.word	0x0800b64c
 8007ad0:	0800b658 	.word	0x0800b658
 8007ad4:	0800b67c 	.word	0x0800b67c
 8007ad8:	0800b6f8 	.word	0x0800b6f8
 8007adc:	20001e68 	.word	0x20001e68

08007ae0 <test_007_007_execute.lto_priv.224>:
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void test_007_007_execute(void) {
 8007ae0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  event_listener_t el1, el2;
  systime_t target_time;

  /* [7.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8007ae4:	f8df 8158 	ldr.w	r8, [pc, #344]	; 8007c40 <test_007_007_execute.lto_priv.224+0x160>
 8007ae8:	2701      	movs	r7, #1
static void test_007_007_execute(void) {
 8007aea:	b08a      	sub	sp, #40	; 0x28
  test_set_step(1);
 8007aec:	f8c8 7000 	str.w	r7, [r8]
 8007af0:	2320      	movs	r3, #32
 8007af2:	f383 8811 	msr	BASEPRI, r3
  elp->next     = esp->next;
 8007af6:	4e48      	ldr	r6, [pc, #288]	; (8007c18 <test_007_007_execute.lto_priv.224+0x138>)
  elp->listener = currp;
 8007af8:	4c48      	ldr	r4, [pc, #288]	; (8007c1c <test_007_007_execute.lto_priv.224+0x13c>)
  elp->next     = esp->next;
 8007afa:	ad0a      	add	r5, sp, #40	; 0x28
  _dbg_check_lock();
 8007afc:	f7f9 fbb0 	bl	8001260 <_dbg_check_lock>
 8007b00:	6833      	ldr	r3, [r6, #0]
 8007b02:	f845 3d14 	str.w	r3, [r5, #-20]!
  elp->listener = currp;
 8007b06:	69a1      	ldr	r1, [r4, #24]
  elp->events   = events;
 8007b08:	9707      	str	r7, [sp, #28]
  elp->wflags   = wflags;
 8007b0a:	f04f 33ff 	mov.w	r3, #4294967295
  elp->flags    = (eventflags_t)0;
 8007b0e:	2200      	movs	r2, #0
  elp->wflags   = wflags;
 8007b10:	9309      	str	r3, [sp, #36]	; 0x24
  elp->listener = currp;
 8007b12:	9106      	str	r1, [sp, #24]
  elp->flags    = (eventflags_t)0;
 8007b14:	9208      	str	r2, [sp, #32]
  esp->next     = elp;
 8007b16:	6035      	str	r5, [r6, #0]
  _dbg_check_unlock();
 8007b18:	f7f9 fb7a 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007b1c:	6823      	ldr	r3, [r4, #0]
 8007b1e:	42a3      	cmp	r3, r4
 8007b20:	d004      	beq.n	8007b2c <test_007_007_execute.lto_priv.224+0x4c>
 8007b22:	69a2      	ldr	r2, [r4, #24]
 8007b24:	689b      	ldr	r3, [r3, #8]
 8007b26:	6892      	ldr	r2, [r2, #8]
 8007b28:	429a      	cmp	r2, r3
 8007b2a:	d346      	bcc.n	8007bba <test_007_007_execute.lto_priv.224+0xda>
 8007b2c:	f04f 0a00 	mov.w	sl, #0
 8007b30:	f38a 8811 	msr	BASEPRI, sl
 8007b34:	2320      	movs	r3, #32
 8007b36:	f383 8811 	msr	BASEPRI, r3
  elp->next     = esp->next;
 8007b3a:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 8007c38 <test_007_007_execute.lto_priv.224+0x158>
 8007b3e:	af0a      	add	r7, sp, #40	; 0x28
  _dbg_check_lock();
 8007b40:	f7f9 fb8e 	bl	8001260 <_dbg_check_lock>
 8007b44:	f8d9 3000 	ldr.w	r3, [r9]
 8007b48:	f847 3d28 	str.w	r3, [r7, #-40]!
  elp->listener = currp;
 8007b4c:	69a3      	ldr	r3, [r4, #24]
 8007b4e:	9301      	str	r3, [sp, #4]
  elp->events   = events;
 8007b50:	2204      	movs	r2, #4
  elp->wflags   = wflags;
 8007b52:	f04f 33ff 	mov.w	r3, #4294967295
 8007b56:	9304      	str	r3, [sp, #16]
  elp->flags    = (eventflags_t)0;
 8007b58:	f8cd a00c 	str.w	sl, [sp, #12]
  elp->events   = events;
 8007b5c:	9202      	str	r2, [sp, #8]
  esp->next     = elp;
 8007b5e:	f8c9 7000 	str.w	r7, [r9]
  _dbg_check_unlock();
 8007b62:	f7f9 fb55 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007b66:	6823      	ldr	r3, [r4, #0]
 8007b68:	42a3      	cmp	r3, r4
 8007b6a:	d004      	beq.n	8007b76 <test_007_007_execute.lto_priv.224+0x96>
 8007b6c:	69a2      	ldr	r2, [r4, #24]
 8007b6e:	689b      	ldr	r3, [r3, #8]
 8007b70:	6892      	ldr	r2, [r2, #8]
 8007b72:	429a      	cmp	r2, r3
 8007b74:	d321      	bcc.n	8007bba <test_007_007_execute.lto_priv.224+0xda>
 8007b76:	2300      	movs	r3, #0
 8007b78:	f383 8811 	msr	BASEPRI, r3
  }

  /* [7.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 8007b7c:	2302      	movs	r3, #2
 8007b7e:	f8c8 3000 	str.w	r3, [r8]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8007b82:	f001 fb35 	bl	80091f0 <test_wait_tick>
  return chThdGetSelfX()->prio;
 8007b86:	69a2      	ldr	r2, [r4, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007b88:	4b25      	ldr	r3, [pc, #148]	; (8007c20 <test_007_007_execute.lto_priv.224+0x140>)
 8007b8a:	6891      	ldr	r1, [r2, #8]
 8007b8c:	4a25      	ldr	r2, [pc, #148]	; (8007c24 <test_007_007_execute.lto_priv.224+0x144>)
    target_time = test_wait_tick() + MS2ST(50);
 8007b8e:	4682      	mov	sl, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007b90:	3901      	subs	r1, #1
 8007b92:	4825      	ldr	r0, [pc, #148]	; (8007c28 <test_007_007_execute.lto_priv.224+0x148>)
 8007b94:	f002 f9ec 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8007b98:	4a24      	ldr	r2, [pc, #144]	; (8007c2c <test_007_007_execute.lto_priv.224+0x14c>)
  }

  /* [7.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8007b9a:	2303      	movs	r3, #3
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8007b9c:	6010      	str	r0, [r2, #0]
  test_set_step(3);
 8007b9e:	f8c8 3000 	str.w	r3, [r8]
  {
    m = chEvtWaitAll(5);
 8007ba2:	f002 fb95 	bl	800a2d0 <chEvtWaitAll.constprop.45>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8007ba6:	f50a 7102 	add.w	r1, sl, #520	; 0x208
 8007baa:	f50a 70fa 	add.w	r0, sl, #500	; 0x1f4
 8007bae:	f7fa f92f 	bl	8001e10 <_test_assert_time_window.constprop.3>
 8007bb2:	b128      	cbz	r0, 8007bc0 <test_007_007_execute.lto_priv.224+0xe0>
    chEvtUnregister(&es1, &el1);
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
}
 8007bb4:	b00a      	add	sp, #40	; 0x28
 8007bb6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007bba:	481d      	ldr	r0, [pc, #116]	; (8007c30 <test_007_007_execute.lto_priv.224+0x150>)
 8007bbc:	f7f8 fe30 	bl	8000820 <chSysHalt>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8007bc0:	f002 fafe 	bl	800a1c0 <chEvtGetAndClearEvents.constprop.51>
    test_assert(m == 0, "stuck event");
 8007bc4:	fab0 f080 	clz	r0, r0
 8007bc8:	0940      	lsrs	r0, r0, #5
 8007bca:	491a      	ldr	r1, [pc, #104]	; (8007c34 <test_007_007_execute.lto_priv.224+0x154>)
 8007bcc:	f001 fe00 	bl	80097d0 <_test_assert>
 8007bd0:	2800      	cmp	r0, #0
 8007bd2:	d1ef      	bne.n	8007bb4 <test_007_007_execute.lto_priv.224+0xd4>
    test_wait_threads();
 8007bd4:	f000 fee4 	bl	80089a0 <test_wait_threads>
  test_set_step(4);
 8007bd8:	2304      	movs	r3, #4
    chEvtUnregister(&es1, &el1);
 8007bda:	4629      	mov	r1, r5
 8007bdc:	480e      	ldr	r0, [pc, #56]	; (8007c18 <test_007_007_execute.lto_priv.224+0x138>)
  test_set_step(4);
 8007bde:	f8c8 3000 	str.w	r3, [r8]
    chEvtUnregister(&es1, &el1);
 8007be2:	f7f9 fc65 	bl	80014b0 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 8007be6:	4639      	mov	r1, r7
 8007be8:	4813      	ldr	r0, [pc, #76]	; (8007c38 <test_007_007_execute.lto_priv.224+0x158>)
 8007bea:	f7f9 fc61 	bl	80014b0 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 8007bee:	6830      	ldr	r0, [r6, #0]
 8007bf0:	4912      	ldr	r1, [pc, #72]	; (8007c3c <test_007_007_execute.lto_priv.224+0x15c>)
 8007bf2:	1b80      	subs	r0, r0, r6
 8007bf4:	fab0 f080 	clz	r0, r0
 8007bf8:	0940      	lsrs	r0, r0, #5
 8007bfa:	f001 fde9 	bl	80097d0 <_test_assert>
 8007bfe:	2800      	cmp	r0, #0
 8007c00:	d1d8      	bne.n	8007bb4 <test_007_007_execute.lto_priv.224+0xd4>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 8007c02:	f8d9 0000 	ldr.w	r0, [r9]
 8007c06:	490d      	ldr	r1, [pc, #52]	; (8007c3c <test_007_007_execute.lto_priv.224+0x15c>)
 8007c08:	eba0 0009 	sub.w	r0, r0, r9
 8007c0c:	fab0 f080 	clz	r0, r0
 8007c10:	0940      	lsrs	r0, r0, #5
 8007c12:	f001 fddd 	bl	80097d0 <_test_assert>
 8007c16:	e7cd      	b.n	8007bb4 <test_007_007_execute.lto_priv.224+0xd4>
 8007c18:	20000c34 	.word	0x20000c34
 8007c1c:	20001e68 	.word	0x20001e68
 8007c20:	0800a9dc 	.word	0x0800a9dc
 8007c24:	08005451 	.word	0x08005451
 8007c28:	20001710 	.word	0x20001710
 8007c2c:	20001d98 	.word	0x20001d98
 8007c30:	0800c538 	.word	0x0800c538
 8007c34:	0800b610 	.word	0x0800b610
 8007c38:	20000c38 	.word	0x20000c38
 8007c3c:	0800ae3c 	.word	0x0800ae3c
 8007c40:	20001df8 	.word	0x20001df8
	...

08007c50 <test_007_006_execute.lto_priv.222>:
static void test_007_006_execute(void) {
 8007c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 8007c52:	4e6b      	ldr	r6, [pc, #428]	; (8007e00 <test_007_006_execute.lto_priv.222+0x1b0>)
 8007c54:	2301      	movs	r3, #1
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007c56:	2000      	movs	r0, #0
  test_set_step(1);
 8007c58:	6033      	str	r3, [r6, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8007c5a:	f002 fb69 	bl	800a330 <chEvtWaitOneTimeout.constprop.44>
    test_assert(m == 0, "spurious event");
 8007c5e:	fab0 f080 	clz	r0, r0
 8007c62:	0940      	lsrs	r0, r0, #5
 8007c64:	4967      	ldr	r1, [pc, #412]	; (8007e04 <test_007_006_execute.lto_priv.222+0x1b4>)
 8007c66:	f001 fdb3 	bl	80097d0 <_test_assert>
 8007c6a:	b100      	cbz	r0, 8007c6e <test_007_006_execute.lto_priv.222+0x1e>
 8007c6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8007c6e:	4c66      	ldr	r4, [pc, #408]	; (8007e08 <test_007_006_execute.lto_priv.222+0x1b8>)
 8007c70:	4605      	mov	r5, r0
 8007c72:	2320      	movs	r3, #32
 8007c74:	69a7      	ldr	r7, [r4, #24]
 8007c76:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007c7a:	f7f9 faf1 	bl	8001260 <_dbg_check_lock>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
 8007c7e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007c80:	2b00      	cmp	r3, #0
 8007c82:	f040 8097 	bne.w	8007db4 <test_007_006_execute.lto_priv.222+0x164>
  _dbg_check_unlock();
 8007c86:	f7f9 fac3 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007c8a:	6823      	ldr	r3, [r4, #0]
 8007c8c:	42a3      	cmp	r3, r4
 8007c8e:	d005      	beq.n	8007c9c <test_007_006_execute.lto_priv.222+0x4c>
 8007c90:	69a2      	ldr	r2, [r4, #24]
 8007c92:	689b      	ldr	r3, [r3, #8]
 8007c94:	6892      	ldr	r2, [r2, #8]
 8007c96:	429a      	cmp	r2, r3
 8007c98:	f0c0 8089 	bcc.w	8007dae <test_007_006_execute.lto_priv.222+0x15e>
 8007c9c:	2300      	movs	r3, #0
 8007c9e:	f383 8811 	msr	BASEPRI, r3
 8007ca2:	2001      	movs	r0, #1
    test_assert(m == 0, "spurious event");
 8007ca4:	4957      	ldr	r1, [pc, #348]	; (8007e04 <test_007_006_execute.lto_priv.222+0x1b4>)
 8007ca6:	f001 fd93 	bl	80097d0 <_test_assert>
 8007caa:	4605      	mov	r5, r0
 8007cac:	2800      	cmp	r0, #0
 8007cae:	d1dd      	bne.n	8007c6c <test_007_006_execute.lto_priv.222+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8007cb0:	69a7      	ldr	r7, [r4, #24]
 8007cb2:	2320      	movs	r3, #32
 8007cb4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007cb8:	f7f9 fad2 	bl	8001260 <_dbg_check_lock>

  chSysLock();
  if ((ctp->epending & events) != events) {
 8007cbc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007cbe:	3301      	adds	r3, #1
 8007cc0:	f000 8087 	beq.w	8007dd2 <test_007_006_execute.lto_priv.222+0x182>
  _dbg_check_unlock();
 8007cc4:	f7f9 faa4 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007cc8:	6823      	ldr	r3, [r4, #0]
 8007cca:	42a3      	cmp	r3, r4
 8007ccc:	d004      	beq.n	8007cd8 <test_007_006_execute.lto_priv.222+0x88>
 8007cce:	69a2      	ldr	r2, [r4, #24]
 8007cd0:	689b      	ldr	r3, [r3, #8]
 8007cd2:	6892      	ldr	r2, [r2, #8]
 8007cd4:	429a      	cmp	r2, r3
 8007cd6:	d36a      	bcc.n	8007dae <test_007_006_execute.lto_priv.222+0x15e>
 8007cd8:	2300      	movs	r3, #0
 8007cda:	f383 8811 	msr	BASEPRI, r3
 8007cde:	2501      	movs	r5, #1
    test_assert(m == 0, "spurious event");
 8007ce0:	4628      	mov	r0, r5
 8007ce2:	4948      	ldr	r1, [pc, #288]	; (8007e04 <test_007_006_execute.lto_priv.222+0x1b4>)
 8007ce4:	f001 fd74 	bl	80097d0 <_test_assert>
 8007ce8:	2800      	cmp	r0, #0
 8007cea:	d1bf      	bne.n	8007c6c <test_007_006_execute.lto_priv.222+0x1c>
  test_set_step(2);
 8007cec:	2302      	movs	r3, #2
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
 8007cee:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  test_set_step(2);
 8007cf2:	6033      	str	r3, [r6, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
 8007cf4:	f002 fb1c 	bl	800a330 <chEvtWaitOneTimeout.constprop.44>
    test_assert(m == 0, "spurious event");
 8007cf8:	fab0 f080 	clz	r0, r0
 8007cfc:	0940      	lsrs	r0, r0, #5
 8007cfe:	4941      	ldr	r1, [pc, #260]	; (8007e04 <test_007_006_execute.lto_priv.222+0x1b4>)
 8007d00:	f001 fd66 	bl	80097d0 <_test_assert>
 8007d04:	2800      	cmp	r0, #0
 8007d06:	d1b1      	bne.n	8007c6c <test_007_006_execute.lto_priv.222+0x1c>
  thread_t *ctp = currp;
 8007d08:	69a5      	ldr	r5, [r4, #24]
 8007d0a:	2320      	movs	r3, #32
 8007d0c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007d10:	f7f9 faa6 	bl	8001260 <_dbg_check_lock>
  m = ctp->epending & events;
 8007d14:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8007d16:	b956      	cbnz	r6, 8007d2e <test_007_006_execute.lto_priv.222+0xde>
    ctp->u.ewmask = events;
 8007d18:	f04f 33ff 	mov.w	r3, #4294967295
 8007d1c:	626b      	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8007d1e:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8007d22:	200a      	movs	r0, #10
 8007d24:	f7f9 f904 	bl	8000f30 <chSchGoSleepTimeoutS>
 8007d28:	2800      	cmp	r0, #0
 8007d2a:	db61      	blt.n	8007df0 <test_007_006_execute.lto_priv.222+0x1a0>
    m = ctp->epending & events;
 8007d2c:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  ctp->epending &= ~m;
 8007d2e:	2300      	movs	r3, #0
 8007d30:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
 8007d32:	f7f9 fa6d 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007d36:	6823      	ldr	r3, [r4, #0]
 8007d38:	42a3      	cmp	r3, r4
 8007d3a:	d004      	beq.n	8007d46 <test_007_006_execute.lto_priv.222+0xf6>
 8007d3c:	69a2      	ldr	r2, [r4, #24]
 8007d3e:	689b      	ldr	r3, [r3, #8]
 8007d40:	6892      	ldr	r2, [r2, #8]
 8007d42:	429a      	cmp	r2, r3
 8007d44:	d333      	bcc.n	8007dae <test_007_006_execute.lto_priv.222+0x15e>
 8007d46:	2300      	movs	r3, #0
 8007d48:	f383 8811 	msr	BASEPRI, r3
    test_assert(m == 0, "spurious event");
 8007d4c:	fab6 f086 	clz	r0, r6
 8007d50:	0940      	lsrs	r0, r0, #5
 8007d52:	492c      	ldr	r1, [pc, #176]	; (8007e04 <test_007_006_execute.lto_priv.222+0x1b4>)
 8007d54:	f001 fd3c 	bl	80097d0 <_test_assert>
 8007d58:	4605      	mov	r5, r0
 8007d5a:	2800      	cmp	r0, #0
 8007d5c:	d186      	bne.n	8007c6c <test_007_006_execute.lto_priv.222+0x1c>
  thread_t *ctp = currp;
 8007d5e:	69a6      	ldr	r6, [r4, #24]
 8007d60:	2320      	movs	r3, #32
 8007d62:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8007d66:	f7f9 fa7b 	bl	8001260 <_dbg_check_lock>
  if ((ctp->epending & events) != events) {
 8007d6a:	6b73      	ldr	r3, [r6, #52]	; 0x34
 8007d6c:	3301      	adds	r3, #1
 8007d6e:	d009      	beq.n	8007d84 <test_007_006_execute.lto_priv.222+0x134>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8007d70:	f04f 33ff 	mov.w	r3, #4294967295
 8007d74:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8007d76:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8007d7a:	200b      	movs	r0, #11
 8007d7c:	f7f9 f8d8 	bl	8000f30 <chSchGoSleepTimeoutS>
 8007d80:	2800      	cmp	r0, #0
 8007d82:	db38      	blt.n	8007df6 <test_007_006_execute.lto_priv.222+0x1a6>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
 8007d84:	2300      	movs	r3, #0
 8007d86:	6373      	str	r3, [r6, #52]	; 0x34
  _dbg_check_unlock();
 8007d88:	f7f9 fa42 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007d8c:	6823      	ldr	r3, [r4, #0]
 8007d8e:	42a3      	cmp	r3, r4
 8007d90:	d004      	beq.n	8007d9c <test_007_006_execute.lto_priv.222+0x14c>
 8007d92:	69a2      	ldr	r2, [r4, #24]
 8007d94:	689b      	ldr	r3, [r3, #8]
 8007d96:	6892      	ldr	r2, [r2, #8]
 8007d98:	429a      	cmp	r2, r3
 8007d9a:	d308      	bcc.n	8007dae <test_007_006_execute.lto_priv.222+0x15e>
 8007d9c:	2300      	movs	r3, #0
 8007d9e:	f383 8811 	msr	BASEPRI, r3
    test_assert(m == 0, "spurious event");
 8007da2:	4628      	mov	r0, r5
 8007da4:	4917      	ldr	r1, [pc, #92]	; (8007e04 <test_007_006_execute.lto_priv.222+0x1b4>)
}
 8007da6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(m == 0, "spurious event");
 8007daa:	f001 bd11 	b.w	80097d0 <_test_assert>
 8007dae:	4817      	ldr	r0, [pc, #92]	; (8007e0c <test_007_006_execute.lto_priv.222+0x1bc>)
 8007db0:	f7f8 fd36 	bl	8000820 <chSysHalt>
  ctp->epending &= ~m;
 8007db4:	637d      	str	r5, [r7, #52]	; 0x34
  _dbg_check_unlock();
 8007db6:	f7f9 fa2b 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007dba:	6823      	ldr	r3, [r4, #0]
 8007dbc:	42a3      	cmp	r3, r4
 8007dbe:	d004      	beq.n	8007dca <test_007_006_execute.lto_priv.222+0x17a>
 8007dc0:	69a2      	ldr	r2, [r4, #24]
 8007dc2:	689b      	ldr	r3, [r3, #8]
 8007dc4:	6892      	ldr	r2, [r2, #8]
 8007dc6:	429a      	cmp	r2, r3
 8007dc8:	d3f1      	bcc.n	8007dae <test_007_006_execute.lto_priv.222+0x15e>
 8007dca:	2000      	movs	r0, #0
 8007dcc:	f380 8811 	msr	BASEPRI, r0
 8007dd0:	e768      	b.n	8007ca4 <test_007_006_execute.lto_priv.222+0x54>
  ctp->epending &= ~events;
 8007dd2:	637d      	str	r5, [r7, #52]	; 0x34
  _dbg_check_unlock();
 8007dd4:	f7f9 fa1c 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007dd8:	6823      	ldr	r3, [r4, #0]
 8007dda:	42a3      	cmp	r3, r4
 8007ddc:	d004      	beq.n	8007de8 <test_007_006_execute.lto_priv.222+0x198>
 8007dde:	69a2      	ldr	r2, [r4, #24]
 8007de0:	689b      	ldr	r3, [r3, #8]
 8007de2:	6892      	ldr	r2, [r2, #8]
 8007de4:	429a      	cmp	r2, r3
 8007de6:	d3e2      	bcc.n	8007dae <test_007_006_execute.lto_priv.222+0x15e>
 8007de8:	2300      	movs	r3, #0
 8007dea:	f383 8811 	msr	BASEPRI, r3
 8007dee:	e777      	b.n	8007ce0 <test_007_006_execute.lto_priv.222+0x90>
      chSysUnlock();
 8007df0:	f7f9 fa1e 	bl	8001230 <chSysUnlock.lto_priv.83>
 8007df4:	e7aa      	b.n	8007d4c <test_007_006_execute.lto_priv.222+0xfc>
      chSysUnlock();
 8007df6:	f7f9 fa1b 	bl	8001230 <chSysUnlock.lto_priv.83>
 8007dfa:	2501      	movs	r5, #1
 8007dfc:	e7d1      	b.n	8007da2 <test_007_006_execute.lto_priv.222+0x152>
 8007dfe:	bf00      	nop
 8007e00:	20001df8 	.word	0x20001df8
 8007e04:	0800b630 	.word	0x0800b630
 8007e08:	20001e68 	.word	0x20001e68
 8007e0c:	0800c538 	.word	0x0800c538

08007e10 <null_provider>:

  (void)size;
  (void)align;

  return NULL;
}
 8007e10:	2000      	movs	r0, #0
 8007e12:	4770      	bx	lr
	...

08007e20 <test_010_001_setup.lto_priv.238>:
  H_NEXT(&heapp->header) = hp;
 8007e20:	4908      	ldr	r1, [pc, #32]	; (8007e44 <test_010_001_setup.lto_priv.238+0x24>)
  heapp->provider = NULL;
 8007e22:	4b09      	ldr	r3, [pc, #36]	; (8007e48 <test_010_001_setup.lto_priv.238+0x28>)
static void test_010_001_setup(void) {
 8007e24:	b410      	push	{r4}
 8007e26:	2200      	movs	r2, #0
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8007e28:	24cc      	movs	r4, #204	; 0xcc
 8007e2a:	e881 0014 	stmia.w	r1, {r2, r4}
  tqp->next = (thread_t *)tqp;
 8007e2e:	f103 0010 	add.w	r0, r3, #16
  H_NEXT(&heapp->header) = hp;
 8007e32:	6099      	str	r1, [r3, #8]
  H_PAGES(&heapp->header) = 0;
 8007e34:	60da      	str	r2, [r3, #12]
 8007e36:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8007e38:	6158      	str	r0, [r3, #20]
  heapp->provider = NULL;
 8007e3a:	601a      	str	r2, [r3, #0]
 8007e3c:	619a      	str	r2, [r3, #24]
}
 8007e3e:	bc10      	pop	{r4}
 8007e40:	4770      	bx	lr
 8007e42:	bf00      	nop
 8007e44:	20001710 	.word	0x20001710
 8007e48:	20001d78 	.word	0x20001d78
 8007e4c:	00000000 	.word	0x00000000

08007e50 <test_009_003_execute.lto_priv.237>:

static void test_009_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void test_009_003_execute(void) {
 8007e50:	b508      	push	{r3, lr}

  /* [9.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8007e52:	4b07      	ldr	r3, [pc, #28]	; (8007e70 <test_009_003_execute.lto_priv.237+0x20>)
 8007e54:	2201      	movs	r2, #1
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8007e56:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(1);
 8007e5a:	601a      	str	r2, [r3, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8007e5c:	f7fa f920 	bl	80020a0 <chGuardedPoolAllocTimeout.constprop.20>
 8007e60:	fab0 f080 	clz	r0, r0
 8007e64:	0940      	lsrs	r0, r0, #5
 8007e66:	4903      	ldr	r1, [pc, #12]	; (8007e74 <test_009_003_execute.lto_priv.237+0x24>)
  }
}
 8007e68:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8007e6c:	f001 bcb0 	b.w	80097d0 <_test_assert>
 8007e70:	20001df8 	.word	0x20001df8
 8007e74:	0800b72c 	.word	0x0800b72c
	...

08007e80 <test_009_003_setup.lto_priv.236>:
  mp->next = NULL;
 8007e80:	4b04      	ldr	r3, [pc, #16]	; (8007e94 <test_009_003_setup.lto_priv.236+0x14>)
 8007e82:	2200      	movs	r2, #0
  mp->object_size = size;
 8007e84:	2104      	movs	r1, #4
  tqp->next = (thread_t *)tqp;
 8007e86:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8007e88:	605b      	str	r3, [r3, #4]
 8007e8a:	6119      	str	r1, [r3, #16]
  mp->next = NULL;
 8007e8c:	60da      	str	r2, [r3, #12]
  mp->provider = provider;
 8007e8e:	615a      	str	r2, [r3, #20]
 8007e90:	609a      	str	r2, [r3, #8]
 8007e92:	4770      	bx	lr
 8007e94:	20000c04 	.word	0x20000c04
	...

08007ea0 <test_009_002_setup.lto_priv.234>:
 8007ea0:	f7ff bfee 	b.w	8007e80 <test_009_003_setup.lto_priv.236>
	...

08007eb0 <test_009_001_setup.lto_priv.232>:
  mp->next = NULL;
 8007eb0:	4b03      	ldr	r3, [pc, #12]	; (8007ec0 <test_009_001_setup.lto_priv.232+0x10>)
 8007eb2:	2200      	movs	r2, #0
  mp->object_size = size;
 8007eb4:	2104      	movs	r1, #4
 8007eb6:	6059      	str	r1, [r3, #4]
  mp->next = NULL;
 8007eb8:	601a      	str	r2, [r3, #0]
  mp->provider = provider;
 8007eba:	609a      	str	r2, [r3, #8]
 8007ebc:	4770      	bx	lr
 8007ebe:	bf00      	nop
 8007ec0:	20000c3c 	.word	0x20000c3c
	...

08007ed0 <test_008_003_setup.lto_priv.141>:
 *   active state.
 * - [8.3.4] Testing chMBFetch() and chMBFetchI() timeout.
 * .
 */

static void test_008_003_setup(void) {
 8007ed0:	b430      	push	{r4, r5}
  mbp->buffer = buf;
 8007ed2:	4b0a      	ldr	r3, [pc, #40]	; (8007efc <test_008_003_setup.lto_priv.141+0x2c>)
 8007ed4:	4a0a      	ldr	r2, [pc, #40]	; (8007f00 <test_008_003_setup.lto_priv.141+0x30>)
 8007ed6:	601a      	str	r2, [r3, #0]
  tqp->next = (thread_t *)tqp;
 8007ed8:	f103 0418 	add.w	r4, r3, #24
  mbp->top    = &buf[n];
 8007edc:	f102 0510 	add.w	r5, r2, #16
 8007ee0:	f103 0020 	add.w	r0, r3, #32
  mbp->cnt    = (cnt_t)0;
 8007ee4:	2100      	movs	r1, #0
  mbp->top    = &buf[n];
 8007ee6:	605d      	str	r5, [r3, #4]
 8007ee8:	619c      	str	r4, [r3, #24]
  tqp->prev = (thread_t *)tqp;
 8007eea:	61dc      	str	r4, [r3, #28]
  mbp->rdptr  = buf;
 8007eec:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 8007eee:	609a      	str	r2, [r3, #8]
  tqp->next = (thread_t *)tqp;
 8007ef0:	6218      	str	r0, [r3, #32]
  tqp->prev = (thread_t *)tqp;
 8007ef2:	6258      	str	r0, [r3, #36]	; 0x24
  mbp->cnt    = (cnt_t)0;
 8007ef4:	6119      	str	r1, [r3, #16]
  mbp->reset  = false;
 8007ef6:	7519      	strb	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8007ef8:	bc30      	pop	{r4, r5}
 8007efa:	4770      	bx	lr
 8007efc:	20000c60 	.word	0x20000c60
 8007f00:	20002710 	.word	0x20002710
	...

08007f10 <test_008_003_teardown.lto_priv.140>:

static void test_008_003_teardown(void) {
  chMBReset(&mb1);
 8007f10:	f7f9 bff6 	b.w	8001f00 <chMBReset.constprop.34>
	...

08007f20 <test_009_002_execute.lto_priv.235>:
static void test_009_002_execute(void) {
 8007f20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  test_set_step(1);
 8007f24:	f8df a140 	ldr.w	sl, [pc, #320]	; 8008068 <test_009_002_execute.lto_priv.235+0x148>
 *
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
 8007f28:	f8df 8134 	ldr.w	r8, [pc, #308]	; 8008060 <test_009_002_execute.lto_priv.235+0x140>
 8007f2c:	4d48      	ldr	r5, [pc, #288]	; (8008050 <test_009_002_execute.lto_priv.235+0x130>)
 8007f2e:	4c49      	ldr	r4, [pc, #292]	; (8008054 <test_009_002_execute.lto_priv.235+0x134>)
 8007f30:	2301      	movs	r3, #1
 8007f32:	f8ca 3000 	str.w	r3, [sl]
  chSemSignalI(&gmp->sem);
 8007f36:	f1a8 070c 	sub.w	r7, r8, #12
 8007f3a:	2604      	movs	r6, #4
 8007f3c:	f04f 0920 	mov.w	r9, #32
 8007f40:	f389 8811 	msr	BASEPRI, r9
  _dbg_check_lock();
 8007f44:	f7f9 f98c 	bl	8001260 <_dbg_check_lock>
  chPoolFreeI(&gmp->pool, objp);
 8007f48:	4629      	mov	r1, r5
 8007f4a:	4640      	mov	r0, r8
 8007f4c:	f7fc fc00 	bl	8004750 <chPoolFreeI>
  chSemSignalI(&gmp->sem);
 8007f50:	4638      	mov	r0, r7
 8007f52:	f7f8 fead 	bl	8000cb0 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8007f56:	f7f8 fd63 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8007f5a:	f7f9 f959 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007f5e:	6823      	ldr	r3, [r4, #0]
 8007f60:	42a3      	cmp	r3, r4
 8007f62:	d004      	beq.n	8007f6e <test_009_002_execute.lto_priv.235+0x4e>
 8007f64:	69a2      	ldr	r2, [r4, #24]
 8007f66:	689b      	ldr	r3, [r3, #8]
 8007f68:	6892      	ldr	r2, [r2, #8]
 8007f6a:	429a      	cmp	r2, r3
 8007f6c:	d36a      	bcc.n	8008044 <test_009_002_execute.lto_priv.235+0x124>
 8007f6e:	2300      	movs	r3, #0
 8007f70:	f383 8811 	msr	BASEPRI, r3
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8007f74:	693b      	ldr	r3, [r7, #16]
  while (n != 0U) {
 8007f76:	3e01      	subs	r6, #1
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8007f78:	441d      	add	r5, r3
  while (n != 0U) {
 8007f7a:	d1e1      	bne.n	8007f40 <test_009_002_execute.lto_priv.235+0x20>
  test_set_step(2);
 8007f7c:	2302      	movs	r3, #2
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8007f7e:	4e36      	ldr	r6, [pc, #216]	; (8008058 <test_009_002_execute.lto_priv.235+0x138>)
  test_set_step(2);
 8007f80:	f8ca 3000 	str.w	r3, [sl]
 8007f84:	2504      	movs	r5, #4
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8007f86:	2000      	movs	r0, #0
 8007f88:	f7fa f88a 	bl	80020a0 <chGuardedPoolAllocTimeout.constprop.20>
 8007f8c:	3000      	adds	r0, #0
 8007f8e:	bf18      	it	ne
 8007f90:	2001      	movne	r0, #1
 8007f92:	4631      	mov	r1, r6
 8007f94:	f001 fc1c 	bl	80097d0 <_test_assert>
 8007f98:	2800      	cmp	r0, #0
 8007f9a:	d156      	bne.n	800804a <test_009_002_execute.lto_priv.235+0x12a>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8007f9c:	3d01      	subs	r5, #1
 8007f9e:	d1f2      	bne.n	8007f86 <test_009_002_execute.lto_priv.235+0x66>
  test_set_step(3);
 8007fa0:	2303      	movs	r3, #3
 8007fa2:	f8ca 3000 	str.w	r3, [sl]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8007fa6:	f7fa f87b 	bl	80020a0 <chGuardedPoolAllocTimeout.constprop.20>
 8007faa:	fab0 f080 	clz	r0, r0
 8007fae:	0940      	lsrs	r0, r0, #5
 8007fb0:	492a      	ldr	r1, [pc, #168]	; (800805c <test_009_002_execute.lto_priv.235+0x13c>)
 8007fb2:	f001 fc0d 	bl	80097d0 <_test_assert>
 8007fb6:	2800      	cmp	r0, #0
 8007fb8:	d147      	bne.n	800804a <test_009_002_execute.lto_priv.235+0x12a>
 8007fba:	4d25      	ldr	r5, [pc, #148]	; (8008050 <test_009_002_execute.lto_priv.235+0x130>)
  chPoolFreeI(&gmp->pool, objp);
 8007fbc:	4e28      	ldr	r6, [pc, #160]	; (8008060 <test_009_002_execute.lto_priv.235+0x140>)
  test_set_step(4);
 8007fbe:	2304      	movs	r3, #4
 8007fc0:	f105 0910 	add.w	r9, r5, #16
  chSemSignalI(&gmp->sem);
 8007fc4:	f1a6 080c 	sub.w	r8, r6, #12
 8007fc8:	f8ca 3000 	str.w	r3, [sl]
 8007fcc:	2720      	movs	r7, #32
 8007fce:	f387 8811 	msr	BASEPRI, r7
  _dbg_check_lock();
 8007fd2:	f7f9 f945 	bl	8001260 <_dbg_check_lock>
  chPoolFreeI(&gmp->pool, objp);
 8007fd6:	4629      	mov	r1, r5
 8007fd8:	4630      	mov	r0, r6
 8007fda:	f7fc fbb9 	bl	8004750 <chPoolFreeI>
  chSemSignalI(&gmp->sem);
 8007fde:	4640      	mov	r0, r8
 8007fe0:	f7f8 fe66 	bl	8000cb0 <chSemSignalI>
  chSchRescheduleS();
 8007fe4:	f7f8 fd1c 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8007fe8:	f7f9 f912 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8007fec:	6823      	ldr	r3, [r4, #0]
 8007fee:	42a3      	cmp	r3, r4
 8007ff0:	d004      	beq.n	8007ffc <test_009_002_execute.lto_priv.235+0xdc>
 8007ff2:	69a2      	ldr	r2, [r4, #24]
 8007ff4:	689b      	ldr	r3, [r3, #8]
 8007ff6:	6892      	ldr	r2, [r2, #8]
 8007ff8:	429a      	cmp	r2, r3
 8007ffa:	d323      	bcc.n	8008044 <test_009_002_execute.lto_priv.235+0x124>
 8007ffc:	2300      	movs	r3, #0
 8007ffe:	f383 8811 	msr	BASEPRI, r3
 8008002:	3504      	adds	r5, #4
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8008004:	45a9      	cmp	r9, r5
 8008006:	d1e2      	bne.n	8007fce <test_009_002_execute.lto_priv.235+0xae>
  test_set_step(5);
 8008008:	2305      	movs	r3, #5
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800800a:	4d13      	ldr	r5, [pc, #76]	; (8008058 <test_009_002_execute.lto_priv.235+0x138>)
  test_set_step(5);
 800800c:	f8ca 3000 	str.w	r3, [sl]
 8008010:	2404      	movs	r4, #4
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8008012:	2000      	movs	r0, #0
 8008014:	f7fa f844 	bl	80020a0 <chGuardedPoolAllocTimeout.constprop.20>
 8008018:	3000      	adds	r0, #0
 800801a:	bf18      	it	ne
 800801c:	2001      	movne	r0, #1
 800801e:	4629      	mov	r1, r5
 8008020:	f001 fbd6 	bl	80097d0 <_test_assert>
 8008024:	b988      	cbnz	r0, 800804a <test_009_002_execute.lto_priv.235+0x12a>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8008026:	3c01      	subs	r4, #1
 8008028:	d1f3      	bne.n	8008012 <test_009_002_execute.lto_priv.235+0xf2>
  test_set_step(6);
 800802a:	2306      	movs	r3, #6
 800802c:	f8ca 3000 	str.w	r3, [sl]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8008030:	f7fa f836 	bl	80020a0 <chGuardedPoolAllocTimeout.constprop.20>
 8008034:	fab0 f080 	clz	r0, r0
 8008038:	0940      	lsrs	r0, r0, #5
 800803a:	4908      	ldr	r1, [pc, #32]	; (800805c <test_009_002_execute.lto_priv.235+0x13c>)
}
 800803c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8008040:	f001 bbc6 	b.w	80097d0 <_test_assert>
 8008044:	4807      	ldr	r0, [pc, #28]	; (8008064 <test_009_002_execute.lto_priv.235+0x144>)
 8008046:	f7f8 fbeb 	bl	8000820 <chSysHalt>
 800804a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800804e:	bf00      	nop
 8008050:	20001e3c 	.word	0x20001e3c
 8008054:	20001e68 	.word	0x20001e68
 8008058:	0800b720 	.word	0x0800b720
 800805c:	0800b72c 	.word	0x0800b72c
 8008060:	20000c10 	.word	0x20000c10
 8008064:	0800a840 	.word	0x0800a840
 8008068:	20001df8 	.word	0x20001df8
 800806c:	00000000 	.word	0x00000000

08008070 <test_009_001_execute.lto_priv.233>:
static void test_009_001_execute(void) {
 8008070:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_set_step(1);
 8008074:	f8df 915c 	ldr.w	r9, [pc, #348]	; 80081d4 <test_009_001_execute.lto_priv.233+0x164>
 8008078:	4d4e      	ldr	r5, [pc, #312]	; (80081b4 <test_009_001_execute.lto_priv.233+0x144>)
 800807a:	4c4f      	ldr	r4, [pc, #316]	; (80081b8 <test_009_001_execute.lto_priv.233+0x148>)
  chPoolFreeI(mp, objp);
 800807c:	4f4f      	ldr	r7, [pc, #316]	; (80081bc <test_009_001_execute.lto_priv.233+0x14c>)
 800807e:	2301      	movs	r3, #1
 8008080:	f8c9 3000 	str.w	r3, [r9]
 8008084:	2604      	movs	r6, #4
 8008086:	f04f 0820 	mov.w	r8, #32
 800808a:	f04f 0a00 	mov.w	sl, #0
 800808e:	f388 8811 	msr	BASEPRI, r8
  _dbg_check_lock();
 8008092:	f7f9 f8e5 	bl	8001260 <_dbg_check_lock>
 8008096:	4629      	mov	r1, r5
 8008098:	4638      	mov	r0, r7
 800809a:	f7fc fb59 	bl	8004750 <chPoolFreeI>
  _dbg_check_unlock();
 800809e:	f7f9 f8b7 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80080a2:	6823      	ldr	r3, [r4, #0]
 80080a4:	42a3      	cmp	r3, r4
 80080a6:	d004      	beq.n	80080b2 <test_009_001_execute.lto_priv.233+0x42>
 80080a8:	69a2      	ldr	r2, [r4, #24]
 80080aa:	689b      	ldr	r3, [r3, #8]
 80080ac:	6892      	ldr	r2, [r2, #8]
 80080ae:	429a      	cmp	r2, r3
 80080b0:	d37a      	bcc.n	80081a8 <test_009_001_execute.lto_priv.233+0x138>
 80080b2:	f38a 8811 	msr	BASEPRI, sl
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80080b6:	687b      	ldr	r3, [r7, #4]
  while (n != 0U) {
 80080b8:	3e01      	subs	r6, #1
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80080ba:	441d      	add	r5, r3
  while (n != 0U) {
 80080bc:	d1e7      	bne.n	800808e <test_009_001_execute.lto_priv.233+0x1e>
  test_set_step(2);
 80080be:	2302      	movs	r3, #2
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80080c0:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 80081bc <test_009_001_execute.lto_priv.233+0x14c>
 80080c4:	4e3e      	ldr	r6, [pc, #248]	; (80081c0 <test_009_001_execute.lto_priv.233+0x150>)
  test_set_step(2);
 80080c6:	f8c9 3000 	str.w	r3, [r9]
 80080ca:	2504      	movs	r5, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80080cc:	4640      	mov	r0, r8
 80080ce:	f7fc fe0f 	bl	8004cf0 <chPoolAlloc>
 80080d2:	3000      	adds	r0, #0
 80080d4:	bf18      	it	ne
 80080d6:	2001      	movne	r0, #1
 80080d8:	4631      	mov	r1, r6
 80080da:	f001 fb79 	bl	80097d0 <_test_assert>
 80080de:	2800      	cmp	r0, #0
 80080e0:	d165      	bne.n	80081ae <test_009_001_execute.lto_priv.233+0x13e>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80080e2:	3d01      	subs	r5, #1
 80080e4:	d1f2      	bne.n	80080cc <test_009_001_execute.lto_priv.233+0x5c>
  test_set_step(3);
 80080e6:	2303      	movs	r3, #3
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80080e8:	4834      	ldr	r0, [pc, #208]	; (80081bc <test_009_001_execute.lto_priv.233+0x14c>)
  test_set_step(3);
 80080ea:	f8c9 3000 	str.w	r3, [r9]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80080ee:	f7fc fdff 	bl	8004cf0 <chPoolAlloc>
 80080f2:	fab0 f080 	clz	r0, r0
 80080f6:	0940      	lsrs	r0, r0, #5
 80080f8:	4932      	ldr	r1, [pc, #200]	; (80081c4 <test_009_001_execute.lto_priv.233+0x154>)
 80080fa:	f001 fb69 	bl	80097d0 <_test_assert>
 80080fe:	2800      	cmp	r0, #0
 8008100:	d155      	bne.n	80081ae <test_009_001_execute.lto_priv.233+0x13e>
 8008102:	4e2c      	ldr	r6, [pc, #176]	; (80081b4 <test_009_001_execute.lto_priv.233+0x144>)
  chPoolFreeI(mp, objp);
 8008104:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 80081bc <test_009_001_execute.lto_priv.233+0x14c>
  test_set_step(4);
 8008108:	2304      	movs	r3, #4
 800810a:	f106 0b10 	add.w	fp, r6, #16
 800810e:	f8c9 3000 	str.w	r3, [r9]
 8008112:	f04f 0820 	mov.w	r8, #32
 8008116:	f388 8811 	msr	BASEPRI, r8
  _dbg_check_lock();
 800811a:	f7f9 f8a1 	bl	8001260 <_dbg_check_lock>
 800811e:	4631      	mov	r1, r6
 8008120:	4650      	mov	r0, sl
 8008122:	f7fc fb15 	bl	8004750 <chPoolFreeI>
  _dbg_check_unlock();
 8008126:	f7f9 f873 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800812a:	6823      	ldr	r3, [r4, #0]
 800812c:	42a3      	cmp	r3, r4
 800812e:	d004      	beq.n	800813a <test_009_001_execute.lto_priv.233+0xca>
 8008130:	69a2      	ldr	r2, [r4, #24]
 8008132:	689b      	ldr	r3, [r3, #8]
 8008134:	6892      	ldr	r2, [r2, #8]
 8008136:	429a      	cmp	r2, r3
 8008138:	d336      	bcc.n	80081a8 <test_009_001_execute.lto_priv.233+0x138>
 800813a:	f385 8811 	msr	BASEPRI, r5
 800813e:	3604      	adds	r6, #4
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8008140:	45b3      	cmp	fp, r6
 8008142:	d1e8      	bne.n	8008116 <test_009_001_execute.lto_priv.233+0xa6>
  test_set_step(5);
 8008144:	2305      	movs	r3, #5
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8008146:	4e1d      	ldr	r6, [pc, #116]	; (80081bc <test_009_001_execute.lto_priv.233+0x14c>)
 8008148:	4d1d      	ldr	r5, [pc, #116]	; (80081c0 <test_009_001_execute.lto_priv.233+0x150>)
  test_set_step(5);
 800814a:	f8c9 3000 	str.w	r3, [r9]
 800814e:	2404      	movs	r4, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8008150:	4630      	mov	r0, r6
 8008152:	f7fc fdcd 	bl	8004cf0 <chPoolAlloc>
 8008156:	3000      	adds	r0, #0
 8008158:	bf18      	it	ne
 800815a:	2001      	movne	r0, #1
 800815c:	4629      	mov	r1, r5
 800815e:	f001 fb37 	bl	80097d0 <_test_assert>
 8008162:	bb20      	cbnz	r0, 80081ae <test_009_001_execute.lto_priv.233+0x13e>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8008164:	3c01      	subs	r4, #1
 8008166:	d1f3      	bne.n	8008150 <test_009_001_execute.lto_priv.233+0xe0>
  test_set_step(6);
 8008168:	2306      	movs	r3, #6
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800816a:	4814      	ldr	r0, [pc, #80]	; (80081bc <test_009_001_execute.lto_priv.233+0x14c>)
  test_set_step(6);
 800816c:	f8c9 3000 	str.w	r3, [r9]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8008170:	f7fc fdbe 	bl	8004cf0 <chPoolAlloc>
 8008174:	fab0 f080 	clz	r0, r0
 8008178:	0940      	lsrs	r0, r0, #5
 800817a:	4912      	ldr	r1, [pc, #72]	; (80081c4 <test_009_001_execute.lto_priv.233+0x154>)
 800817c:	f001 fb28 	bl	80097d0 <_test_assert>
 8008180:	b9a8      	cbnz	r0, 80081ae <test_009_001_execute.lto_priv.233+0x13e>
  test_set_step(7);
 8008182:	2107      	movs	r1, #7
  mp->provider = provider;
 8008184:	4b10      	ldr	r3, [pc, #64]	; (80081c8 <test_009_001_execute.lto_priv.233+0x158>)
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8008186:	480d      	ldr	r0, [pc, #52]	; (80081bc <test_009_001_execute.lto_priv.233+0x14c>)
  test_set_step(7);
 8008188:	f8c9 1000 	str.w	r1, [r9]
  mp->object_size = size;
 800818c:	2204      	movs	r2, #4
  mp->next = NULL;
 800818e:	603c      	str	r4, [r7, #0]
  mp->object_size = size;
 8008190:	607a      	str	r2, [r7, #4]
  mp->provider = provider;
 8008192:	60bb      	str	r3, [r7, #8]
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8008194:	f7fc fdac 	bl	8004cf0 <chPoolAlloc>
 8008198:	fab0 f080 	clz	r0, r0
 800819c:	0940      	lsrs	r0, r0, #5
 800819e:	490b      	ldr	r1, [pc, #44]	; (80081cc <test_009_001_execute.lto_priv.233+0x15c>)
}
 80081a0:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 80081a4:	f001 bb14 	b.w	80097d0 <_test_assert>
 80081a8:	4809      	ldr	r0, [pc, #36]	; (80081d0 <test_009_001_execute.lto_priv.233+0x160>)
 80081aa:	f7f8 fb39 	bl	8000820 <chSysHalt>
 80081ae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80081b2:	bf00      	nop
 80081b4:	20001e3c 	.word	0x20001e3c
 80081b8:	20001e68 	.word	0x20001e68
 80081bc:	20000c3c 	.word	0x20000c3c
 80081c0:	0800b720 	.word	0x0800b720
 80081c4:	0800b72c 	.word	0x0800b72c
 80081c8:	08007e11 	.word	0x08007e11
 80081cc:	0800b704 	.word	0x0800b704
 80081d0:	0800a840 	.word	0x0800a840
 80081d4:	20001df8 	.word	0x20001df8
	...

080081e0 <test_008_003_execute.lto_priv.231>:
}

static void test_008_003_execute(void) {
 80081e0:	b570      	push	{r4, r5, r6, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
 80081e2:	4e57      	ldr	r6, [pc, #348]	; (8008340 <test_008_003_execute.lto_priv.231+0x160>)
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80081e4:	4d57      	ldr	r5, [pc, #348]	; (8008344 <test_008_003_execute.lto_priv.231+0x164>)
  test_set_step(1);
 80081e6:	2301      	movs	r3, #1
static void test_008_003_execute(void) {
 80081e8:	b082      	sub	sp, #8
  test_set_step(1);
 80081ea:	6033      	str	r3, [r6, #0]
 80081ec:	2442      	movs	r4, #66	; 0x42
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80081ee:	f04f 31ff 	mov.w	r1, #4294967295
 80081f2:	4620      	mov	r0, r4
 80081f4:	f7f9 fea4 	bl	8001f40 <chMBPost.constprop.32>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80081f8:	fab0 f080 	clz	r0, r0
 80081fc:	4629      	mov	r1, r5
 80081fe:	0940      	lsrs	r0, r0, #5
 8008200:	f001 fae6 	bl	80097d0 <_test_assert>
 8008204:	b988      	cbnz	r0, 800822a <test_008_003_execute.lto_priv.231+0x4a>
 8008206:	3401      	adds	r4, #1
    for (i = 0; i < MB_SIZE; i++) {
 8008208:	2c46      	cmp	r4, #70	; 0x46
 800820a:	d1f0      	bne.n	80081ee <test_008_003_execute.lto_priv.231+0xe>
    }
  }

  /* [8.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 800820c:	2302      	movs	r3, #2
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 800820e:	2101      	movs	r1, #1
 8008210:	2058      	movs	r0, #88	; 0x58
  test_set_step(2);
 8008212:	6033      	str	r3, [r6, #0]
    msg1 = chMBPost(&mb1, 'X', 1);
 8008214:	f7f9 fe94 	bl	8001f40 <chMBPost.constprop.32>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8008218:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 800821c:	fab0 f080 	clz	r0, r0
 8008220:	4948      	ldr	r1, [pc, #288]	; (8008344 <test_008_003_execute.lto_priv.231+0x164>)
 8008222:	0940      	lsrs	r0, r0, #5
 8008224:	f001 fad4 	bl	80097d0 <_test_assert>
 8008228:	b108      	cbz	r0, 800822e <test_008_003_execute.lto_priv.231+0x4e>
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  }
}
 800822a:	b002      	add	sp, #8
 800822c:	bd70      	pop	{r4, r5, r6, pc}
 800822e:	2320      	movs	r3, #32
 8008230:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008234:	f7f9 f814 	bl	8001260 <_dbg_check_lock>
    msg1 = chMBPostI(&mb1, 'X');
 8008238:	2058      	movs	r0, #88	; 0x58
 800823a:	f7f9 fd59 	bl	8001cf0 <chMBPostI.constprop.31>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800823e:	4c42      	ldr	r4, [pc, #264]	; (8008348 <test_008_003_execute.lto_priv.231+0x168>)
 8008240:	4605      	mov	r5, r0
  _dbg_check_unlock();
 8008242:	f7f8 ffe5 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008246:	6823      	ldr	r3, [r4, #0]
 8008248:	42a3      	cmp	r3, r4
 800824a:	d004      	beq.n	8008256 <test_008_003_execute.lto_priv.231+0x76>
 800824c:	69a2      	ldr	r2, [r4, #24]
 800824e:	689b      	ldr	r3, [r3, #8]
 8008250:	6892      	ldr	r2, [r2, #8]
 8008252:	429a      	cmp	r2, r3
 8008254:	d370      	bcc.n	8008338 <test_008_003_execute.lto_priv.231+0x158>
 8008256:	2300      	movs	r3, #0
 8008258:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800825c:	f1a5 30ff 	sub.w	r0, r5, #4294967295
 8008260:	fab0 f080 	clz	r0, r0
 8008264:	4937      	ldr	r1, [pc, #220]	; (8008344 <test_008_003_execute.lto_priv.231+0x164>)
 8008266:	0940      	lsrs	r0, r0, #5
 8008268:	f001 fab2 	bl	80097d0 <_test_assert>
 800826c:	2800      	cmp	r0, #0
 800826e:	d1dc      	bne.n	800822a <test_008_003_execute.lto_priv.231+0x4a>
    msg1 = chMBPostAhead(&mb1, 'X', 1);
 8008270:	2101      	movs	r1, #1
 8008272:	2058      	movs	r0, #88	; 0x58
 8008274:	f7f9 febc 	bl	8001ff0 <chMBPostAhead.constprop.29>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8008278:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 800827c:	fab0 f080 	clz	r0, r0
 8008280:	4930      	ldr	r1, [pc, #192]	; (8008344 <test_008_003_execute.lto_priv.231+0x164>)
 8008282:	0940      	lsrs	r0, r0, #5
 8008284:	f001 faa4 	bl	80097d0 <_test_assert>
 8008288:	2800      	cmp	r0, #0
 800828a:	d1ce      	bne.n	800822a <test_008_003_execute.lto_priv.231+0x4a>
 800828c:	2320      	movs	r3, #32
 800828e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008292:	f7f8 ffe5 	bl	8001260 <_dbg_check_lock>
    msg1 = chMBPostAheadI(&mb1, 'X');
 8008296:	2058      	movs	r0, #88	; 0x58
 8008298:	f7f9 fd5a 	bl	8001d50 <chMBPostAheadI.constprop.28>
 800829c:	4605      	mov	r5, r0
  _dbg_check_unlock();
 800829e:	f7f8 ffb7 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80082a2:	6823      	ldr	r3, [r4, #0]
 80082a4:	42a3      	cmp	r3, r4
 80082a6:	d004      	beq.n	80082b2 <test_008_003_execute.lto_priv.231+0xd2>
 80082a8:	69a2      	ldr	r2, [r4, #24]
 80082aa:	689b      	ldr	r3, [r3, #8]
 80082ac:	6892      	ldr	r2, [r2, #8]
 80082ae:	429a      	cmp	r2, r3
 80082b0:	d342      	bcc.n	8008338 <test_008_003_execute.lto_priv.231+0x158>
 80082b2:	2300      	movs	r3, #0
 80082b4:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80082b8:	f1a5 30ff 	sub.w	r0, r5, #4294967295
 80082bc:	fab0 f080 	clz	r0, r0
 80082c0:	4920      	ldr	r1, [pc, #128]	; (8008344 <test_008_003_execute.lto_priv.231+0x164>)
 80082c2:	0940      	lsrs	r0, r0, #5
 80082c4:	f001 fa84 	bl	80097d0 <_test_assert>
 80082c8:	4605      	mov	r5, r0
 80082ca:	2800      	cmp	r0, #0
 80082cc:	d1ad      	bne.n	800822a <test_008_003_execute.lto_priv.231+0x4a>
  test_set_step(3);
 80082ce:	2303      	movs	r3, #3
 80082d0:	6033      	str	r3, [r6, #0]
    chMBReset(&mb1);
 80082d2:	f7f9 fe15 	bl	8001f00 <chMBReset.constprop.34>
  mbp->reset = false;
 80082d6:	4a1d      	ldr	r2, [pc, #116]	; (800834c <test_008_003_execute.lto_priv.231+0x16c>)
  test_set_step(4);
 80082d8:	2304      	movs	r3, #4
    msg1 = chMBFetch(&mb1, &msg2, 1);
 80082da:	2101      	movs	r1, #1
 80082dc:	a801      	add	r0, sp, #4
 80082de:	7515      	strb	r5, [r2, #20]
  test_set_step(4);
 80082e0:	6033      	str	r3, [r6, #0]
    msg1 = chMBFetch(&mb1, &msg2, 1);
 80082e2:	f7f9 fdb5 	bl	8001e50 <chMBFetch.constprop.26>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80082e6:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 80082ea:	fab0 f080 	clz	r0, r0
 80082ee:	4915      	ldr	r1, [pc, #84]	; (8008344 <test_008_003_execute.lto_priv.231+0x164>)
 80082f0:	0940      	lsrs	r0, r0, #5
 80082f2:	f001 fa6d 	bl	80097d0 <_test_assert>
 80082f6:	2800      	cmp	r0, #0
 80082f8:	d197      	bne.n	800822a <test_008_003_execute.lto_priv.231+0x4a>
 80082fa:	2320      	movs	r3, #32
 80082fc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008300:	f7f8 ffae 	bl	8001260 <_dbg_check_lock>
    msg1 = chMBFetchI(&mb1, &msg2);
 8008304:	a801      	add	r0, sp, #4
 8008306:	f7f9 fd53 	bl	8001db0 <chMBFetchI.constprop.25>
 800830a:	4605      	mov	r5, r0
  _dbg_check_unlock();
 800830c:	f7f8 ff80 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008310:	6823      	ldr	r3, [r4, #0]
 8008312:	42a3      	cmp	r3, r4
 8008314:	d004      	beq.n	8008320 <test_008_003_execute.lto_priv.231+0x140>
 8008316:	69a2      	ldr	r2, [r4, #24]
 8008318:	689b      	ldr	r3, [r3, #8]
 800831a:	6892      	ldr	r2, [r2, #8]
 800831c:	429a      	cmp	r2, r3
 800831e:	d30b      	bcc.n	8008338 <test_008_003_execute.lto_priv.231+0x158>
 8008320:	2300      	movs	r3, #0
 8008322:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8008326:	f1a5 30ff 	sub.w	r0, r5, #4294967295
 800832a:	fab0 f080 	clz	r0, r0
 800832e:	4905      	ldr	r1, [pc, #20]	; (8008344 <test_008_003_execute.lto_priv.231+0x164>)
 8008330:	0940      	lsrs	r0, r0, #5
 8008332:	f001 fa4d 	bl	80097d0 <_test_assert>
 8008336:	e778      	b.n	800822a <test_008_003_execute.lto_priv.231+0x4a>
 8008338:	4805      	ldr	r0, [pc, #20]	; (8008350 <test_008_003_execute.lto_priv.231+0x170>)
 800833a:	f7f8 fa71 	bl	8000820 <chSysHalt>
 800833e:	bf00      	nop
 8008340:	20001df8 	.word	0x20001df8
 8008344:	0800aa04 	.word	0x0800aa04
 8008348:	20001e68 	.word	0x20001e68
 800834c:	20000c60 	.word	0x20000c60
 8008350:	0800b6f8 	.word	0x0800b6f8
	...

08008360 <test_008_002_execute.lto_priv.230>:
static void test_008_002_execute(void) {
 8008360:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_set_step(1);
 8008364:	4ec0      	ldr	r6, [pc, #768]	; (8008668 <test_008_002_execute.lto_priv.230+0x308>)
 8008366:	2301      	movs	r3, #1
static void test_008_002_execute(void) {
 8008368:	b083      	sub	sp, #12
  test_set_step(1);
 800836a:	6033      	str	r3, [r6, #0]
 800836c:	2320      	movs	r3, #32
 800836e:	f383 8811 	msr	BASEPRI, r3
  return (cnt_t)(mbp->top - mbp->buffer);
 8008372:	4cbe      	ldr	r4, [pc, #760]	; (800866c <test_008_002_execute.lto_priv.230+0x30c>)
  _dbg_check_lock();
 8008374:	f7f8 ff74 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8008378:	f7f8 faa2 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheckClassI();
 800837c:	f7f8 faa0 	bl	80008c0 <chDbgCheckClassI>
  return (cnt_t)(mbp->top - mbp->buffer);
 8008380:	e894 000c 	ldmia.w	r4, {r2, r3}
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8008384:	6920      	ldr	r0, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8008386:	49ba      	ldr	r1, [pc, #744]	; (8008670 <test_008_002_execute.lto_priv.230+0x310>)
  return (cnt_t)(mbp->top - mbp->buffer);
 8008388:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800838a:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 800838e:	f1a0 0004 	sub.w	r0, r0, #4
 8008392:	fab0 f080 	clz	r0, r0
 8008396:	0940      	lsrs	r0, r0, #5
 8008398:	f001 fa1a 	bl	80097d0 <_test_assert>
 800839c:	2800      	cmp	r0, #0
 800839e:	f040 819f 	bne.w	80086e0 <test_008_002_execute.lto_priv.230+0x380>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80083a2:	4db4      	ldr	r5, [pc, #720]	; (8008674 <test_008_002_execute.lto_priv.230+0x314>)
  _dbg_check_unlock();
 80083a4:	f7f8 ff34 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80083a8:	682b      	ldr	r3, [r5, #0]
 80083aa:	42ab      	cmp	r3, r5
 80083ac:	d005      	beq.n	80083ba <test_008_002_execute.lto_priv.230+0x5a>
 80083ae:	69aa      	ldr	r2, [r5, #24]
 80083b0:	689b      	ldr	r3, [r3, #8]
 80083b2:	6892      	ldr	r2, [r2, #8]
 80083b4:	429a      	cmp	r2, r3
 80083b6:	f0c0 8190 	bcc.w	80086da <test_008_002_execute.lto_priv.230+0x37a>
 80083ba:	2300      	movs	r3, #0
 80083bc:	f383 8811 	msr	BASEPRI, r3
  test_set_step(2);
 80083c0:	2302      	movs	r3, #2
 80083c2:	6033      	str	r3, [r6, #0]
 80083c4:	2320      	movs	r3, #32
 80083c6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80083ca:	f7f8 ff49 	bl	8001260 <_dbg_check_lock>
    chMBResetI(&mb1);
 80083ce:	f001 fdb7 	bl	8009f40 <chMBResetI.constprop.35>
  _dbg_check_unlock();
 80083d2:	f7f8 ff1d 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80083d6:	682b      	ldr	r3, [r5, #0]
 80083d8:	42ab      	cmp	r3, r5
 80083da:	d005      	beq.n	80083e8 <test_008_002_execute.lto_priv.230+0x88>
 80083dc:	69aa      	ldr	r2, [r5, #24]
 80083de:	689b      	ldr	r3, [r3, #8]
 80083e0:	6892      	ldr	r2, [r2, #8]
 80083e2:	429a      	cmp	r2, r3
 80083e4:	f0c0 8179 	bcc.w	80086da <test_008_002_execute.lto_priv.230+0x37a>
 80083e8:	2300      	movs	r3, #0
 80083ea:	f383 8811 	msr	BASEPRI, r3
 80083ee:	2320      	movs	r3, #32
 80083f0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80083f4:	f7f8 ff34 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 80083f8:	f7f8 fa62 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheckClassI();
 80083fc:	f7f8 fa60 	bl	80008c0 <chDbgCheckClassI>
  return (cnt_t)(mbp->top - mbp->buffer);
 8008400:	e894 000c 	ldmia.w	r4, {r2, r3}
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8008404:	6920      	ldr	r0, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8008406:	499c      	ldr	r1, [pc, #624]	; (8008678 <test_008_002_execute.lto_priv.230+0x318>)
  return (cnt_t)(mbp->top - mbp->buffer);
 8008408:	1a9b      	subs	r3, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800840a:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 800840e:	f1a0 0004 	sub.w	r0, r0, #4
 8008412:	fab0 f080 	clz	r0, r0
 8008416:	0940      	lsrs	r0, r0, #5
 8008418:	f001 f9da 	bl	80097d0 <_test_assert>
 800841c:	2800      	cmp	r0, #0
 800841e:	f040 8170 	bne.w	8008702 <test_008_002_execute.lto_priv.230+0x3a2>
  _dbg_check_unlock();
 8008422:	f7f8 fef5 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008426:	682b      	ldr	r3, [r5, #0]
 8008428:	42ab      	cmp	r3, r5
 800842a:	d005      	beq.n	8008438 <test_008_002_execute.lto_priv.230+0xd8>
 800842c:	69aa      	ldr	r2, [r5, #24]
 800842e:	689b      	ldr	r3, [r3, #8]
 8008430:	6892      	ldr	r2, [r2, #8]
 8008432:	429a      	cmp	r2, r3
 8008434:	f0c0 8151 	bcc.w	80086da <test_008_002_execute.lto_priv.230+0x37a>
 8008438:	2300      	movs	r3, #0
 800843a:	f383 8811 	msr	BASEPRI, r3
 800843e:	2320      	movs	r3, #32
 8008440:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008444:	f7f8 ff0c 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8008448:	f7f8 fa3a 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800844c:	6920      	ldr	r0, [r4, #16]
 800844e:	498b      	ldr	r1, [pc, #556]	; (800867c <test_008_002_execute.lto_priv.230+0x31c>)
 8008450:	fab0 f080 	clz	r0, r0
 8008454:	0940      	lsrs	r0, r0, #5
 8008456:	f001 f9bb 	bl	80097d0 <_test_assert>
 800845a:	2800      	cmp	r0, #0
 800845c:	f040 8151 	bne.w	8008702 <test_008_002_execute.lto_priv.230+0x3a2>
  _dbg_check_unlock();
 8008460:	f7f8 fed6 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008464:	682b      	ldr	r3, [r5, #0]
 8008466:	42ab      	cmp	r3, r5
 8008468:	d005      	beq.n	8008476 <test_008_002_execute.lto_priv.230+0x116>
 800846a:	69aa      	ldr	r2, [r5, #24]
 800846c:	689b      	ldr	r3, [r3, #8]
 800846e:	6892      	ldr	r2, [r2, #8]
 8008470:	429a      	cmp	r2, r3
 8008472:	f0c0 8132 	bcc.w	80086da <test_008_002_execute.lto_priv.230+0x37a>
 8008476:	2300      	movs	r3, #0
 8008478:	f383 8811 	msr	BASEPRI, r3
 800847c:	2320      	movs	r3, #32
 800847e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008482:	f7f8 feed 	bl	8001260 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8008486:	6820      	ldr	r0, [r4, #0]
 8008488:	68a3      	ldr	r3, [r4, #8]
 800848a:	497d      	ldr	r1, [pc, #500]	; (8008680 <test_008_002_execute.lto_priv.230+0x320>)
 800848c:	1ac0      	subs	r0, r0, r3
 800848e:	fab0 f080 	clz	r0, r0
 8008492:	0940      	lsrs	r0, r0, #5
 8008494:	f001 f99c 	bl	80097d0 <_test_assert>
 8008498:	2800      	cmp	r0, #0
 800849a:	f040 8132 	bne.w	8008702 <test_008_002_execute.lto_priv.230+0x3a2>
  _dbg_check_unlock();
 800849e:	f7f8 feb7 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80084a2:	682b      	ldr	r3, [r5, #0]
 80084a4:	42ab      	cmp	r3, r5
 80084a6:	d005      	beq.n	80084b4 <test_008_002_execute.lto_priv.230+0x154>
 80084a8:	69aa      	ldr	r2, [r5, #24]
 80084aa:	689b      	ldr	r3, [r3, #8]
 80084ac:	6892      	ldr	r2, [r2, #8]
 80084ae:	429a      	cmp	r2, r3
 80084b0:	f0c0 8113 	bcc.w	80086da <test_008_002_execute.lto_priv.230+0x37a>
 80084b4:	2300      	movs	r3, #0
 80084b6:	f383 8811 	msr	BASEPRI, r3
 80084ba:	2320      	movs	r3, #32
 80084bc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80084c0:	f7f8 fece 	bl	8001260 <_dbg_check_lock>
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80084c4:	6820      	ldr	r0, [r4, #0]
 80084c6:	68e3      	ldr	r3, [r4, #12]
 80084c8:	496e      	ldr	r1, [pc, #440]	; (8008684 <test_008_002_execute.lto_priv.230+0x324>)
 80084ca:	1ac0      	subs	r0, r0, r3
 80084cc:	fab0 f080 	clz	r0, r0
 80084d0:	0940      	lsrs	r0, r0, #5
 80084d2:	f001 f97d 	bl	80097d0 <_test_assert>
 80084d6:	2800      	cmp	r0, #0
 80084d8:	f040 8113 	bne.w	8008702 <test_008_002_execute.lto_priv.230+0x3a2>
  _dbg_check_unlock();
 80084dc:	f7f8 fe98 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80084e0:	682b      	ldr	r3, [r5, #0]
 80084e2:	42ab      	cmp	r3, r5
 80084e4:	d005      	beq.n	80084f2 <test_008_002_execute.lto_priv.230+0x192>
 80084e6:	69aa      	ldr	r2, [r5, #24]
 80084e8:	689b      	ldr	r3, [r3, #8]
 80084ea:	6892      	ldr	r2, [r2, #8]
 80084ec:	429a      	cmp	r2, r3
 80084ee:	f0c0 80f4 	bcc.w	80086da <test_008_002_execute.lto_priv.230+0x37a>
 80084f2:	2300      	movs	r3, #0
 80084f4:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 80084f8:	2203      	movs	r2, #3
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80084fa:	f8df 918c 	ldr.w	r9, [pc, #396]	; 8008688 <test_008_002_execute.lto_priv.230+0x328>
  mbp->reset = false;
 80084fe:	7523      	strb	r3, [r4, #20]
 8008500:	4698      	mov	r8, r3
  test_set_step(3);
 8008502:	6032      	str	r2, [r6, #0]
 8008504:	2742      	movs	r7, #66	; 0x42
 8008506:	f04f 0a20 	mov.w	sl, #32
 800850a:	f38a 8811 	msr	BASEPRI, sl
  _dbg_check_lock();
 800850e:	f7f8 fea7 	bl	8001260 <_dbg_check_lock>
      msg1 = chMBPostI(&mb1, 'B' + i);
 8008512:	4638      	mov	r0, r7
 8008514:	f7f9 fbec 	bl	8001cf0 <chMBPostI.constprop.31>
 8008518:	4683      	mov	fp, r0
  _dbg_check_unlock();
 800851a:	f7f8 fe79 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800851e:	682a      	ldr	r2, [r5, #0]
 8008520:	42aa      	cmp	r2, r5
 8008522:	d005      	beq.n	8008530 <test_008_002_execute.lto_priv.230+0x1d0>
 8008524:	69ab      	ldr	r3, [r5, #24]
 8008526:	6892      	ldr	r2, [r2, #8]
 8008528:	689b      	ldr	r3, [r3, #8]
 800852a:	4293      	cmp	r3, r2
 800852c:	f0c0 80d5 	bcc.w	80086da <test_008_002_execute.lto_priv.230+0x37a>
 8008530:	f388 8811 	msr	BASEPRI, r8
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008534:	fabb f08b 	clz	r0, fp
 8008538:	0940      	lsrs	r0, r0, #5
 800853a:	4649      	mov	r1, r9
 800853c:	f001 f948 	bl	80097d0 <_test_assert>
 8008540:	2800      	cmp	r0, #0
 8008542:	f040 80db 	bne.w	80086fc <test_008_002_execute.lto_priv.230+0x39c>
 8008546:	3701      	adds	r7, #1
    for (i = 0; i < MB_SIZE - 1; i++) {
 8008548:	2f45      	cmp	r7, #69	; 0x45
 800854a:	d1de      	bne.n	800850a <test_008_002_execute.lto_priv.230+0x1aa>
 800854c:	2320      	movs	r3, #32
 800854e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008552:	f7f8 fe85 	bl	8001260 <_dbg_check_lock>
    msg1 = chMBPostAheadI(&mb1, 'A');
 8008556:	2041      	movs	r0, #65	; 0x41
 8008558:	f7f9 fbfa 	bl	8001d50 <chMBPostAheadI.constprop.28>
 800855c:	4607      	mov	r7, r0
  _dbg_check_unlock();
 800855e:	f7f8 fe57 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008562:	682b      	ldr	r3, [r5, #0]
 8008564:	42ab      	cmp	r3, r5
 8008566:	d005      	beq.n	8008574 <test_008_002_execute.lto_priv.230+0x214>
 8008568:	69aa      	ldr	r2, [r5, #24]
 800856a:	689b      	ldr	r3, [r3, #8]
 800856c:	6892      	ldr	r2, [r2, #8]
 800856e:	429a      	cmp	r2, r3
 8008570:	f0c0 80b3 	bcc.w	80086da <test_008_002_execute.lto_priv.230+0x37a>
 8008574:	2300      	movs	r3, #0
 8008576:	f383 8811 	msr	BASEPRI, r3
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800857a:	fab7 f087 	clz	r0, r7
 800857e:	0940      	lsrs	r0, r0, #5
 8008580:	4941      	ldr	r1, [pc, #260]	; (8008688 <test_008_002_execute.lto_priv.230+0x328>)
 8008582:	f001 f925 	bl	80097d0 <_test_assert>
 8008586:	2800      	cmp	r0, #0
 8008588:	f040 80b8 	bne.w	80086fc <test_008_002_execute.lto_priv.230+0x39c>
  test_set_step(4);
 800858c:	2304      	movs	r3, #4
 800858e:	6033      	str	r3, [r6, #0]
 8008590:	2320      	movs	r3, #32
 8008592:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008596:	f7f8 fe63 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 800859a:	f7f8 f991 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheckClassI();
 800859e:	f7f8 f98f 	bl	80008c0 <chDbgCheckClassI>
  return (cnt_t)(mbp->top - mbp->buffer);
 80085a2:	e894 0009 	ldmia.w	r4, {r0, r3}
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 80085a6:	6922      	ldr	r2, [r4, #16]
 80085a8:	4938      	ldr	r1, [pc, #224]	; (800868c <test_008_002_execute.lto_priv.230+0x32c>)
 80085aa:	1a1b      	subs	r3, r3, r0
 80085ac:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 80085b0:	bf0c      	ite	eq
 80085b2:	2001      	moveq	r0, #1
 80085b4:	2000      	movne	r0, #0
 80085b6:	f001 f90b 	bl	80097d0 <_test_assert>
 80085ba:	2800      	cmp	r0, #0
 80085bc:	f040 80a1 	bne.w	8008702 <test_008_002_execute.lto_priv.230+0x3a2>
  _dbg_check_unlock();
 80085c0:	f7f8 fe26 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80085c4:	682b      	ldr	r3, [r5, #0]
 80085c6:	42ab      	cmp	r3, r5
 80085c8:	d005      	beq.n	80085d6 <test_008_002_execute.lto_priv.230+0x276>
 80085ca:	69aa      	ldr	r2, [r5, #24]
 80085cc:	689b      	ldr	r3, [r3, #8]
 80085ce:	6892      	ldr	r2, [r2, #8]
 80085d0:	429a      	cmp	r2, r3
 80085d2:	f0c0 8082 	bcc.w	80086da <test_008_002_execute.lto_priv.230+0x37a>
 80085d6:	2300      	movs	r3, #0
 80085d8:	f383 8811 	msr	BASEPRI, r3
 80085dc:	2320      	movs	r3, #32
 80085de:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80085e2:	f7f8 fe3d 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 80085e6:	f7f8 f96b 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 80085ea:	6920      	ldr	r0, [r4, #16]
 80085ec:	4928      	ldr	r1, [pc, #160]	; (8008690 <test_008_002_execute.lto_priv.230+0x330>)
 80085ee:	f1a0 0e04 	sub.w	lr, r0, #4
 80085f2:	f1de 0000 	rsbs	r0, lr, #0
 80085f6:	eb40 000e 	adc.w	r0, r0, lr
 80085fa:	f001 f8e9 	bl	80097d0 <_test_assert>
 80085fe:	2800      	cmp	r0, #0
 8008600:	d17f      	bne.n	8008702 <test_008_002_execute.lto_priv.230+0x3a2>
  _dbg_check_unlock();
 8008602:	f7f8 fe05 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008606:	682b      	ldr	r3, [r5, #0]
 8008608:	42ab      	cmp	r3, r5
 800860a:	d004      	beq.n	8008616 <test_008_002_execute.lto_priv.230+0x2b6>
 800860c:	69aa      	ldr	r2, [r5, #24]
 800860e:	689b      	ldr	r3, [r3, #8]
 8008610:	6892      	ldr	r2, [r2, #8]
 8008612:	429a      	cmp	r2, r3
 8008614:	d361      	bcc.n	80086da <test_008_002_execute.lto_priv.230+0x37a>
 8008616:	2300      	movs	r3, #0
 8008618:	f383 8811 	msr	BASEPRI, r3
 800861c:	2320      	movs	r3, #32
 800861e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008622:	f7f8 fe1d 	bl	8001260 <_dbg_check_lock>
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8008626:	68e0      	ldr	r0, [r4, #12]
 8008628:	68a3      	ldr	r3, [r4, #8]
 800862a:	491a      	ldr	r1, [pc, #104]	; (8008694 <test_008_002_execute.lto_priv.230+0x334>)
 800862c:	1ac7      	subs	r7, r0, r3
 800862e:	4278      	negs	r0, r7
 8008630:	4178      	adcs	r0, r7
 8008632:	f001 f8cd 	bl	80097d0 <_test_assert>
 8008636:	2800      	cmp	r0, #0
 8008638:	d163      	bne.n	8008702 <test_008_002_execute.lto_priv.230+0x3a2>
  _dbg_check_unlock();
 800863a:	f7f8 fde9 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800863e:	682b      	ldr	r3, [r5, #0]
 8008640:	42ab      	cmp	r3, r5
 8008642:	d004      	beq.n	800864e <test_008_002_execute.lto_priv.230+0x2ee>
 8008644:	69aa      	ldr	r2, [r5, #24]
 8008646:	689b      	ldr	r3, [r3, #8]
 8008648:	6892      	ldr	r2, [r2, #8]
 800864a:	429a      	cmp	r2, r3
 800864c:	d345      	bcc.n	80086da <test_008_002_execute.lto_priv.230+0x37a>
 800864e:	2300      	movs	r3, #0
 8008650:	f383 8811 	msr	BASEPRI, r3
  test_set_step(5);
 8008654:	2205      	movs	r2, #5
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008656:	f8df 9030 	ldr.w	r9, [pc, #48]	; 8008688 <test_008_002_execute.lto_priv.230+0x328>
  test_set_step(5);
 800865a:	6032      	str	r2, [r6, #0]
 800865c:	4698      	mov	r8, r3
 800865e:	2704      	movs	r7, #4
 8008660:	f04f 0a20 	mov.w	sl, #32
 8008664:	e027      	b.n	80086b6 <test_008_002_execute.lto_priv.230+0x356>
 8008666:	bf00      	nop
 8008668:	20001df8 	.word	0x20001df8
 800866c:	20000c60 	.word	0x20000c60
 8008670:	0800b640 	.word	0x0800b640
 8008674:	20001e68 	.word	0x20001e68
 8008678:	0800aad8 	.word	0x0800aad8
 800867c:	0800b64c 	.word	0x0800b64c
 8008680:	0800b658 	.word	0x0800b658
 8008684:	0800b67c 	.word	0x0800b67c
 8008688:	0800aa04 	.word	0x0800aa04
 800868c:	0800b6b4 	.word	0x0800b6b4
 8008690:	0800b6c0 	.word	0x0800b6c0
 8008694:	0800b6cc 	.word	0x0800b6cc
 8008698:	f388 8811 	msr	BASEPRI, r8
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800869c:	fabb f08b 	clz	r0, fp
 80086a0:	0940      	lsrs	r0, r0, #5
 80086a2:	4649      	mov	r1, r9
 80086a4:	f001 f894 	bl	80097d0 <_test_assert>
 80086a8:	bb40      	cbnz	r0, 80086fc <test_008_002_execute.lto_priv.230+0x39c>
      test_emit_token(msg2);
 80086aa:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80086ae:	f001 f9b7 	bl	8009a20 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 80086b2:	3f01      	subs	r7, #1
 80086b4:	d030      	beq.n	8008718 <test_008_002_execute.lto_priv.230+0x3b8>
 80086b6:	f38a 8811 	msr	BASEPRI, sl
  _dbg_check_lock();
 80086ba:	f7f8 fdd1 	bl	8001260 <_dbg_check_lock>
      msg1 = chMBFetchI(&mb1, &msg2);
 80086be:	a801      	add	r0, sp, #4
 80086c0:	f7f9 fb76 	bl	8001db0 <chMBFetchI.constprop.25>
 80086c4:	4683      	mov	fp, r0
  _dbg_check_unlock();
 80086c6:	f7f8 fda3 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80086ca:	682b      	ldr	r3, [r5, #0]
 80086cc:	42ab      	cmp	r3, r5
 80086ce:	d0e3      	beq.n	8008698 <test_008_002_execute.lto_priv.230+0x338>
 80086d0:	69aa      	ldr	r2, [r5, #24]
 80086d2:	689b      	ldr	r3, [r3, #8]
 80086d4:	6892      	ldr	r2, [r2, #8]
 80086d6:	429a      	cmp	r2, r3
 80086d8:	d2de      	bcs.n	8008698 <test_008_002_execute.lto_priv.230+0x338>
 80086da:	4840      	ldr	r0, [pc, #256]	; (80087dc <test_008_002_execute.lto_priv.230+0x47c>)
 80086dc:	f7f8 f8a0 	bl	8000820 <chSysHalt>
  _dbg_check_unlock();
 80086e0:	f7f8 fd96 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80086e4:	4b3e      	ldr	r3, [pc, #248]	; (80087e0 <test_008_002_execute.lto_priv.230+0x480>)
 80086e6:	681a      	ldr	r2, [r3, #0]
 80086e8:	429a      	cmp	r2, r3
 80086ea:	d004      	beq.n	80086f6 <test_008_002_execute.lto_priv.230+0x396>
 80086ec:	6999      	ldr	r1, [r3, #24]
 80086ee:	6893      	ldr	r3, [r2, #8]
 80086f0:	688a      	ldr	r2, [r1, #8]
 80086f2:	429a      	cmp	r2, r3
 80086f4:	d3f1      	bcc.n	80086da <test_008_002_execute.lto_priv.230+0x37a>
 80086f6:	2300      	movs	r3, #0
 80086f8:	f383 8811 	msr	BASEPRI, r3
}
 80086fc:	b003      	add	sp, #12
 80086fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  _dbg_check_unlock();
 8008702:	f7f8 fd85 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008706:	682b      	ldr	r3, [r5, #0]
 8008708:	42ab      	cmp	r3, r5
 800870a:	d0f4      	beq.n	80086f6 <test_008_002_execute.lto_priv.230+0x396>
 800870c:	69aa      	ldr	r2, [r5, #24]
 800870e:	689b      	ldr	r3, [r3, #8]
 8008710:	6892      	ldr	r2, [r2, #8]
 8008712:	429a      	cmp	r2, r3
 8008714:	d2ef      	bcs.n	80086f6 <test_008_002_execute.lto_priv.230+0x396>
 8008716:	e7e0      	b.n	80086da <test_008_002_execute.lto_priv.230+0x37a>
    test_assert_sequence("ABCD", "wrong get sequence");
 8008718:	4932      	ldr	r1, [pc, #200]	; (80087e4 <test_008_002_execute.lto_priv.230+0x484>)
 800871a:	4833      	ldr	r0, [pc, #204]	; (80087e8 <test_008_002_execute.lto_priv.230+0x488>)
 800871c:	f001 f830 	bl	8009780 <_test_assert_sequence>
 8008720:	2800      	cmp	r0, #0
 8008722:	d1eb      	bne.n	80086fc <test_008_002_execute.lto_priv.230+0x39c>
  test_set_step(6);
 8008724:	2306      	movs	r3, #6
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8008726:	f04f 31ff 	mov.w	r1, #4294967295
 800872a:	2046      	movs	r0, #70	; 0x46
  test_set_step(6);
 800872c:	6033      	str	r3, [r6, #0]
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800872e:	f7f9 fc07 	bl	8001f40 <chMBPost.constprop.32>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008732:	fab0 f080 	clz	r0, r0
 8008736:	0940      	lsrs	r0, r0, #5
 8008738:	492c      	ldr	r1, [pc, #176]	; (80087ec <test_008_002_execute.lto_priv.230+0x48c>)
 800873a:	f001 f849 	bl	80097d0 <_test_assert>
 800873e:	2800      	cmp	r0, #0
 8008740:	d1dc      	bne.n	80086fc <test_008_002_execute.lto_priv.230+0x39c>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8008742:	f04f 31ff 	mov.w	r1, #4294967295
 8008746:	a801      	add	r0, sp, #4
 8008748:	f7f9 fb82 	bl	8001e50 <chMBFetch.constprop.26>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800874c:	fab0 f080 	clz	r0, r0
 8008750:	0940      	lsrs	r0, r0, #5
 8008752:	4926      	ldr	r1, [pc, #152]	; (80087ec <test_008_002_execute.lto_priv.230+0x48c>)
 8008754:	f001 f83c 	bl	80097d0 <_test_assert>
 8008758:	2800      	cmp	r0, #0
 800875a:	d1cf      	bne.n	80086fc <test_008_002_execute.lto_priv.230+0x39c>
  test_set_step(7);
 800875c:	2307      	movs	r3, #7
 800875e:	6033      	str	r3, [r6, #0]
 8008760:	2520      	movs	r5, #32
 8008762:	f385 8811 	msr	BASEPRI, r5
  _dbg_check_lock();
 8008766:	f7f8 fd7b 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 800876a:	f7f8 f8a9 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheckClassI();
 800876e:	f7f8 f8a7 	bl	80008c0 <chDbgCheckClassI>
  return (cnt_t)(mbp->top - mbp->buffer);
 8008772:	e894 0005 	ldmia.w	r4, {r0, r2}
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8008776:	6923      	ldr	r3, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8008778:	491d      	ldr	r1, [pc, #116]	; (80087f0 <test_008_002_execute.lto_priv.230+0x490>)
  return (cnt_t)(mbp->top - mbp->buffer);
 800877a:	1a12      	subs	r2, r2, r0
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800877c:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8008780:	1f1e      	subs	r6, r3, #4
 8008782:	4270      	negs	r0, r6
 8008784:	4170      	adcs	r0, r6
 8008786:	f001 f823 	bl	80097d0 <_test_assert>
 800878a:	bb20      	cbnz	r0, 80087d6 <test_008_002_execute.lto_priv.230+0x476>
 800878c:	f7fe ff80 	bl	8007690 <chSysUnlock.lto_priv.135>
 8008790:	f385 8811 	msr	BASEPRI, r5
 8008794:	f7f8 fd64 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8008798:	f7f8 f892 	bl	80008c0 <chDbgCheckClassI>
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800879c:	6920      	ldr	r0, [r4, #16]
 800879e:	4915      	ldr	r1, [pc, #84]	; (80087f4 <test_008_002_execute.lto_priv.230+0x494>)
 80087a0:	fab0 f080 	clz	r0, r0
 80087a4:	0940      	lsrs	r0, r0, #5
 80087a6:	f001 f813 	bl	80097d0 <_test_assert>
 80087aa:	b9a0      	cbnz	r0, 80087d6 <test_008_002_execute.lto_priv.230+0x476>
 80087ac:	f7fe ff70 	bl	8007690 <chSysUnlock.lto_priv.135>
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80087b0:	6820      	ldr	r0, [r4, #0]
 80087b2:	68a3      	ldr	r3, [r4, #8]
 80087b4:	4910      	ldr	r1, [pc, #64]	; (80087f8 <test_008_002_execute.lto_priv.230+0x498>)
 80087b6:	1ac2      	subs	r2, r0, r3
 80087b8:	4250      	negs	r0, r2
 80087ba:	4150      	adcs	r0, r2
 80087bc:	f001 f808 	bl	80097d0 <_test_assert>
 80087c0:	2800      	cmp	r0, #0
 80087c2:	d19b      	bne.n	80086fc <test_008_002_execute.lto_priv.230+0x39c>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80087c4:	6820      	ldr	r0, [r4, #0]
 80087c6:	68e3      	ldr	r3, [r4, #12]
 80087c8:	490c      	ldr	r1, [pc, #48]	; (80087fc <test_008_002_execute.lto_priv.230+0x49c>)
 80087ca:	1ac3      	subs	r3, r0, r3
 80087cc:	4258      	negs	r0, r3
 80087ce:	4158      	adcs	r0, r3
 80087d0:	f000 fffe 	bl	80097d0 <_test_assert>
 80087d4:	e792      	b.n	80086fc <test_008_002_execute.lto_priv.230+0x39c>
 80087d6:	f7fe ff5b 	bl	8007690 <chSysUnlock.lto_priv.135>
 80087da:	e78f      	b.n	80086fc <test_008_002_execute.lto_priv.230+0x39c>
 80087dc:	0800b6f8 	.word	0x0800b6f8
 80087e0:	20001e68 	.word	0x20001e68
 80087e4:	0800b6e4 	.word	0x0800b6e4
 80087e8:	0800abe4 	.word	0x0800abe4
 80087ec:	0800aa04 	.word	0x0800aa04
 80087f0:	0800aad8 	.word	0x0800aad8
 80087f4:	0800b64c 	.word	0x0800b64c
 80087f8:	0800b658 	.word	0x0800b658
 80087fc:	0800b67c 	.word	0x0800b67c

08008800 <test_003_001_setup.lto_priv.184>:
 *   the state of the reference are tested.
 * .
 */

static void test_003_001_setup(void) {
  tr1 = NULL;
 8008800:	4b01      	ldr	r3, [pc, #4]	; (8008808 <test_003_001_setup.lto_priv.184+0x8>)
 8008802:	2200      	movs	r2, #0
 8008804:	601a      	str	r2, [r3, #0]
 8008806:	4770      	bx	lr
 8008808:	20001e4c 	.word	0x20001e4c
 800880c:	00000000 	.word	0x00000000

08008810 <test_001_004_execute.lto_priv.179>:

static void test_001_004_execute(void) {

  /* [1.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 8008810:	4b04      	ldr	r3, [pc, #16]	; (8008824 <test_001_004_execute.lto_priv.179+0x14>)
 8008812:	2101      	movs	r1, #1
 8008814:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8008818:	6019      	str	r1, [r3, #0]
 800881a:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800881c:	6a53      	ldr	r3, [r2, #36]	; 0x24
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
 800881e:	4299      	cmp	r1, r3
 8008820:	d0fc      	beq.n	800881c <test_001_004_execute.lto_priv.179+0xc>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 8008822:	4770      	bx	lr
 8008824:	20001df8 	.word	0x20001df8
	...

08008830 <thread3.lto_priv.158>:
static THD_FUNCTION(thread3, p) {
 8008830:	b510      	push	{r4, lr}
  chSemWait(&sem1);
 8008832:	4c04      	ldr	r4, [pc, #16]	; (8008844 <thread3.lto_priv.158+0x14>)
 8008834:	4620      	mov	r0, r4
 8008836:	f7f8 ff23 	bl	8001680 <chSemWait>
  chSemSignal(&sem1);
 800883a:	4620      	mov	r0, r4
}
 800883c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chSemSignal(&sem1);
 8008840:	f7f8 bee6 	b.w	8001610 <chSemSignal>
 8008844:	2000272c 	.word	0x2000272c
	...

08008850 <thread1.lto_priv.160>:
static THD_FUNCTION(thread1, p) {
 8008850:	b510      	push	{r4, lr}
 8008852:	4604      	mov	r4, r0
  chSemWait(&sem1);
 8008854:	4803      	ldr	r0, [pc, #12]	; (8008864 <thread1.lto_priv.160+0x14>)
 8008856:	f7f8 ff13 	bl	8001680 <chSemWait>
  test_emit_token(*(char *)p);
 800885a:	7820      	ldrb	r0, [r4, #0]
}
 800885c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
 8008860:	f001 b8de 	b.w	8009a20 <test_emit_token>
 8008864:	2000272c 	.word	0x2000272c
	...

08008870 <thread.lto_priv.130>:
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8008870:	7800      	ldrb	r0, [r0, #0]
 8008872:	f001 b8d5 	b.w	8009a20 <test_emit_token>
 8008876:	bf00      	nop
	...

08008880 <test_002_003_execute.lto_priv.182>:
 * - [2.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void test_002_003_execute(void) {
 8008880:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return ch.rlist.current;
 8008884:	4e1c      	ldr	r6, [pc, #112]	; (80088f8 <test_002_003_execute.lto_priv.182+0x78>)
  tprio_t prio, p1;

  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8008886:	4f1d      	ldr	r7, [pc, #116]	; (80088fc <test_002_003_execute.lto_priv.182+0x7c>)
  return chThdGetSelfX()->prio;
 8008888:	69b3      	ldr	r3, [r6, #24]
 800888a:	689c      	ldr	r4, [r3, #8]
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 800888c:	1c65      	adds	r5, r4, #1
  test_set_step(1);
 800888e:	2301      	movs	r3, #1
    p1 = chThdSetPriority(prio + 1);
 8008890:	4628      	mov	r0, r5
  test_set_step(1);
 8008892:	603b      	str	r3, [r7, #0]
    p1 = chThdSetPriority(prio + 1);
 8008894:	f7f8 ffec 	bl	8001870 <chThdSetPriority>
 8008898:	4680      	mov	r8, r0
    test_assert(p1 == prio, "unexpected returned priority level");
 800889a:	1b00      	subs	r0, r0, r4
 800889c:	fab0 f080 	clz	r0, r0
 80088a0:	0940      	lsrs	r0, r0, #5
 80088a2:	4917      	ldr	r1, [pc, #92]	; (8008900 <test_002_003_execute.lto_priv.182+0x80>)
 80088a4:	f000 ff94 	bl	80097d0 <_test_assert>
 80088a8:	b108      	cbz	r0, 80088ae <test_002_003_execute.lto_priv.182+0x2e>
 80088aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80088ae:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 80088b0:	4914      	ldr	r1, [pc, #80]	; (8008904 <test_002_003_execute.lto_priv.182+0x84>)
 80088b2:	6898      	ldr	r0, [r3, #8]
 80088b4:	1b40      	subs	r0, r0, r5
 80088b6:	fab0 f080 	clz	r0, r0
 80088ba:	0940      	lsrs	r0, r0, #5
 80088bc:	f000 ff88 	bl	80097d0 <_test_assert>
 80088c0:	2800      	cmp	r0, #0
 80088c2:	d1f2      	bne.n	80088aa <test_002_003_execute.lto_priv.182+0x2a>
  }

  /* [2.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 80088c4:	2302      	movs	r3, #2
  {
    p1 = chThdSetPriority(p1);
 80088c6:	4640      	mov	r0, r8
  test_set_step(2);
 80088c8:	603b      	str	r3, [r7, #0]
    p1 = chThdSetPriority(p1);
 80088ca:	f7f8 ffd1 	bl	8001870 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 80088ce:	1a28      	subs	r0, r5, r0
 80088d0:	fab0 f080 	clz	r0, r0
 80088d4:	490a      	ldr	r1, [pc, #40]	; (8008900 <test_002_003_execute.lto_priv.182+0x80>)
 80088d6:	0940      	lsrs	r0, r0, #5
 80088d8:	f000 ff7a 	bl	80097d0 <_test_assert>
 80088dc:	2800      	cmp	r0, #0
 80088de:	d1e4      	bne.n	80088aa <test_002_003_execute.lto_priv.182+0x2a>
 80088e0:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 80088e2:	4908      	ldr	r1, [pc, #32]	; (8008904 <test_002_003_execute.lto_priv.182+0x84>)
 80088e4:	6898      	ldr	r0, [r3, #8]
 80088e6:	1b00      	subs	r0, r0, r4
 80088e8:	fab0 f080 	clz	r0, r0
 80088ec:	0940      	lsrs	r0, r0, #5
  }
}
 80088ee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 80088f2:	f000 bf6d 	b.w	80097d0 <_test_assert>
 80088f6:	bf00      	nop
 80088f8:	20001e68 	.word	0x20001e68
 80088fc:	20001df8 	.word	0x20001df8
 8008900:	0800b81c 	.word	0x0800b81c
 8008904:	0800b840 	.word	0x0800b840
	...

08008910 <test_001_003_execute.lto_priv.178>:
static void test_001_003_execute(void) {
 8008910:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 8008912:	4b0e      	ldr	r3, [pc, #56]	; (800894c <test_001_003_execute.lto_priv.178+0x3c>)
 8008914:	2201      	movs	r2, #1
 8008916:	601a      	str	r2, [r3, #0]
 8008918:	2420      	movs	r4, #32
 800891a:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 800891e:	b662      	cpsie	i
  _dbg_check_suspend();
 8008920:	f7f9 f90e 	bl	8001b40 <_dbg_check_suspend>
  __ASM volatile ("cpsid i" : : : "memory");
 8008924:	b672      	cpsid	i
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8008926:	4b0a      	ldr	r3, [pc, #40]	; (8008950 <test_001_003_execute.lto_priv.178+0x40>)
 8008928:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800892a:	b90a      	cbnz	r2, 8008930 <test_001_003_execute.lto_priv.178+0x20>
 800892c:	6b5d      	ldr	r5, [r3, #52]	; 0x34
 800892e:	b115      	cbz	r5, 8008936 <test_001_003_execute.lto_priv.178+0x26>
    chSysHalt("SV#1");
 8008930:	4808      	ldr	r0, [pc, #32]	; (8008954 <test_001_003_execute.lto_priv.178+0x44>)
 8008932:	f7f7 ff75 	bl	8000820 <chSysHalt>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008936:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 800893a:	b662      	cpsie	i
 800893c:	f7f9 f900 	bl	8001b40 <_dbg_check_suspend>
  _dbg_check_enable();
 8008940:	f7f9 f8ee 	bl	8001b20 <_dbg_check_enable>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008944:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
 8008948:	b662      	cpsie	i
 800894a:	bd38      	pop	{r3, r4, r5, pc}
 800894c:	20001df8 	.word	0x20001df8
 8008950:	20001e68 	.word	0x20001e68
 8008954:	0800b814 	.word	0x0800b814
	...

08008960 <vtcb>:
static void vtcb(void *p) {
 8008960:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008962:	2420      	movs	r4, #32
 8008964:	f384 8811 	msr	BASEPRI, r4
  _dbg_check_lock_from_isr();
 8008968:	f7f8 fc02 	bl	8001170 <_dbg_check_lock_from_isr>
  _dbg_check_unlock_from_isr();
 800896c:	f7f8 fbe8 	bl	8001140 <_dbg_check_unlock_from_isr>
 8008970:	2300      	movs	r3, #0
 8008972:	f383 8811 	msr	BASEPRI, r3
 8008976:	f384 8811 	msr	BASEPRI, r4
  _dbg_check_lock_from_isr();
 800897a:	f7f8 fbf9 	bl	8001170 <_dbg_check_lock_from_isr>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800897e:	f3ef 8311 	mrs	r3, BASEPRI
  if (port_irq_enabled(sts)) {
 8008982:	b91b      	cbnz	r3, 800898c <vtcb+0x2c>
 8008984:	f7f9 f8bc 	bl	8001b00 <chSysGetStatusAndLockX.part.1>
 8008988:	f7f9 f8ea 	bl	8001b60 <chSysRestoreStatusX.part.2>
  _dbg_check_unlock_from_isr();
 800898c:	f7f8 fbd8 	bl	8001140 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008990:	2300      	movs	r3, #0
 8008992:	f383 8811 	msr	BASEPRI, r3
 8008996:	bd10      	pop	{r4, pc}
	...

080089a0 <test_wait_threads>:
}

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 80089a0:	b570      	push	{r4, r5, r6, lr}
 80089a2:	4c06      	ldr	r4, [pc, #24]	; (80089bc <test_wait_threads+0x1c>)
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 80089a4:	2600      	movs	r6, #0
 80089a6:	f104 0514 	add.w	r5, r4, #20
    if (threads[i] != NULL) {
 80089aa:	6820      	ldr	r0, [r4, #0]
 80089ac:	b110      	cbz	r0, 80089b4 <test_wait_threads+0x14>
      chThdWait(threads[i]);
 80089ae:	f7f9 f86f 	bl	8001a90 <chThdWait>
      threads[i] = NULL;
 80089b2:	6026      	str	r6, [r4, #0]
 80089b4:	3404      	adds	r4, #4
  for (i = 0; i < MAX_THREADS; i++)
 80089b6:	42ac      	cmp	r4, r5
 80089b8:	d1f7      	bne.n	80089aa <test_wait_threads+0xa>
    }
}
 80089ba:	bd70      	pop	{r4, r5, r6, pc}
 80089bc:	20001d98 	.word	0x20001d98

080089c0 <test_002_002_execute.lto_priv.181>:
static void test_002_002_execute(void) {
 80089c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 80089c2:	4d54      	ldr	r5, [pc, #336]	; (8008b14 <test_002_002_execute.lto_priv.181+0x154>)
  test_set_step(1);
 80089c4:	4e54      	ldr	r6, [pc, #336]	; (8008b18 <test_002_002_execute.lto_priv.181+0x158>)
  return chThdGetSelfX()->prio;
 80089c6:	69aa      	ldr	r2, [r5, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80089c8:	4b54      	ldr	r3, [pc, #336]	; (8008b1c <test_002_002_execute.lto_priv.181+0x15c>)
 80089ca:	6891      	ldr	r1, [r2, #8]
 80089cc:	4854      	ldr	r0, [pc, #336]	; (8008b20 <test_002_002_execute.lto_priv.181+0x160>)
 80089ce:	4a55      	ldr	r2, [pc, #340]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 80089d0:	4c55      	ldr	r4, [pc, #340]	; (8008b28 <test_002_002_execute.lto_priv.181+0x168>)
 80089d2:	3905      	subs	r1, #5
  test_set_step(1);
 80089d4:	2701      	movs	r7, #1
 80089d6:	6037      	str	r7, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80089d8:	f001 faca 	bl	8009f70 <chThdCreateStatic.constprop.72>
 80089dc:	69ab      	ldr	r3, [r5, #24]
 80089de:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80089e0:	6899      	ldr	r1, [r3, #8]
 80089e2:	4a50      	ldr	r2, [pc, #320]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 80089e4:	4b51      	ldr	r3, [pc, #324]	; (8008b2c <test_002_002_execute.lto_priv.181+0x16c>)
 80089e6:	4852      	ldr	r0, [pc, #328]	; (8008b30 <test_002_002_execute.lto_priv.181+0x170>)
 80089e8:	3904      	subs	r1, #4
 80089ea:	f001 fac1 	bl	8009f70 <chThdCreateStatic.constprop.72>
 80089ee:	69ab      	ldr	r3, [r5, #24]
 80089f0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80089f2:	6899      	ldr	r1, [r3, #8]
 80089f4:	4a4b      	ldr	r2, [pc, #300]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 80089f6:	4b4f      	ldr	r3, [pc, #316]	; (8008b34 <test_002_002_execute.lto_priv.181+0x174>)
 80089f8:	484f      	ldr	r0, [pc, #316]	; (8008b38 <test_002_002_execute.lto_priv.181+0x178>)
 80089fa:	3903      	subs	r1, #3
 80089fc:	f001 fab8 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008a00:	69ab      	ldr	r3, [r5, #24]
 8008a02:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8008a04:	6899      	ldr	r1, [r3, #8]
 8008a06:	4a47      	ldr	r2, [pc, #284]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008a08:	4b4c      	ldr	r3, [pc, #304]	; (8008b3c <test_002_002_execute.lto_priv.181+0x17c>)
 8008a0a:	484d      	ldr	r0, [pc, #308]	; (8008b40 <test_002_002_execute.lto_priv.181+0x180>)
 8008a0c:	3902      	subs	r1, #2
 8008a0e:	f001 faaf 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008a12:	69ab      	ldr	r3, [r5, #24]
 8008a14:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8008a16:	6899      	ldr	r1, [r3, #8]
 8008a18:	4a42      	ldr	r2, [pc, #264]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008a1a:	4b4a      	ldr	r3, [pc, #296]	; (8008b44 <test_002_002_execute.lto_priv.181+0x184>)
 8008a1c:	484a      	ldr	r0, [pc, #296]	; (8008b48 <test_002_002_execute.lto_priv.181+0x188>)
 8008a1e:	3901      	subs	r1, #1
 8008a20:	f001 faa6 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008a24:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 8008a26:	f7ff ffbb 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8008a2a:	4948      	ldr	r1, [pc, #288]	; (8008b4c <test_002_002_execute.lto_priv.181+0x18c>)
 8008a2c:	4848      	ldr	r0, [pc, #288]	; (8008b50 <test_002_002_execute.lto_priv.181+0x190>)
 8008a2e:	f000 fea7 	bl	8009780 <_test_assert_sequence>
 8008a32:	b100      	cbz	r0, 8008a36 <test_002_002_execute.lto_priv.181+0x76>
 8008a34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008a36:	69aa      	ldr	r2, [r5, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8008a38:	4b42      	ldr	r3, [pc, #264]	; (8008b44 <test_002_002_execute.lto_priv.181+0x184>)
 8008a3a:	6891      	ldr	r1, [r2, #8]
 8008a3c:	4842      	ldr	r0, [pc, #264]	; (8008b48 <test_002_002_execute.lto_priv.181+0x188>)
 8008a3e:	4a39      	ldr	r2, [pc, #228]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008a40:	3901      	subs	r1, #1
  test_set_step(2);
 8008a42:	2702      	movs	r7, #2
 8008a44:	6037      	str	r7, [r6, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8008a46:	f001 fa93 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008a4a:	69ab      	ldr	r3, [r5, #24]
 8008a4c:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8008a4e:	6899      	ldr	r1, [r3, #8]
 8008a50:	4a34      	ldr	r2, [pc, #208]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008a52:	4b3a      	ldr	r3, [pc, #232]	; (8008b3c <test_002_002_execute.lto_priv.181+0x17c>)
 8008a54:	483a      	ldr	r0, [pc, #232]	; (8008b40 <test_002_002_execute.lto_priv.181+0x180>)
 8008a56:	3902      	subs	r1, #2
 8008a58:	f001 fa8a 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008a5c:	69ab      	ldr	r3, [r5, #24]
 8008a5e:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8008a60:	6899      	ldr	r1, [r3, #8]
 8008a62:	4a30      	ldr	r2, [pc, #192]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008a64:	4b33      	ldr	r3, [pc, #204]	; (8008b34 <test_002_002_execute.lto_priv.181+0x174>)
 8008a66:	4834      	ldr	r0, [pc, #208]	; (8008b38 <test_002_002_execute.lto_priv.181+0x178>)
 8008a68:	3903      	subs	r1, #3
 8008a6a:	f001 fa81 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008a6e:	69ab      	ldr	r3, [r5, #24]
 8008a70:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8008a72:	6899      	ldr	r1, [r3, #8]
 8008a74:	4a2b      	ldr	r2, [pc, #172]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008a76:	4b2d      	ldr	r3, [pc, #180]	; (8008b2c <test_002_002_execute.lto_priv.181+0x16c>)
 8008a78:	482d      	ldr	r0, [pc, #180]	; (8008b30 <test_002_002_execute.lto_priv.181+0x170>)
 8008a7a:	3904      	subs	r1, #4
 8008a7c:	f001 fa78 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008a80:	69ab      	ldr	r3, [r5, #24]
 8008a82:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8008a84:	6899      	ldr	r1, [r3, #8]
 8008a86:	4a27      	ldr	r2, [pc, #156]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008a88:	4b24      	ldr	r3, [pc, #144]	; (8008b1c <test_002_002_execute.lto_priv.181+0x15c>)
 8008a8a:	4825      	ldr	r0, [pc, #148]	; (8008b20 <test_002_002_execute.lto_priv.181+0x160>)
 8008a8c:	3905      	subs	r1, #5
 8008a8e:	f001 fa6f 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008a92:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 8008a94:	f7ff ff84 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8008a98:	492c      	ldr	r1, [pc, #176]	; (8008b4c <test_002_002_execute.lto_priv.181+0x18c>)
 8008a9a:	482d      	ldr	r0, [pc, #180]	; (8008b50 <test_002_002_execute.lto_priv.181+0x190>)
 8008a9c:	f000 fe70 	bl	8009780 <_test_assert_sequence>
 8008aa0:	2800      	cmp	r0, #0
 8008aa2:	d1c7      	bne.n	8008a34 <test_002_002_execute.lto_priv.181+0x74>
 8008aa4:	69aa      	ldr	r2, [r5, #24]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8008aa6:	4b21      	ldr	r3, [pc, #132]	; (8008b2c <test_002_002_execute.lto_priv.181+0x16c>)
 8008aa8:	6891      	ldr	r1, [r2, #8]
 8008aaa:	4821      	ldr	r0, [pc, #132]	; (8008b30 <test_002_002_execute.lto_priv.181+0x170>)
 8008aac:	4a1d      	ldr	r2, [pc, #116]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008aae:	3904      	subs	r1, #4
  test_set_step(3);
 8008ab0:	2703      	movs	r7, #3
 8008ab2:	6037      	str	r7, [r6, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8008ab4:	f001 fa5c 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008ab8:	69ab      	ldr	r3, [r5, #24]
 8008aba:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8008abc:	6899      	ldr	r1, [r3, #8]
 8008abe:	4a19      	ldr	r2, [pc, #100]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008ac0:	4b16      	ldr	r3, [pc, #88]	; (8008b1c <test_002_002_execute.lto_priv.181+0x15c>)
 8008ac2:	4817      	ldr	r0, [pc, #92]	; (8008b20 <test_002_002_execute.lto_priv.181+0x160>)
 8008ac4:	3905      	subs	r1, #5
 8008ac6:	f001 fa53 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008aca:	69ab      	ldr	r3, [r5, #24]
 8008acc:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8008ace:	6899      	ldr	r1, [r3, #8]
 8008ad0:	4a14      	ldr	r2, [pc, #80]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008ad2:	4b1c      	ldr	r3, [pc, #112]	; (8008b44 <test_002_002_execute.lto_priv.181+0x184>)
 8008ad4:	481c      	ldr	r0, [pc, #112]	; (8008b48 <test_002_002_execute.lto_priv.181+0x188>)
 8008ad6:	3901      	subs	r1, #1
 8008ad8:	f001 fa4a 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008adc:	69ab      	ldr	r3, [r5, #24]
 8008ade:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8008ae0:	6899      	ldr	r1, [r3, #8]
 8008ae2:	4a10      	ldr	r2, [pc, #64]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008ae4:	4b15      	ldr	r3, [pc, #84]	; (8008b3c <test_002_002_execute.lto_priv.181+0x17c>)
 8008ae6:	4816      	ldr	r0, [pc, #88]	; (8008b40 <test_002_002_execute.lto_priv.181+0x180>)
 8008ae8:	3902      	subs	r1, #2
 8008aea:	f001 fa41 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008aee:	69ab      	ldr	r3, [r5, #24]
 8008af0:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8008af2:	6899      	ldr	r1, [r3, #8]
 8008af4:	4a0b      	ldr	r2, [pc, #44]	; (8008b24 <test_002_002_execute.lto_priv.181+0x164>)
 8008af6:	4b0f      	ldr	r3, [pc, #60]	; (8008b34 <test_002_002_execute.lto_priv.181+0x174>)
 8008af8:	480f      	ldr	r0, [pc, #60]	; (8008b38 <test_002_002_execute.lto_priv.181+0x178>)
 8008afa:	3903      	subs	r1, #3
 8008afc:	f001 fa38 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008b00:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
 8008b02:	f7ff ff4d 	bl	80089a0 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8008b06:	4911      	ldr	r1, [pc, #68]	; (8008b4c <test_002_002_execute.lto_priv.181+0x18c>)
 8008b08:	4811      	ldr	r0, [pc, #68]	; (8008b50 <test_002_002_execute.lto_priv.181+0x190>)
}
 8008b0a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8008b0e:	f000 be37 	b.w	8009780 <_test_assert_sequence>
 8008b12:	bf00      	nop
 8008b14:	20001e68 	.word	0x20001e68
 8008b18:	20001df8 	.word	0x20001df8
 8008b1c:	0800aa00 	.word	0x0800aa00
 8008b20:	20001710 	.word	0x20001710
 8008b24:	08008871 	.word	0x08008871
 8008b28:	20001d98 	.word	0x20001d98
 8008b2c:	0800b314 	.word	0x0800b314
 8008b30:	20001858 	.word	0x20001858
 8008b34:	0800a9e4 	.word	0x0800a9e4
 8008b38:	200019a0 	.word	0x200019a0
 8008b3c:	0800a9e0 	.word	0x0800a9e0
 8008b40:	20001ae8 	.word	0x20001ae8
 8008b44:	0800a9dc 	.word	0x0800a9dc
 8008b48:	20001c30 	.word	0x20001c30
 8008b4c:	0800a9e8 	.word	0x0800a9e8
 8008b50:	0800a9fc 	.word	0x0800a9fc
	...

08008b60 <thread2.lto_priv.161>:
static THD_FUNCTION(thread2, p) {
 8008b60:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(50);
 8008b62:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8008b66:	f7f8 fe5b 	bl	8001820 <chThdSleep>
 8008b6a:	2320      	movs	r3, #32
 8008b6c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008b70:	f7f8 fb76 	bl	8001260 <_dbg_check_lock>
  chSemSignalI(&sem1); /* For coverage reasons */
 8008b74:	480b      	ldr	r0, [pc, #44]	; (8008ba4 <thread2.lto_priv.161+0x44>)
 8008b76:	f7f8 f89b 	bl	8000cb0 <chSemSignalI>
  chSchRescheduleS();
 8008b7a:	f7f7 ff51 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8008b7e:	f7f8 fb47 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008b82:	4b09      	ldr	r3, [pc, #36]	; (8008ba8 <thread2.lto_priv.161+0x48>)
 8008b84:	681a      	ldr	r2, [r3, #0]
 8008b86:	429a      	cmp	r2, r3
 8008b88:	d004      	beq.n	8008b94 <thread2.lto_priv.161+0x34>
 8008b8a:	6999      	ldr	r1, [r3, #24]
 8008b8c:	6893      	ldr	r3, [r2, #8]
 8008b8e:	688a      	ldr	r2, [r1, #8]
 8008b90:	429a      	cmp	r2, r3
 8008b92:	d303      	bcc.n	8008b9c <thread2.lto_priv.161+0x3c>
 8008b94:	2300      	movs	r3, #0
 8008b96:	f383 8811 	msr	BASEPRI, r3
 8008b9a:	bd08      	pop	{r3, pc}
 8008b9c:	4803      	ldr	r0, [pc, #12]	; (8008bac <thread2.lto_priv.161+0x4c>)
 8008b9e:	f7f7 fe3f 	bl	8000820 <chSysHalt>
 8008ba2:	bf00      	nop
 8008ba4:	2000272c 	.word	0x2000272c
 8008ba8:	20001e68 	.word	0x20001e68
 8008bac:	0800a984 	.word	0x0800a984

08008bb0 <test_003_001_execute.lto_priv.185>:
}

static void test_003_001_execute(void) {
 8008bb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return ch.rlist.current;
 8008bb2:	4c41      	ldr	r4, [pc, #260]	; (8008cb8 <test_003_001_execute.lto_priv.185+0x108>)
  msg_t msg;

  /* [3.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 8008bb4:	4e41      	ldr	r6, [pc, #260]	; (8008cbc <test_003_001_execute.lto_priv.185+0x10c>)
  return chThdGetSelfX()->prio;
 8008bb6:	69a2      	ldr	r2, [r4, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 8008bb8:	4b41      	ldr	r3, [pc, #260]	; (8008cc0 <test_003_001_execute.lto_priv.185+0x110>)
 8008bba:	6891      	ldr	r1, [r2, #8]
 8008bbc:	4841      	ldr	r0, [pc, #260]	; (8008cc4 <test_003_001_execute.lto_priv.185+0x114>)
 8008bbe:	4a42      	ldr	r2, [pc, #264]	; (8008cc8 <test_003_001_execute.lto_priv.185+0x118>)
 8008bc0:	3901      	subs	r1, #1
  test_set_step(1);
 8008bc2:	2501      	movs	r5, #1
 8008bc4:	6035      	str	r5, [r6, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 8008bc6:	f001 f9d3 	bl	8009f70 <chThdCreateStatic.constprop.72>
 8008bca:	4a40      	ldr	r2, [pc, #256]	; (8008ccc <test_003_001_execute.lto_priv.185+0x11c>)
 8008bcc:	2320      	movs	r3, #32
 8008bce:	6010      	str	r0, [r2, #0]
 8008bd0:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(*trp == NULL, "not NULL");
 8008bd4:	4d3e      	ldr	r5, [pc, #248]	; (8008cd0 <test_003_001_execute.lto_priv.185+0x120>)
  _dbg_check_lock();
 8008bd6:	f7f8 fb43 	bl	8001260 <_dbg_check_lock>
 8008bda:	682b      	ldr	r3, [r5, #0]
 8008bdc:	b113      	cbz	r3, 8008be4 <test_003_001_execute.lto_priv.185+0x34>
 8008bde:	483d      	ldr	r0, [pc, #244]	; (8008cd4 <test_003_001_execute.lto_priv.185+0x124>)
 8008be0:	f7f7 fe1e 	bl	8000820 <chSysHalt>
  return ch.rlist.current;
 8008be4:	69a3      	ldr	r3, [r4, #24]
  *trp = tp;
 8008be6:	602b      	str	r3, [r5, #0]
  tp->u.wttrp = trp;
 8008be8:	625d      	str	r5, [r3, #36]	; 0x24
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8008bea:	f04f 31ff 	mov.w	r1, #4294967295
 8008bee:	2003      	movs	r0, #3
 8008bf0:	f7f8 f99e 	bl	8000f30 <chSchGoSleepTimeoutS>
 8008bf4:	4607      	mov	r7, r0
  _dbg_check_unlock();
 8008bf6:	f7f8 fb0b 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008bfa:	6823      	ldr	r3, [r4, #0]
 8008bfc:	42a3      	cmp	r3, r4
 8008bfe:	d004      	beq.n	8008c0a <test_003_001_execute.lto_priv.185+0x5a>
 8008c00:	69a2      	ldr	r2, [r4, #24]
 8008c02:	689b      	ldr	r3, [r3, #8]
 8008c04:	6892      	ldr	r2, [r2, #8]
 8008c06:	429a      	cmp	r2, r3
 8008c08:	d30b      	bcc.n	8008c22 <test_003_001_execute.lto_priv.185+0x72>
 8008c0a:	2300      	movs	r3, #0
 8008c0c:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 8008c10:	6828      	ldr	r0, [r5, #0]
 8008c12:	4931      	ldr	r1, [pc, #196]	; (8008cd8 <test_003_001_execute.lto_priv.185+0x128>)
 8008c14:	fab0 f080 	clz	r0, r0
 8008c18:	0940      	lsrs	r0, r0, #5
 8008c1a:	f000 fdd9 	bl	80097d0 <_test_assert>
 8008c1e:	b118      	cbz	r0, 8008c28 <test_003_001_execute.lto_priv.185+0x78>
 8008c20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008c22:	482e      	ldr	r0, [pc, #184]	; (8008cdc <test_003_001_execute.lto_priv.185+0x12c>)
 8008c24:	f7f7 fdfc 	bl	8000820 <chSysHalt>
    test_assert(MSG_OK == msg,"wrong returned message");
 8008c28:	fab7 f087 	clz	r0, r7
 8008c2c:	0940      	lsrs	r0, r0, #5
 8008c2e:	492c      	ldr	r1, [pc, #176]	; (8008ce0 <test_003_001_execute.lto_priv.185+0x130>)
 8008c30:	f000 fdce 	bl	80097d0 <_test_assert>
 8008c34:	2800      	cmp	r0, #0
 8008c36:	d1f3      	bne.n	8008c20 <test_003_001_execute.lto_priv.185+0x70>
    test_wait_threads();
 8008c38:	f7ff feb2 	bl	80089a0 <test_wait_threads>
  }

  /* [3.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
 8008c3c:	2302      	movs	r3, #2
 8008c3e:	6033      	str	r3, [r6, #0]
 8008c40:	2320      	movs	r3, #32
 8008c42:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008c46:	f7f8 fb0b 	bl	8001260 <_dbg_check_lock>
 8008c4a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  chDbgAssert(*trp == NULL, "not NULL");
 8008c4e:	682b      	ldr	r3, [r5, #0]
 8008c50:	6a56      	ldr	r6, [r2, #36]	; 0x24
 8008c52:	2b00      	cmp	r3, #0
 8008c54:	d1c3      	bne.n	8008bde <test_003_001_execute.lto_priv.185+0x2e>
 8008c56:	69a3      	ldr	r3, [r4, #24]
  *trp = tp;
 8008c58:	602b      	str	r3, [r5, #0]
  tp->u.wttrp = trp;
 8008c5a:	625d      	str	r5, [r3, #36]	; 0x24
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8008c5c:	f242 7110 	movw	r1, #10000	; 0x2710
 8008c60:	2003      	movs	r0, #3
 8008c62:	f7f8 f965 	bl	8000f30 <chSchGoSleepTimeoutS>
 8008c66:	4607      	mov	r7, r0
  _dbg_check_unlock();
 8008c68:	f7f8 fad2 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008c6c:	6823      	ldr	r3, [r4, #0]
 8008c6e:	42a3      	cmp	r3, r4
 8008c70:	d004      	beq.n	8008c7c <test_003_001_execute.lto_priv.185+0xcc>
 8008c72:	69a2      	ldr	r2, [r4, #24]
 8008c74:	689b      	ldr	r3, [r3, #8]
 8008c76:	6892      	ldr	r2, [r2, #8]
 8008c78:	429a      	cmp	r2, r3
 8008c7a:	d3d2      	bcc.n	8008c22 <test_003_001_execute.lto_priv.185+0x72>
 8008c7c:	2300      	movs	r3, #0
 8008c7e:	f383 8811 	msr	BASEPRI, r3
  {
    chSysLock();
    time = chVTGetSystemTimeX();
    msg = chThdSuspendTimeoutS(&tr1, MS2ST(1000));
    chSysUnlock();
    test_assert_time_window(time + MS2ST(1000),
 8008c82:	f506 511c 	add.w	r1, r6, #9984	; 0x2700
 8008c86:	4608      	mov	r0, r1
 8008c88:	3010      	adds	r0, #16
 8008c8a:	3113      	adds	r1, #19
 8008c8c:	f7f9 f8c0 	bl	8001e10 <_test_assert_time_window.constprop.3>
 8008c90:	2800      	cmp	r0, #0
 8008c92:	d1c5      	bne.n	8008c20 <test_003_001_execute.lto_priv.185+0x70>
                            time + MS2ST(1000) + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
 8008c94:	6828      	ldr	r0, [r5, #0]
 8008c96:	4910      	ldr	r1, [pc, #64]	; (8008cd8 <test_003_001_execute.lto_priv.185+0x128>)
 8008c98:	fab0 f080 	clz	r0, r0
 8008c9c:	0940      	lsrs	r0, r0, #5
 8008c9e:	f000 fd97 	bl	80097d0 <_test_assert>
 8008ca2:	2800      	cmp	r0, #0
 8008ca4:	d1bc      	bne.n	8008c20 <test_003_001_execute.lto_priv.185+0x70>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8008ca6:	1c7b      	adds	r3, r7, #1
 8008ca8:	4258      	negs	r0, r3
 8008caa:	4158      	adcs	r0, r3
 8008cac:	490c      	ldr	r1, [pc, #48]	; (8008ce0 <test_003_001_execute.lto_priv.185+0x130>)
  }
}
 8008cae:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8008cb2:	f000 bd8d 	b.w	80097d0 <_test_assert>
 8008cb6:	bf00      	nop
 8008cb8:	20001e68 	.word	0x20001e68
 8008cbc:	20001df8 	.word	0x20001df8
 8008cc0:	0800a9dc 	.word	0x0800a9dc
 8008cc4:	20001710 	.word	0x20001710
 8008cc8:	08008cf1 	.word	0x08008cf1
 8008ccc:	20001d98 	.word	0x20001d98
 8008cd0:	20001e4c 	.word	0x20001e4c
 8008cd4:	0800b778 	.word	0x0800b778
 8008cd8:	0800b8a4 	.word	0x0800b8a4
 8008cdc:	0800b760 	.word	0x0800b760
 8008ce0:	0800a9c4 	.word	0x0800a9c4
	...

08008cf0 <thread1>:
static THD_FUNCTION(thread1, p) {
 8008cf0:	b510      	push	{r4, lr}
 8008cf2:	2320      	movs	r3, #32
 8008cf4:	4604      	mov	r4, r0
 8008cf6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008cfa:	f7f8 fab1 	bl	8001260 <_dbg_check_lock>
  chThdResumeI(&tr1, MSG_OK);
 8008cfe:	480d      	ldr	r0, [pc, #52]	; (8008d34 <thread1+0x44>)
 8008d00:	f001 f826 	bl	8009d50 <chThdResumeI.constprop.70>
  chSchRescheduleS();
 8008d04:	f7f7 fe8c 	bl	8000a20 <chSchRescheduleS>
  _dbg_check_unlock();
 8008d08:	f7f8 fa82 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008d0c:	4b0a      	ldr	r3, [pc, #40]	; (8008d38 <thread1+0x48>)
 8008d0e:	681a      	ldr	r2, [r3, #0]
 8008d10:	429a      	cmp	r2, r3
 8008d12:	d004      	beq.n	8008d1e <thread1+0x2e>
 8008d14:	6999      	ldr	r1, [r3, #24]
 8008d16:	6893      	ldr	r3, [r2, #8]
 8008d18:	688a      	ldr	r2, [r1, #8]
 8008d1a:	429a      	cmp	r2, r3
 8008d1c:	d307      	bcc.n	8008d2e <thread1+0x3e>
 8008d1e:	2300      	movs	r3, #0
 8008d20:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 8008d24:	7820      	ldrb	r0, [r4, #0]
}
 8008d26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
 8008d2a:	f000 be79 	b.w	8009a20 <test_emit_token>
 8008d2e:	4803      	ldr	r0, [pc, #12]	; (8008d3c <thread1+0x4c>)
 8008d30:	f7f7 fd76 	bl	8000820 <chSysHalt>
 8008d34:	20001e4c 	.word	0x20001e4c
 8008d38:	20001e68 	.word	0x20001e68
 8008d3c:	0800b760 	.word	0x0800b760

08008d40 <test_002_004_execute.lto_priv.183>:
 * - [2.4.3] Raising thread priority above the boosted level.
 * - [2.4.4] Restoring original conditions.
 * .
 */

static void test_002_004_execute(void) {
 8008d40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008d44:	4d37      	ldr	r5, [pc, #220]	; (8008e24 <test_002_004_execute.lto_priv.183+0xe4>)
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8008d46:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 8008e3c <test_002_004_execute.lto_priv.183+0xfc>
 8008d4a:	69ab      	ldr	r3, [r5, #24]
  return chThdGetSelfX()->prio;
 8008d4c:	689c      	ldr	r4, [r3, #8]
    chThdGetSelfX()->prio += 2;
 8008d4e:	1ca6      	adds	r6, r4, #2
  {
    p1 = chThdSetPriority(prio + 1);
 8008d50:	1c67      	adds	r7, r4, #1
    chThdGetSelfX()->prio += 2;
 8008d52:	609e      	str	r6, [r3, #8]
    p1 = chThdSetPriority(prio + 1);
 8008d54:	4638      	mov	r0, r7
  test_set_step(2);
 8008d56:	2302      	movs	r3, #2
 8008d58:	f8c8 3000 	str.w	r3, [r8]
    p1 = chThdSetPriority(prio + 1);
 8008d5c:	f7f8 fd88 	bl	8001870 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8008d60:	1b00      	subs	r0, r0, r4
 8008d62:	fab0 f080 	clz	r0, r0
 8008d66:	4930      	ldr	r1, [pc, #192]	; (8008e28 <test_002_004_execute.lto_priv.183+0xe8>)
 8008d68:	0940      	lsrs	r0, r0, #5
 8008d6a:	f000 fd31 	bl	80097d0 <_test_assert>
 8008d6e:	b108      	cbz	r0, 8008d74 <test_002_004_execute.lto_priv.183+0x34>
 8008d70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 8008d74:	69ab      	ldr	r3, [r5, #24]
 8008d76:	492d      	ldr	r1, [pc, #180]	; (8008e2c <test_002_004_execute.lto_priv.183+0xec>)
 8008d78:	6898      	ldr	r0, [r3, #8]
 8008d7a:	1b80      	subs	r0, r0, r6
 8008d7c:	fab0 f080 	clz	r0, r0
 8008d80:	0940      	lsrs	r0, r0, #5
 8008d82:	f000 fd25 	bl	80097d0 <_test_assert>
 8008d86:	2800      	cmp	r0, #0
 8008d88:	d1f2      	bne.n	8008d70 <test_002_004_execute.lto_priv.183+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 8008d8a:	69ab      	ldr	r3, [r5, #24]
 8008d8c:	4928      	ldr	r1, [pc, #160]	; (8008e30 <test_002_004_execute.lto_priv.183+0xf0>)
 8008d8e:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8008d90:	1bc0      	subs	r0, r0, r7
 8008d92:	fab0 f080 	clz	r0, r0
 8008d96:	0940      	lsrs	r0, r0, #5
 8008d98:	f000 fd1a 	bl	80097d0 <_test_assert>
 8008d9c:	2800      	cmp	r0, #0
 8008d9e:	d1e7      	bne.n	8008d70 <test_002_004_execute.lto_priv.183+0x30>
  }

  /* [2.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
  {
    p1 = chThdSetPriority(prio + 3);
 8008da0:	1ce6      	adds	r6, r4, #3
  test_set_step(3);
 8008da2:	2303      	movs	r3, #3
    p1 = chThdSetPriority(prio + 3);
 8008da4:	4630      	mov	r0, r6
  test_set_step(3);
 8008da6:	f8c8 3000 	str.w	r3, [r8]
    p1 = chThdSetPriority(prio + 3);
 8008daa:	f7f8 fd61 	bl	8001870 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8008dae:	1a38      	subs	r0, r7, r0
 8008db0:	fab0 f080 	clz	r0, r0
 8008db4:	491c      	ldr	r1, [pc, #112]	; (8008e28 <test_002_004_execute.lto_priv.183+0xe8>)
 8008db6:	0940      	lsrs	r0, r0, #5
 8008db8:	f000 fd0a 	bl	80097d0 <_test_assert>
 8008dbc:	2800      	cmp	r0, #0
 8008dbe:	d1d7      	bne.n	8008d70 <test_002_004_execute.lto_priv.183+0x30>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 8008dc0:	69ab      	ldr	r3, [r5, #24]
 8008dc2:	491a      	ldr	r1, [pc, #104]	; (8008e2c <test_002_004_execute.lto_priv.183+0xec>)
 8008dc4:	6898      	ldr	r0, [r3, #8]
 8008dc6:	1b80      	subs	r0, r0, r6
 8008dc8:	fab0 f080 	clz	r0, r0
 8008dcc:	0940      	lsrs	r0, r0, #5
 8008dce:	f000 fcff 	bl	80097d0 <_test_assert>
 8008dd2:	2800      	cmp	r0, #0
 8008dd4:	d1cc      	bne.n	8008d70 <test_002_004_execute.lto_priv.183+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8008dd6:	69ab      	ldr	r3, [r5, #24]
 8008dd8:	4916      	ldr	r1, [pc, #88]	; (8008e34 <test_002_004_execute.lto_priv.183+0xf4>)
 8008dda:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8008ddc:	1b80      	subs	r0, r0, r6
 8008dde:	fab0 f080 	clz	r0, r0
 8008de2:	0940      	lsrs	r0, r0, #5
 8008de4:	f000 fcf4 	bl	80097d0 <_test_assert>
 8008de8:	2800      	cmp	r0, #0
 8008dea:	d1c1      	bne.n	8008d70 <test_002_004_execute.lto_priv.183+0x30>
  }

  /* [2.4.4] Restoring original conditions.*/
  test_set_step(4);
 8008dec:	2304      	movs	r3, #4
 8008dee:	f8c8 3000 	str.w	r3, [r8]
 8008df2:	2320      	movs	r3, #32
 8008df4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008df8:	f7f8 fa32 	bl	8001260 <_dbg_check_lock>
  return ch.rlist.current;
 8008dfc:	69ab      	ldr	r3, [r5, #24]
  {
    chSysLock();
    chThdGetSelfX()->prio = prio;
 8008dfe:	609c      	str	r4, [r3, #8]
    chThdGetSelfX()->realprio = prio;
 8008e00:	63dc      	str	r4, [r3, #60]	; 0x3c
  _dbg_check_unlock();
 8008e02:	f7f8 fa05 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008e06:	682b      	ldr	r3, [r5, #0]
 8008e08:	42ab      	cmp	r3, r5
 8008e0a:	d004      	beq.n	8008e16 <test_002_004_execute.lto_priv.183+0xd6>
 8008e0c:	69aa      	ldr	r2, [r5, #24]
 8008e0e:	689b      	ldr	r3, [r3, #8]
 8008e10:	6892      	ldr	r2, [r2, #8]
 8008e12:	429a      	cmp	r2, r3
 8008e14:	d303      	bcc.n	8008e1e <test_002_004_execute.lto_priv.183+0xde>
 8008e16:	2300      	movs	r3, #0
 8008e18:	f383 8811 	msr	BASEPRI, r3
 8008e1c:	e7a8      	b.n	8008d70 <test_002_004_execute.lto_priv.183+0x30>
 8008e1e:	4806      	ldr	r0, [pc, #24]	; (8008e38 <test_002_004_execute.lto_priv.183+0xf8>)
 8008e20:	f7f7 fcfe 	bl	8000820 <chSysHalt>
 8008e24:	20001e68 	.word	0x20001e68
 8008e28:	0800b81c 	.word	0x0800b81c
 8008e2c:	0800b840 	.word	0x0800b840
 8008e30:	0800b85c 	.word	0x0800b85c
 8008e34:	0800b884 	.word	0x0800b884
 8008e38:	0800b754 	.word	0x0800b754
 8008e3c:	20001df8 	.word	0x20001df8

08008e40 <test_002_001_execute.lto_priv.180>:
static void test_002_001_execute(void) {
 8008e40:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8008e42:	4e34      	ldr	r6, [pc, #208]	; (8008f14 <test_002_001_execute.lto_priv.180+0xd4>)
 8008e44:	2301      	movs	r3, #1
 8008e46:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8008e4a:	6033      	str	r3, [r6, #0]
 8008e4c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleep(100);
 8008e4e:	2064      	movs	r0, #100	; 0x64
 8008e50:	f7f8 fce6 	bl	8001820 <chThdSleep>
    test_assert_time_window(time + 100,
 8008e54:	f104 0167 	add.w	r1, r4, #103	; 0x67
 8008e58:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8008e5c:	f7f8 ffd8 	bl	8001e10 <_test_assert_time_window.constprop.3>
 8008e60:	b100      	cbz	r0, 8008e64 <test_002_001_execute.lto_priv.180+0x24>
 8008e62:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(2);
 8008e64:	2302      	movs	r3, #2
 8008e66:	6033      	str	r3, [r6, #0]
 8008e68:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepMicroseconds(100000);
 8008e6a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008e6e:	f7f8 fcd7 	bl	8001820 <chThdSleep>
    test_assert_time_window(time + US2ST(100000),
 8008e72:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 8008e76:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 8008e7a:	f7f8 ffc9 	bl	8001e10 <_test_assert_time_window.constprop.3>
 8008e7e:	2800      	cmp	r0, #0
 8008e80:	d1ef      	bne.n	8008e62 <test_002_001_execute.lto_priv.180+0x22>
  test_set_step(3);
 8008e82:	2303      	movs	r3, #3
 8008e84:	6033      	str	r3, [r6, #0]
 8008e86:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepMilliseconds(100);
 8008e88:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008e8c:	f7f8 fcc8 	bl	8001820 <chThdSleep>
    test_assert_time_window(time + MS2ST(100),
 8008e90:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 8008e94:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 8008e98:	f7f8 ffba 	bl	8001e10 <_test_assert_time_window.constprop.3>
 8008e9c:	2800      	cmp	r0, #0
 8008e9e:	d1e0      	bne.n	8008e62 <test_002_001_execute.lto_priv.180+0x22>
  test_set_step(4);
 8008ea0:	2304      	movs	r3, #4
 8008ea2:	6033      	str	r3, [r6, #0]
 8008ea4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
    chThdSleepSeconds(1);
 8008ea6:	f242 7010 	movw	r0, #10000	; 0x2710
 8008eaa:	f7f8 fcb9 	bl	8001820 <chThdSleep>
    test_assert_time_window(time + S2ST(1),
 8008eae:	f504 511c 	add.w	r1, r4, #9984	; 0x2700
 8008eb2:	4608      	mov	r0, r1
 8008eb4:	3010      	adds	r0, #16
 8008eb6:	3113      	adds	r1, #19
 8008eb8:	f7f8 ffaa 	bl	8001e10 <_test_assert_time_window.constprop.3>
 8008ebc:	2800      	cmp	r0, #0
 8008ebe:	d1d0      	bne.n	8008e62 <test_002_001_execute.lto_priv.180+0x22>
  test_set_step(5);
 8008ec0:	2305      	movs	r3, #5
 8008ec2:	6033      	str	r3, [r6, #0]
 8008ec4:	6a6e      	ldr	r6, [r5, #36]	; 0x24
 8008ec6:	2320      	movs	r3, #32
    chThdSleepUntil(time + 100);
 8008ec8:	f106 0464 	add.w	r4, r6, #100	; 0x64
 8008ecc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008ed0:	f7f8 f9c6 	bl	8001260 <_dbg_check_lock>
 8008ed4:	6a69      	ldr	r1, [r5, #36]	; 0x24
  if (time > (systime_t)0) {
 8008ed6:	1a61      	subs	r1, r4, r1
 8008ed8:	d117      	bne.n	8008f0a <test_002_001_execute.lto_priv.180+0xca>
  _dbg_check_unlock();
 8008eda:	f7f8 f999 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008ede:	4b0e      	ldr	r3, [pc, #56]	; (8008f18 <test_002_001_execute.lto_priv.180+0xd8>)
 8008ee0:	681a      	ldr	r2, [r3, #0]
 8008ee2:	429a      	cmp	r2, r3
 8008ee4:	d004      	beq.n	8008ef0 <test_002_001_execute.lto_priv.180+0xb0>
 8008ee6:	6999      	ldr	r1, [r3, #24]
 8008ee8:	6893      	ldr	r3, [r2, #8]
 8008eea:	688a      	ldr	r2, [r1, #8]
 8008eec:	429a      	cmp	r2, r3
 8008eee:	d309      	bcc.n	8008f04 <test_002_001_execute.lto_priv.180+0xc4>
 8008ef0:	2300      	movs	r3, #0
 8008ef2:	f383 8811 	msr	BASEPRI, r3
    test_assert_time_window(time + 100,
 8008ef6:	f106 0167 	add.w	r1, r6, #103	; 0x67
 8008efa:	4620      	mov	r0, r4
}
 8008efc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert_time_window(time + 100,
 8008f00:	f7f8 bf86 	b.w	8001e10 <_test_assert_time_window.constprop.3>
 8008f04:	4805      	ldr	r0, [pc, #20]	; (8008f1c <test_002_001_execute.lto_priv.180+0xdc>)
 8008f06:	f7f7 fc8b 	bl	8000820 <chSysHalt>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8008f0a:	2008      	movs	r0, #8
 8008f0c:	f7f8 f810 	bl	8000f30 <chSchGoSleepTimeoutS>
 8008f10:	e7e3      	b.n	8008eda <test_002_001_execute.lto_priv.180+0x9a>
 8008f12:	bf00      	nop
 8008f14:	20001df8 	.word	0x20001df8
 8008f18:	20001e68 	.word	0x20001e68
 8008f1c:	0800c508 	.word	0x0800c508

08008f20 <test_001_002_execute.lto_priv.177>:
static void test_001_002_execute(void) {
 8008f20:	b530      	push	{r4, r5, lr}
  test_set_step(1);
 8008f22:	4d60      	ldr	r5, [pc, #384]	; (80090a4 <test_001_002_execute.lto_priv.177+0x184>)
 8008f24:	2301      	movs	r3, #1
static void test_001_002_execute(void) {
 8008f26:	b087      	sub	sp, #28
  test_set_step(1);
 8008f28:	602b      	str	r3, [r5, #0]
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008f2a:	f3ef 8311 	mrs	r3, BASEPRI
 8008f2e:	b91b      	cbnz	r3, 8008f38 <test_001_002_execute.lto_priv.177+0x18>
 8008f30:	f7f8 fde6 	bl	8001b00 <chSysGetStatusAndLockX.part.1>
 8008f34:	f7f8 fe14 	bl	8001b60 <chSysRestoreStatusX.part.2>
  test_set_step(2);
 8008f38:	2302      	movs	r3, #2
 8008f3a:	602b      	str	r3, [r5, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008f3c:	2320      	movs	r3, #32
 8008f3e:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008f42:	f7f8 f98d 	bl	8001260 <_dbg_check_lock>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008f46:	f3ef 8311 	mrs	r3, BASEPRI
 8008f4a:	b91b      	cbnz	r3, 8008f54 <test_001_002_execute.lto_priv.177+0x34>
 8008f4c:	f7f8 fdd8 	bl	8001b00 <chSysGetStatusAndLockX.part.1>
 8008f50:	f7f8 fe06 	bl	8001b60 <chSysRestoreStatusX.part.2>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008f54:	4c54      	ldr	r4, [pc, #336]	; (80090a8 <test_001_002_execute.lto_priv.177+0x188>)
  _dbg_check_unlock();
 8008f56:	f7f8 f95b 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008f5a:	6823      	ldr	r3, [r4, #0]
 8008f5c:	42a3      	cmp	r3, r4
 8008f5e:	d004      	beq.n	8008f6a <test_001_002_execute.lto_priv.177+0x4a>
 8008f60:	69a2      	ldr	r2, [r4, #24]
 8008f62:	689b      	ldr	r3, [r3, #8]
 8008f64:	6892      	ldr	r2, [r2, #8]
 8008f66:	429a      	cmp	r2, r3
 8008f68:	d36c      	bcc.n	8009044 <test_001_002_execute.lto_priv.177+0x124>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008f6a:	2300      	movs	r3, #0
 8008f6c:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 8008f70:	2303      	movs	r3, #3
 8008f72:	602b      	str	r3, [r5, #0]
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008f74:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8008f78:	2b00      	cmp	r3, #0
 8008f7a:	d06c      	beq.n	8009056 <test_001_002_execute.lto_priv.177+0x136>
 8008f7c:	f3ef 8311 	mrs	r3, BASEPRI
 8008f80:	2b00      	cmp	r3, #0
 8008f82:	d062      	beq.n	800904a <test_001_002_execute.lto_priv.177+0x12a>
  _dbg_check_unlock();
 8008f84:	f7f8 f944 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008f88:	6823      	ldr	r3, [r4, #0]
 8008f8a:	42a3      	cmp	r3, r4
 8008f8c:	d004      	beq.n	8008f98 <test_001_002_execute.lto_priv.177+0x78>
 8008f8e:	69a2      	ldr	r2, [r4, #24]
 8008f90:	689b      	ldr	r3, [r3, #8]
 8008f92:	6892      	ldr	r2, [r2, #8]
 8008f94:	429a      	cmp	r2, r3
 8008f96:	d355      	bcc.n	8009044 <test_001_002_execute.lto_priv.177+0x124>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008f98:	2300      	movs	r3, #0
 8008f9a:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
 8008f9e:	2304      	movs	r3, #4
 8008fa0:	602b      	str	r3, [r5, #0]
 8008fa2:	2320      	movs	r3, #32
 8008fa4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008fa8:	f7f8 f95a 	bl	8001260 <_dbg_check_lock>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008fac:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 8008fb0:	2b00      	cmp	r3, #0
 8008fb2:	d168      	bne.n	8009086 <test_001_002_execute.lto_priv.177+0x166>
 8008fb4:	f3ef 8311 	mrs	r3, BASEPRI
 8008fb8:	2b00      	cmp	r3, #0
 8008fba:	d156      	bne.n	800906a <test_001_002_execute.lto_priv.177+0x14a>
  test_set_step(5);
 8008fbc:	2205      	movs	r2, #5
  vtp->func = NULL;
 8008fbe:	2300      	movs	r3, #0
 8008fc0:	9304      	str	r3, [sp, #16]
 8008fc2:	602a      	str	r2, [r5, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008fc4:	2320      	movs	r3, #32
 8008fc6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8008fca:	f7f8 f949 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8008fce:	f7f7 fc77 	bl	80008c0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8008fd2:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8008fd4:	ad01      	add	r5, sp, #4
  if (chVTIsArmedI(vtp)) {
 8008fd6:	b113      	cbz	r3, 8008fde <test_001_002_execute.lto_priv.177+0xbe>
    chVTDoResetI(vtp);
 8008fd8:	4628      	mov	r0, r5
 8008fda:	f7f7 fef9 	bl	8000dd0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8008fde:	2300      	movs	r3, #0
 8008fe0:	4628      	mov	r0, r5
 8008fe2:	4a32      	ldr	r2, [pc, #200]	; (80090ac <test_001_002_execute.lto_priv.177+0x18c>)
 8008fe4:	2101      	movs	r1, #1
 8008fe6:	f7f7 ff3b 	bl	8000e60 <chVTDoSetI>
  _dbg_check_unlock();
 8008fea:	f7f8 f911 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8008fee:	6823      	ldr	r3, [r4, #0]
 8008ff0:	42a3      	cmp	r3, r4
 8008ff2:	d004      	beq.n	8008ffe <test_001_002_execute.lto_priv.177+0xde>
 8008ff4:	69a2      	ldr	r2, [r4, #24]
 8008ff6:	689b      	ldr	r3, [r3, #8]
 8008ff8:	6892      	ldr	r2, [r2, #8]
 8008ffa:	429a      	cmp	r2, r3
 8008ffc:	d322      	bcc.n	8009044 <test_001_002_execute.lto_priv.177+0x124>
 8008ffe:	2300      	movs	r3, #0
 8009000:	f383 8811 	msr	BASEPRI, r3
    chThdSleep(10);
 8009004:	200a      	movs	r0, #10
 8009006:	f7f8 fc0b 	bl	8001820 <chThdSleep>
 800900a:	2320      	movs	r3, #32
 800900c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009010:	f7f8 f926 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassI();
 8009014:	f7f7 fc54 	bl	80008c0 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
 8009018:	9d04      	ldr	r5, [sp, #16]
  _dbg_check_unlock();
 800901a:	f7f8 f8f9 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800901e:	6823      	ldr	r3, [r4, #0]
 8009020:	42a3      	cmp	r3, r4
 8009022:	d004      	beq.n	800902e <test_001_002_execute.lto_priv.177+0x10e>
 8009024:	69a2      	ldr	r2, [r4, #24]
 8009026:	689b      	ldr	r3, [r3, #8]
 8009028:	6892      	ldr	r2, [r2, #8]
 800902a:	429a      	cmp	r2, r3
 800902c:	d30a      	bcc.n	8009044 <test_001_002_execute.lto_priv.177+0x124>
 800902e:	2300      	movs	r3, #0
 8009030:	f383 8811 	msr	BASEPRI, r3
    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 8009034:	fab5 f085 	clz	r0, r5
 8009038:	491d      	ldr	r1, [pc, #116]	; (80090b0 <test_001_002_execute.lto_priv.177+0x190>)
 800903a:	0940      	lsrs	r0, r0, #5
 800903c:	f000 fbc8 	bl	80097d0 <_test_assert>
}
 8009040:	b007      	add	sp, #28
 8009042:	bd30      	pop	{r4, r5, pc}
 8009044:	481b      	ldr	r0, [pc, #108]	; (80090b4 <test_001_002_execute.lto_priv.177+0x194>)
 8009046:	f7f7 fbeb 	bl	8000820 <chSysHalt>
 800904a:	2320      	movs	r3, #32
 800904c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009050:	f7f8 f906 	bl	8001260 <_dbg_check_lock>
 8009054:	e796      	b.n	8008f84 <test_001_002_execute.lto_priv.177+0x64>
 8009056:	2320      	movs	r3, #32
 8009058:	f383 8811 	msr	BASEPRI, r3
 800905c:	f7f8 f900 	bl	8001260 <_dbg_check_lock>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009060:	f3ef 8311 	mrs	r3, BASEPRI
  if (port_irq_enabled(port_get_irq_status())) {
 8009064:	2b00      	cmp	r3, #0
 8009066:	d18d      	bne.n	8008f84 <test_001_002_execute.lto_priv.177+0x64>
 8009068:	e7ef      	b.n	800904a <test_001_002_execute.lto_priv.177+0x12a>
  _dbg_check_unlock();
 800906a:	f7f8 f8d1 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800906e:	6823      	ldr	r3, [r4, #0]
 8009070:	42a3      	cmp	r3, r4
 8009072:	d004      	beq.n	800907e <test_001_002_execute.lto_priv.177+0x15e>
 8009074:	69a2      	ldr	r2, [r4, #24]
 8009076:	689b      	ldr	r3, [r3, #8]
 8009078:	6892      	ldr	r2, [r2, #8]
 800907a:	429a      	cmp	r2, r3
 800907c:	d3e2      	bcc.n	8009044 <test_001_002_execute.lto_priv.177+0x124>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800907e:	2300      	movs	r3, #0
 8009080:	f383 8811 	msr	BASEPRI, r3
 8009084:	e79a      	b.n	8008fbc <test_001_002_execute.lto_priv.177+0x9c>
  _dbg_check_unlock();
 8009086:	f7f8 f8c3 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800908a:	6823      	ldr	r3, [r4, #0]
 800908c:	42a3      	cmp	r3, r4
 800908e:	d004      	beq.n	800909a <test_001_002_execute.lto_priv.177+0x17a>
 8009090:	69a2      	ldr	r2, [r4, #24]
 8009092:	689b      	ldr	r3, [r3, #8]
 8009094:	6892      	ldr	r2, [r2, #8]
 8009096:	429a      	cmp	r2, r3
 8009098:	d3d4      	bcc.n	8009044 <test_001_002_execute.lto_priv.177+0x124>
 800909a:	2300      	movs	r3, #0
 800909c:	f383 8811 	msr	BASEPRI, r3
 80090a0:	e788      	b.n	8008fb4 <test_001_002_execute.lto_priv.177+0x94>
 80090a2:	bf00      	nop
 80090a4:	20001df8 	.word	0x20001df8
 80090a8:	20001e68 	.word	0x20001e68
 80090ac:	08008961 	.word	0x08008961
 80090b0:	0800b800 	.word	0x0800b800
 80090b4:	0800b748 	.word	0x0800b748
	...

080090c0 <test_001_001_execute.lto_priv.176>:
static void test_001_001_execute(void) {
 80090c0:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 80090c2:	4e42      	ldr	r6, [pc, #264]	; (80091cc <test_001_001_execute.lto_priv.176+0x10c>)
 80090c4:	2501      	movs	r5, #1
 80090c6:	6035      	str	r5, [r6, #0]
 80090c8:	2320      	movs	r3, #32
 80090ca:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80090ce:	f7f8 f8c7 	bl	8001260 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 80090d2:	4628      	mov	r0, r5
 80090d4:	f7f7 ffa4 	bl	8001020 <chSysIntegrityCheckI>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80090d8:	4c3d      	ldr	r4, [pc, #244]	; (80091d0 <test_001_001_execute.lto_priv.176+0x110>)
 80090da:	4605      	mov	r5, r0
  _dbg_check_unlock();
 80090dc:	f7f8 f898 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80090e0:	6823      	ldr	r3, [r4, #0]
 80090e2:	42a3      	cmp	r3, r4
 80090e4:	d004      	beq.n	80090f0 <test_001_001_execute.lto_priv.176+0x30>
 80090e6:	69a2      	ldr	r2, [r4, #24]
 80090e8:	689b      	ldr	r3, [r3, #8]
 80090ea:	6892      	ldr	r2, [r2, #8]
 80090ec:	429a      	cmp	r2, r3
 80090ee:	d36a      	bcc.n	80091c6 <test_001_001_execute.lto_priv.176+0x106>
 80090f0:	2300      	movs	r3, #0
 80090f2:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "ready list check failed");
 80090f6:	f085 0001 	eor.w	r0, r5, #1
 80090fa:	b2c0      	uxtb	r0, r0
 80090fc:	4935      	ldr	r1, [pc, #212]	; (80091d4 <test_001_001_execute.lto_priv.176+0x114>)
 80090fe:	f000 fb67 	bl	80097d0 <_test_assert>
 8009102:	b100      	cbz	r0, 8009106 <test_001_001_execute.lto_priv.176+0x46>
 8009104:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(2);
 8009106:	2502      	movs	r5, #2
 8009108:	6035      	str	r5, [r6, #0]
 800910a:	2320      	movs	r3, #32
 800910c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009110:	f7f8 f8a6 	bl	8001260 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8009114:	4628      	mov	r0, r5
 8009116:	f7f7 ff83 	bl	8001020 <chSysIntegrityCheckI>
 800911a:	4605      	mov	r5, r0
  _dbg_check_unlock();
 800911c:	f7f8 f878 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009120:	6823      	ldr	r3, [r4, #0]
 8009122:	42a3      	cmp	r3, r4
 8009124:	d004      	beq.n	8009130 <test_001_001_execute.lto_priv.176+0x70>
 8009126:	69a2      	ldr	r2, [r4, #24]
 8009128:	689b      	ldr	r3, [r3, #8]
 800912a:	6892      	ldr	r2, [r2, #8]
 800912c:	429a      	cmp	r2, r3
 800912e:	d34a      	bcc.n	80091c6 <test_001_001_execute.lto_priv.176+0x106>
 8009130:	2300      	movs	r3, #0
 8009132:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "virtual timers list check failed");
 8009136:	f085 0001 	eor.w	r0, r5, #1
 800913a:	b2c0      	uxtb	r0, r0
 800913c:	4926      	ldr	r1, [pc, #152]	; (80091d8 <test_001_001_execute.lto_priv.176+0x118>)
 800913e:	f000 fb47 	bl	80097d0 <_test_assert>
 8009142:	2800      	cmp	r0, #0
 8009144:	d1de      	bne.n	8009104 <test_001_001_execute.lto_priv.176+0x44>
  test_set_step(3);
 8009146:	2303      	movs	r3, #3
 8009148:	6033      	str	r3, [r6, #0]
 800914a:	2320      	movs	r3, #32
 800914c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009150:	f7f8 f886 	bl	8001260 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8009154:	2004      	movs	r0, #4
 8009156:	f7f7 ff63 	bl	8001020 <chSysIntegrityCheckI>
 800915a:	4605      	mov	r5, r0
  _dbg_check_unlock();
 800915c:	f7f8 f858 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009160:	6823      	ldr	r3, [r4, #0]
 8009162:	42a3      	cmp	r3, r4
 8009164:	d004      	beq.n	8009170 <test_001_001_execute.lto_priv.176+0xb0>
 8009166:	69a2      	ldr	r2, [r4, #24]
 8009168:	689b      	ldr	r3, [r3, #8]
 800916a:	6892      	ldr	r2, [r2, #8]
 800916c:	429a      	cmp	r2, r3
 800916e:	d32a      	bcc.n	80091c6 <test_001_001_execute.lto_priv.176+0x106>
 8009170:	2300      	movs	r3, #0
 8009172:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "registry list check failed");
 8009176:	f085 0001 	eor.w	r0, r5, #1
 800917a:	b2c0      	uxtb	r0, r0
 800917c:	4917      	ldr	r1, [pc, #92]	; (80091dc <test_001_001_execute.lto_priv.176+0x11c>)
 800917e:	f000 fb27 	bl	80097d0 <_test_assert>
 8009182:	2800      	cmp	r0, #0
 8009184:	d1be      	bne.n	8009104 <test_001_001_execute.lto_priv.176+0x44>
  test_set_step(4);
 8009186:	2304      	movs	r3, #4
 8009188:	6033      	str	r3, [r6, #0]
 800918a:	2320      	movs	r3, #32
 800918c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009190:	f7f8 f866 	bl	8001260 <_dbg_check_lock>
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8009194:	2008      	movs	r0, #8
 8009196:	f7f7 ff43 	bl	8001020 <chSysIntegrityCheckI>
 800919a:	4605      	mov	r5, r0
  _dbg_check_unlock();
 800919c:	f7f8 f838 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80091a0:	6823      	ldr	r3, [r4, #0]
 80091a2:	42a3      	cmp	r3, r4
 80091a4:	d004      	beq.n	80091b0 <test_001_001_execute.lto_priv.176+0xf0>
 80091a6:	69a2      	ldr	r2, [r4, #24]
 80091a8:	689b      	ldr	r3, [r3, #8]
 80091aa:	6892      	ldr	r2, [r2, #8]
 80091ac:	429a      	cmp	r2, r3
 80091ae:	d30a      	bcc.n	80091c6 <test_001_001_execute.lto_priv.176+0x106>
 80091b0:	2300      	movs	r3, #0
 80091b2:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "port layer check failed");
 80091b6:	f085 0001 	eor.w	r0, r5, #1
 80091ba:	b2c0      	uxtb	r0, r0
 80091bc:	4908      	ldr	r1, [pc, #32]	; (80091e0 <test_001_001_execute.lto_priv.176+0x120>)
}
 80091be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert(result == false, "port layer check failed");
 80091c2:	f000 bb05 	b.w	80097d0 <_test_assert>
 80091c6:	4807      	ldr	r0, [pc, #28]	; (80091e4 <test_001_001_execute.lto_priv.176+0x124>)
 80091c8:	f7f7 fb2a 	bl	8000820 <chSysHalt>
 80091cc:	20001df8 	.word	0x20001df8
 80091d0:	20001e68 	.word	0x20001e68
 80091d4:	0800b790 	.word	0x0800b790
 80091d8:	0800b7a8 	.word	0x0800b7a8
 80091dc:	0800b7cc 	.word	0x0800b7cc
 80091e0:	0800b7e8 	.word	0x0800b7e8
 80091e4:	0800b748 	.word	0x0800b748
	...

080091f0 <test_wait_tick>:

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 80091f0:	b510      	push	{r4, lr}

  chThdSleep(1);
 80091f2:	2001      	movs	r0, #1
 80091f4:	f7f8 fb14 	bl	8001820 <chThdSleep>
 80091f8:	2320      	movs	r3, #32
 80091fa:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80091fe:	f7f8 f82f 	bl	8001260 <_dbg_check_lock>
 8009202:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009206:	6a5c      	ldr	r4, [r3, #36]	; 0x24
  _dbg_check_unlock();
 8009208:	f7f8 f802 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800920c:	4b08      	ldr	r3, [pc, #32]	; (8009230 <test_wait_tick+0x40>)
 800920e:	681a      	ldr	r2, [r3, #0]
 8009210:	429a      	cmp	r2, r3
 8009212:	d004      	beq.n	800921e <test_wait_tick+0x2e>
 8009214:	6999      	ldr	r1, [r3, #24]
 8009216:	6893      	ldr	r3, [r2, #8]
 8009218:	688a      	ldr	r2, [r1, #8]
 800921a:	429a      	cmp	r2, r3
 800921c:	d304      	bcc.n	8009228 <test_wait_tick+0x38>
 800921e:	2300      	movs	r3, #0
 8009220:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 8009224:	4620      	mov	r0, r4
 8009226:	bd10      	pop	{r4, pc}
 8009228:	4802      	ldr	r0, [pc, #8]	; (8009234 <test_wait_tick+0x44>)
 800922a:	f7f7 faf9 	bl	8000820 <chSysHalt>
 800922e:	bf00      	nop
 8009230:	20001e68 	.word	0x20001e68
 8009234:	0800b73c 	.word	0x0800b73c
	...

08009240 <test_terminate_threads>:
void test_terminate_threads(void) {
 8009240:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8009244:	4c13      	ldr	r4, [pc, #76]	; (8009294 <test_terminate_threads+0x54>)
 8009246:	4e14      	ldr	r6, [pc, #80]	; (8009298 <test_terminate_threads+0x58>)
 8009248:	f104 0714 	add.w	r7, r4, #20
 800924c:	f04f 0820 	mov.w	r8, #32
 8009250:	f04f 0900 	mov.w	r9, #0
    if (threads[i])
 8009254:	f854 5b04 	ldr.w	r5, [r4], #4
 8009258:	b1ad      	cbz	r5, 8009286 <test_terminate_threads+0x46>
 800925a:	f388 8811 	msr	BASEPRI, r8
  _dbg_check_lock();
 800925e:	f7f7 ffff 	bl	8001260 <_dbg_check_lock>
  tp->flags |= CH_FLAG_TERMINATE;
 8009262:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
 8009266:	f043 0304 	orr.w	r3, r3, #4
 800926a:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
  _dbg_check_unlock();
 800926e:	f7f7 ffcf 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009272:	6833      	ldr	r3, [r6, #0]
 8009274:	42b3      	cmp	r3, r6
 8009276:	d004      	beq.n	8009282 <test_terminate_threads+0x42>
 8009278:	69b2      	ldr	r2, [r6, #24]
 800927a:	689b      	ldr	r3, [r3, #8]
 800927c:	6892      	ldr	r2, [r2, #8]
 800927e:	429a      	cmp	r2, r3
 8009280:	d305      	bcc.n	800928e <test_terminate_threads+0x4e>
 8009282:	f389 8811 	msr	BASEPRI, r9
  for (i = 0; i < MAX_THREADS; i++)
 8009286:	42bc      	cmp	r4, r7
 8009288:	d1e4      	bne.n	8009254 <test_terminate_threads+0x14>
}
 800928a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800928e:	4803      	ldr	r0, [pc, #12]	; (800929c <test_terminate_threads+0x5c>)
 8009290:	f7f7 fac6 	bl	8000820 <chSysHalt>
 8009294:	20001d98 	.word	0x20001d98
 8009298:	20001e68 	.word	0x20001e68
 800929c:	0800c508 	.word	0x0800c508

080092a0 <print_line>:
static void print_line(void) {
 80092a0:	b570      	push	{r4, r5, r6, lr}
 80092a2:	4d08      	ldr	r5, [pc, #32]	; (80092c4 <print_line+0x24>)
 80092a4:	244c      	movs	r4, #76	; 0x4c
    streamPut(test_chp, '-');
 80092a6:	6828      	ldr	r0, [r5, #0]
 80092a8:	6803      	ldr	r3, [r0, #0]
 80092aa:	212d      	movs	r1, #45	; 0x2d
 80092ac:	689b      	ldr	r3, [r3, #8]
 80092ae:	4798      	blx	r3
  for (i = 0; i < 76; i++)
 80092b0:	3c01      	subs	r4, #1
 80092b2:	d1f8      	bne.n	80092a6 <print_line+0x6>
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 80092b4:	6828      	ldr	r0, [r5, #0]
 80092b6:	4904      	ldr	r1, [pc, #16]	; (80092c8 <print_line+0x28>)
 80092b8:	6803      	ldr	r3, [r0, #0]
 80092ba:	2202      	movs	r2, #2
 80092bc:	681b      	ldr	r3, [r3, #0]
}
 80092be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 80092c2:	4718      	bx	r3
 80092c4:	20001e50 	.word	0x20001e50
 80092c8:	0800a8dc 	.word	0x0800a8dc
 80092cc:	00000000 	.word	0x00000000

080092d0 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80092d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80092d4:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
  OSAL_IRQ_PROLOGUE();
 80092d8:	482f      	ldr	r0, [pc, #188]	; (8009398 <VectorB0+0xc8>)
 80092da:	f7f7 fa71 	bl	80007c0 <_trace_isr_enter>
 80092de:	f7f7 ff17 	bl	8001110 <_dbg_check_enter_isr>
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80092e2:	693b      	ldr	r3, [r7, #16]
 80092e4:	079b      	lsls	r3, r3, #30
 80092e6:	d408      	bmi.n	80092fa <VectorB0+0x2a>
  OSAL_IRQ_EPILOGUE();
 80092e8:	f7f7 fefa 	bl	80010e0 <_dbg_check_leave_isr>
 80092ec:	482a      	ldr	r0, [pc, #168]	; (8009398 <VectorB0+0xc8>)
 80092ee:	f7f7 fa47 	bl	8000780 <_trace_isr_leave>
}
 80092f2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 80092f6:	f7fb b9fb 	b.w	80046f0 <_port_irq_epilogue>
    STM32_ST_TIM->SR = 0U;
 80092fa:	2600      	movs	r6, #0
 80092fc:	613e      	str	r6, [r7, #16]
 80092fe:	f04f 0820 	mov.w	r8, #32
 8009302:	f388 8811 	msr	BASEPRI, r8
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8009306:	4d25      	ldr	r5, [pc, #148]	; (800939c <VectorB0+0xcc>)
  _dbg_check_lock_from_isr();
 8009308:	f7f7 ff32 	bl	8001170 <_dbg_check_lock_from_isr>
  chDbgCheckClassI();
 800930c:	f7f7 fad8 	bl	80008c0 <chDbgCheckClassI>
  chDbgCheckClassI();
 8009310:	f7f7 fad6 	bl	80008c0 <chDbgCheckClassI>
  vtp = ch.vtlist.next;
 8009314:	69ec      	ldr	r4, [r5, #28]
 8009316:	6a78      	ldr	r0, [r7, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8009318:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800931a:	68a1      	ldr	r1, [r4, #8]
 800931c:	1ac2      	subs	r2, r0, r3
 800931e:	428a      	cmp	r2, r1
 8009320:	f105 091c 	add.w	r9, r5, #28
 8009324:	d31c      	bcc.n	8009360 <VectorB0+0x90>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8009326:	6822      	ldr	r2, [r4, #0]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 8009328:	f8d4 a00c 	ldr.w	sl, [r4, #12]
    ch.vtlist.lasttime += vtp->delta;
 800932c:	440b      	add	r3, r1
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800932e:	454a      	cmp	r2, r9
    ch.vtlist.lasttime += vtp->delta;
 8009330:	62ab      	str	r3, [r5, #40]	; 0x28
    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8009332:	f8c2 9004 	str.w	r9, [r2, #4]
    ch.vtlist.next = vtp->next;
 8009336:	61ea      	str	r2, [r5, #28]
    vtp->func = NULL;
 8009338:	60e6      	str	r6, [r4, #12]
  STM32_ST_TIM->DIER = 0;
 800933a:	bf08      	it	eq
 800933c:	60fe      	streq	r6, [r7, #12]
  _dbg_check_unlock_from_isr();
 800933e:	f7f7 feff 	bl	8001140 <_dbg_check_unlock_from_isr>
 8009342:	f386 8811 	msr	BASEPRI, r6
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8009346:	6920      	ldr	r0, [r4, #16]
 8009348:	47d0      	blx	sl
 800934a:	f388 8811 	msr	BASEPRI, r8
  _dbg_check_lock_from_isr();
 800934e:	f7f7 ff0f 	bl	8001170 <_dbg_check_lock_from_isr>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8009352:	69ec      	ldr	r4, [r5, #28]
  return (systime_t)STM32_ST_TIM->CNT;
 8009354:	6a78      	ldr	r0, [r7, #36]	; 0x24
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8009356:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8009358:	68a1      	ldr	r1, [r4, #8]
 800935a:	1ac2      	subs	r2, r0, r3
 800935c:	4291      	cmp	r1, r2
 800935e:	d9e2      	bls.n	8009326 <VectorB0+0x56>
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8009360:	454c      	cmp	r4, r9
 8009362:	d010      	beq.n	8009386 <VectorB0+0xb6>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8009364:	440b      	add	r3, r1
 8009366:	1a1b      	subs	r3, r3, r0
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 8009368:	2b02      	cmp	r3, #2
 800936a:	bf2c      	ite	cs
 800936c:	18c4      	addcs	r4, r0, r3
 800936e:	1c84      	addcc	r4, r0, #2
 8009370:	4620      	mov	r0, r4
 8009372:	f7fb f9ad 	bl	80046d0 <stSetAlarm>
 8009376:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 800937a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800937c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800937e:	1a63      	subs	r3, r4, r1
 8009380:	1a52      	subs	r2, r2, r1
 8009382:	429a      	cmp	r2, r3
 8009384:	d805      	bhi.n	8009392 <VectorB0+0xc2>
  _dbg_check_unlock_from_isr();
 8009386:	f7f7 fedb 	bl	8001140 <_dbg_check_unlock_from_isr>
 800938a:	2300      	movs	r3, #0
 800938c:	f383 8811 	msr	BASEPRI, r3
 8009390:	e7aa      	b.n	80092e8 <VectorB0+0x18>
 8009392:	4803      	ldr	r0, [pc, #12]	; (80093a0 <VectorB0+0xd0>)
 8009394:	f7f7 fa44 	bl	8000820 <chSysHalt>
 8009398:	0800b8e4 	.word	0x0800b8e4
 800939c:	20001e68 	.word	0x20001e68
 80093a0:	0800b8bc 	.word	0x0800b8bc
	...

080093b0 <Vector174>:
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 80093b0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80093b2:	4c09      	ldr	r4, [pc, #36]	; (80093d8 <Vector174+0x28>)
 80093b4:	4620      	mov	r0, r4
 80093b6:	f7f7 fa03 	bl	80007c0 <_trace_isr_enter>
 80093ba:	f7f7 fea9 	bl	8001110 <_dbg_check_enter_isr>
  usb_lld_serve_interrupt(&USBD2);
 80093be:	4807      	ldr	r0, [pc, #28]	; (80093dc <Vector174+0x2c>)
 80093c0:	f7fd fafe 	bl	80069c0 <usb_lld_serve_interrupt.lto_priv.260>
  OSAL_IRQ_EPILOGUE();
 80093c4:	f7f7 fe8c 	bl	80010e0 <_dbg_check_leave_isr>
 80093c8:	4620      	mov	r0, r4
 80093ca:	f7f7 f9d9 	bl	8000780 <_trace_isr_leave>
}
 80093ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80093d2:	f7fb b98d 	b.w	80046f0 <_port_irq_epilogue>
 80093d6:	bf00      	nop
 80093d8:	0800b918 	.word	0x0800b918
 80093dc:	200012e8 	.word	0x200012e8

080093e0 <Vector14C>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 80093e0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80093e2:	4c09      	ldr	r4, [pc, #36]	; (8009408 <Vector14C+0x28>)
 80093e4:	4620      	mov	r0, r4
 80093e6:	f7f7 f9eb 	bl	80007c0 <_trace_isr_enter>
 80093ea:	f7f7 fe91 	bl	8001110 <_dbg_check_enter_isr>
  usb_lld_serve_interrupt(&USBD1);
 80093ee:	4807      	ldr	r0, [pc, #28]	; (800940c <Vector14C+0x2c>)
 80093f0:	f7fd fae6 	bl	80069c0 <usb_lld_serve_interrupt.lto_priv.260>
  OSAL_IRQ_EPILOGUE();
 80093f4:	f7f7 fe74 	bl	80010e0 <_dbg_check_leave_isr>
 80093f8:	4620      	mov	r0, r4
 80093fa:	f7f7 f9c1 	bl	8000780 <_trace_isr_leave>
}
 80093fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8009402:	f7fb b975 	b.w	80046f0 <_port_irq_epilogue>
 8009406:	bf00      	nop
 8009408:	0800b90c 	.word	0x0800b90c
 800940c:	20001118 	.word	0x20001118

08009410 <test_println>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8009410:	b570      	push	{r4, r5, r6, lr}
  while (*msgp)
 8009412:	7801      	ldrb	r1, [r0, #0]
 8009414:	b189      	cbz	r1, 800943a <test_println+0x2a>
 8009416:	4d0a      	ldr	r5, [pc, #40]	; (8009440 <test_println+0x30>)
 8009418:	4604      	mov	r4, r0
    streamPut(test_chp, *msgp++);
 800941a:	6828      	ldr	r0, [r5, #0]
 800941c:	6803      	ldr	r3, [r0, #0]
 800941e:	689b      	ldr	r3, [r3, #8]
 8009420:	4798      	blx	r3
  while (*msgp)
 8009422:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8009426:	2900      	cmp	r1, #0
 8009428:	d1f7      	bne.n	800941a <test_println+0xa>

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 800942a:	6828      	ldr	r0, [r5, #0]
 800942c:	4905      	ldr	r1, [pc, #20]	; (8009444 <test_println+0x34>)
 800942e:	6803      	ldr	r3, [r0, #0]
 8009430:	2202      	movs	r2, #2
 8009432:	681b      	ldr	r3, [r3, #0]
}
 8009434:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8009438:	4718      	bx	r3
 800943a:	4d01      	ldr	r5, [pc, #4]	; (8009440 <test_println+0x30>)
 800943c:	e7f5      	b.n	800942a <test_println+0x1a>
 800943e:	bf00      	nop
 8009440:	20001e50 	.word	0x20001e50
 8009444:	0800a8dc 	.word	0x0800a8dc
	...

08009450 <test_print>:
  while (*msgp)
 8009450:	7801      	ldrb	r1, [r0, #0]
 8009452:	b159      	cbz	r1, 800946c <test_print+0x1c>
void test_print(const char *msgp) {
 8009454:	b538      	push	{r3, r4, r5, lr}
 8009456:	4d06      	ldr	r5, [pc, #24]	; (8009470 <test_print+0x20>)
 8009458:	4604      	mov	r4, r0
    streamPut(test_chp, *msgp++);
 800945a:	6828      	ldr	r0, [r5, #0]
 800945c:	6803      	ldr	r3, [r0, #0]
 800945e:	689b      	ldr	r3, [r3, #8]
 8009460:	4798      	blx	r3
  while (*msgp)
 8009462:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8009466:	2900      	cmp	r1, #0
 8009468:	d1f7      	bne.n	800945a <test_print+0xa>
 800946a:	bd38      	pop	{r3, r4, r5, pc}
 800946c:	4770      	bx	lr
 800946e:	bf00      	nop
 8009470:	20001e50 	.word	0x20001e50
	...

08009480 <test_printn>:
  if (!n)
 8009480:	b320      	cbz	r0, 80094cc <test_printn+0x4c>
void test_printn(uint32_t n) {
 8009482:	b570      	push	{r4, r5, r6, lr}
 8009484:	b084      	sub	sp, #16
  if (!n)
 8009486:	466d      	mov	r5, sp
 8009488:	466c      	mov	r4, sp
      *p++ = (n % 10) + '0', n /= 10;
 800948a:	4e13      	ldr	r6, [pc, #76]	; (80094d8 <test_printn+0x58>)
 800948c:	e000      	b.n	8009490 <test_printn+0x10>
    while (n)
 800948e:	4614      	mov	r4, r2
      *p++ = (n % 10) + '0', n /= 10;
 8009490:	fba6 2300 	umull	r2, r3, r6, r0
 8009494:	08db      	lsrs	r3, r3, #3
 8009496:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 800949a:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 800949e:	f100 0130 	add.w	r1, r0, #48	; 0x30
 80094a2:	4622      	mov	r2, r4
 80094a4:	b2c9      	uxtb	r1, r1
 80094a6:	f802 1b01 	strb.w	r1, [r2], #1
    while (n)
 80094aa:	4618      	mov	r0, r3
 80094ac:	2b00      	cmp	r3, #0
 80094ae:	d1ee      	bne.n	800948e <test_printn+0xe>
    while (p > buf)
 80094b0:	42aa      	cmp	r2, r5
 80094b2:	d909      	bls.n	80094c8 <test_printn+0x48>
 80094b4:	4e09      	ldr	r6, [pc, #36]	; (80094dc <test_printn+0x5c>)
 80094b6:	e001      	b.n	80094bc <test_printn+0x3c>
 80094b8:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      streamPut(test_chp, *--p);
 80094bc:	6830      	ldr	r0, [r6, #0]
 80094be:	6803      	ldr	r3, [r0, #0]
 80094c0:	689b      	ldr	r3, [r3, #8]
 80094c2:	4798      	blx	r3
    while (p > buf)
 80094c4:	42ac      	cmp	r4, r5
 80094c6:	d1f7      	bne.n	80094b8 <test_printn+0x38>
}
 80094c8:	b004      	add	sp, #16
 80094ca:	bd70      	pop	{r4, r5, r6, pc}
    streamPut(test_chp, '0');
 80094cc:	4b03      	ldr	r3, [pc, #12]	; (80094dc <test_printn+0x5c>)
 80094ce:	6818      	ldr	r0, [r3, #0]
 80094d0:	6803      	ldr	r3, [r0, #0]
 80094d2:	2130      	movs	r1, #48	; 0x30
 80094d4:	689b      	ldr	r3, [r3, #8]
 80094d6:	4718      	bx	r3
 80094d8:	cccccccd 	.word	0xcccccccd
 80094dc:	20001e50 	.word	0x20001e50

080094e0 <test_execute>:
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
 80094e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int i, j;

  test_chp = stream;
 80094e4:	4c86      	ldr	r4, [pc, #536]	; (8009700 <test_execute+0x220>)
#if defined(TEST_SUITE_NAME)
  test_println("*** " TEST_SUITE_NAME);
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
 80094e6:	4d87      	ldr	r5, [pc, #540]	; (8009704 <test_execute+0x224>)
  test_chp = stream;
 80094e8:	6020      	str	r0, [r4, #0]
msg_t test_execute(BaseSequentialStream *stream) {
 80094ea:	b085      	sub	sp, #20
  test_println("");
 80094ec:	4886      	ldr	r0, [pc, #536]	; (8009708 <test_execute+0x228>)
 80094ee:	f7ff ff8f 	bl	8009410 <test_println>
  test_println("*** " TEST_SUITE_NAME);
 80094f2:	4886      	ldr	r0, [pc, #536]	; (800970c <test_execute+0x22c>)
 80094f4:	f7ff ff8c 	bl	8009410 <test_println>
  test_println("***");
 80094f8:	4885      	ldr	r0, [pc, #532]	; (8009710 <test_execute+0x230>)
 80094fa:	f7ff ff89 	bl	8009410 <test_println>
 80094fe:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 8009500:	6820      	ldr	r0, [r4, #0]
 8009502:	6803      	ldr	r3, [r0, #0]
 8009504:	689b      	ldr	r3, [r3, #8]
 8009506:	4798      	blx	r3
  while (*msgp)
 8009508:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800950c:	2900      	cmp	r1, #0
 800950e:	d1f7      	bne.n	8009500 <test_execute+0x20>
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8009510:	4880      	ldr	r0, [pc, #512]	; (8009714 <test_execute+0x234>)
 8009512:	4d81      	ldr	r5, [pc, #516]	; (8009718 <test_execute+0x238>)
 8009514:	f7ff ff7c 	bl	8009410 <test_println>
 8009518:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 800951a:	6820      	ldr	r0, [r4, #0]
 800951c:	6803      	ldr	r3, [r0, #0]
 800951e:	689b      	ldr	r3, [r3, #8]
 8009520:	4798      	blx	r3
  while (*msgp)
 8009522:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8009526:	2900      	cmp	r1, #0
 8009528:	d1f7      	bne.n	800951a <test_execute+0x3a>
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 800952a:	487c      	ldr	r0, [pc, #496]	; (800971c <test_execute+0x23c>)
 800952c:	4d7c      	ldr	r5, [pc, #496]	; (8009720 <test_execute+0x240>)
 800952e:	f7ff ff6f 	bl	8009410 <test_println>
 8009532:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 8009534:	6820      	ldr	r0, [r4, #0]
 8009536:	6803      	ldr	r3, [r0, #0]
 8009538:	689b      	ldr	r3, [r3, #8]
 800953a:	4798      	blx	r3
  while (*msgp)
 800953c:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8009540:	2900      	cmp	r1, #0
 8009542:	d1f7      	bne.n	8009534 <test_execute+0x54>
 8009544:	4b77      	ldr	r3, [pc, #476]	; (8009724 <test_execute+0x244>)
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8009546:	4878      	ldr	r0, [pc, #480]	; (8009728 <test_execute+0x248>)
 8009548:	9303      	str	r3, [sp, #12]
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");

  test_global_fail = false;
 800954a:	4b78      	ldr	r3, [pc, #480]	; (800972c <test_execute+0x24c>)
 800954c:	9101      	str	r1, [sp, #4]
 800954e:	9302      	str	r3, [sp, #8]
  test_println(BOARD_NAME);
 8009550:	f7ff ff5e 	bl	8009410 <test_println>
  test_println("");
 8009554:	486c      	ldr	r0, [pc, #432]	; (8009708 <test_execute+0x228>)
  test_global_fail = false;
 8009556:	f8df 821c 	ldr.w	r8, [pc, #540]	; 8009774 <test_execute+0x294>
  test_tokp = test_tokens_buffer;
 800955a:	4e75      	ldr	r6, [pc, #468]	; (8009730 <test_execute+0x250>)
 800955c:	f8df b1f4 	ldr.w	fp, [pc, #500]	; 8009754 <test_execute+0x274>
  test_local_fail = false;
 8009560:	f8df a214 	ldr.w	sl, [pc, #532]	; 8009778 <test_execute+0x298>
  test_println("");
 8009564:	f7ff ff54 	bl	8009410 <test_println>
  test_global_fail = false;
 8009568:	4b72      	ldr	r3, [pc, #456]	; (8009734 <test_execute+0x254>)
 800956a:	9901      	ldr	r1, [sp, #4]
 800956c:	7019      	strb	r1, [r3, #0]
 800956e:	4b72      	ldr	r3, [pc, #456]	; (8009738 <test_execute+0x258>)
 8009570:	9a01      	ldr	r2, [sp, #4]
 8009572:	3201      	adds	r2, #1
 8009574:	9201      	str	r2, [sp, #4]
  while (cp < test_tokp)
 8009576:	2700      	movs	r7, #0
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 8009578:	2b00      	cmp	r3, #0
 800957a:	f000 808f 	beq.w	800969c <test_execute+0x1bc>
      print_line();
 800957e:	4d6f      	ldr	r5, [pc, #444]	; (800973c <test_execute+0x25c>)
 8009580:	f7ff fe8e 	bl	80092a0 <print_line>
 8009584:	212d      	movs	r1, #45	; 0x2d
    streamPut(test_chp, *msgp++);
 8009586:	6820      	ldr	r0, [r4, #0]
 8009588:	6803      	ldr	r3, [r0, #0]
 800958a:	689b      	ldr	r3, [r3, #8]
 800958c:	4798      	blx	r3
  while (*msgp)
 800958e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8009592:	2900      	cmp	r1, #0
 8009594:	d1f7      	bne.n	8009586 <test_execute+0xa6>
      test_print("--- Test Case ");
      test_printn(i + 1);
 8009596:	9801      	ldr	r0, [sp, #4]
      test_print(".");
      test_printn(j + 1);
 8009598:	4d69      	ldr	r5, [pc, #420]	; (8009740 <test_execute+0x260>)
      test_printn(i + 1);
 800959a:	f7ff ff71 	bl	8009480 <test_printn>
    streamPut(test_chp, *msgp++);
 800959e:	6820      	ldr	r0, [r4, #0]
 80095a0:	6803      	ldr	r3, [r0, #0]
 80095a2:	212e      	movs	r1, #46	; 0x2e
 80095a4:	689b      	ldr	r3, [r3, #8]
 80095a6:	f107 0901 	add.w	r9, r7, #1
 80095aa:	4798      	blx	r3
      test_printn(j + 1);
 80095ac:	4648      	mov	r0, r9
 80095ae:	f7ff ff67 	bl	8009480 <test_printn>
 80095b2:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
 80095b4:	6820      	ldr	r0, [r4, #0]
 80095b6:	6803      	ldr	r3, [r0, #0]
 80095b8:	689b      	ldr	r3, [r3, #8]
 80095ba:	4798      	blx	r3
  while (*msgp)
 80095bc:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80095c0:	2900      	cmp	r1, #0
 80095c2:	d1f7      	bne.n	80095b4 <test_execute+0xd4>
      test_print(" (");
      test_print(test_suite[i][j]->name);
 80095c4:	f858 3027 	ldr.w	r3, [r8, r7, lsl #2]
 80095c8:	681d      	ldr	r5, [r3, #0]
  while (*msgp)
 80095ca:	7829      	ldrb	r1, [r5, #0]
 80095cc:	b139      	cbz	r1, 80095de <test_execute+0xfe>
    streamPut(test_chp, *msgp++);
 80095ce:	6820      	ldr	r0, [r4, #0]
 80095d0:	6803      	ldr	r3, [r0, #0]
 80095d2:	689b      	ldr	r3, [r3, #8]
 80095d4:	4798      	blx	r3
  while (*msgp)
 80095d6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80095da:	2900      	cmp	r1, #0
 80095dc:	d1f7      	bne.n	80095ce <test_execute+0xee>
      test_println(")");
 80095de:	4859      	ldr	r0, [pc, #356]	; (8009744 <test_execute+0x264>)
 80095e0:	f7ff ff16 	bl	8009410 <test_println>
  chThdSleep(time);
 80095e4:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80095e8:	f7f8 f91a 	bl	8001820 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
 80095ec:	f858 5027 	ldr.w	r5, [r8, r7, lsl #2]
  test_tokp = test_tokens_buffer;
 80095f0:	f8c6 b000 	str.w	fp, [r6]
  if (tcp->setup != NULL)
 80095f4:	686b      	ldr	r3, [r5, #4]
  test_local_fail = false;
 80095f6:	2200      	movs	r2, #0
 80095f8:	f88a 2000 	strb.w	r2, [sl]
  if (tcp->setup != NULL)
 80095fc:	b103      	cbz	r3, 8009600 <test_execute+0x120>
    tcp->setup();
 80095fe:	4798      	blx	r3
  tcp->execute();
 8009600:	68eb      	ldr	r3, [r5, #12]
 8009602:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8009604:	68ab      	ldr	r3, [r5, #8]
 8009606:	b103      	cbz	r3, 800960a <test_execute+0x12a>
    tcp->teardown();
 8009608:	4798      	blx	r3
      if (test_local_fail) {
 800960a:	f89a 3000 	ldrb.w	r3, [sl]
 800960e:	2b00      	cmp	r3, #0
 8009610:	d04f      	beq.n	80096b2 <test_execute+0x1d2>
 8009612:	4d4d      	ldr	r5, [pc, #308]	; (8009748 <test_execute+0x268>)
 8009614:	212d      	movs	r1, #45	; 0x2d
    streamPut(test_chp, *msgp++);
 8009616:	6820      	ldr	r0, [r4, #0]
 8009618:	6803      	ldr	r3, [r0, #0]
 800961a:	689b      	ldr	r3, [r3, #8]
 800961c:	4798      	blx	r3
  while (*msgp)
 800961e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8009622:	2900      	cmp	r1, #0
 8009624:	d1f7      	bne.n	8009616 <test_execute+0x136>
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
 8009626:	4b49      	ldr	r3, [pc, #292]	; (800974c <test_execute+0x26c>)
 8009628:	4d49      	ldr	r5, [pc, #292]	; (8009750 <test_execute+0x270>)
 800962a:	6818      	ldr	r0, [r3, #0]
 800962c:	f7ff ff28 	bl	8009480 <test_printn>
 8009630:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
 8009632:	6820      	ldr	r0, [r4, #0]
 8009634:	6803      	ldr	r3, [r0, #0]
 8009636:	689b      	ldr	r3, [r3, #8]
 8009638:	4798      	blx	r3
  while (*msgp)
 800963a:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800963e:	2900      	cmp	r1, #0
 8009640:	d1f7      	bne.n	8009632 <test_execute+0x152>
  while (cp < test_tokp)
 8009642:	6833      	ldr	r3, [r6, #0]
 8009644:	455b      	cmp	r3, fp
 8009646:	d909      	bls.n	800965c <test_execute+0x17c>
 8009648:	4d42      	ldr	r5, [pc, #264]	; (8009754 <test_execute+0x274>)
    streamPut(test_chp, *cp++);
 800964a:	6820      	ldr	r0, [r4, #0]
 800964c:	f815 1b01 	ldrb.w	r1, [r5], #1
 8009650:	6803      	ldr	r3, [r0, #0]
 8009652:	689b      	ldr	r3, [r3, #8]
 8009654:	4798      	blx	r3
  while (cp < test_tokp)
 8009656:	6833      	ldr	r3, [r6, #0]
 8009658:	429d      	cmp	r5, r3
 800965a:	d3f6      	bcc.n	800964a <test_execute+0x16a>
 800965c:	4d3e      	ldr	r5, [pc, #248]	; (8009758 <test_execute+0x278>)
 800965e:	215d      	movs	r1, #93	; 0x5d
    streamPut(test_chp, *msgp++);
 8009660:	6820      	ldr	r0, [r4, #0]
 8009662:	6803      	ldr	r3, [r0, #0]
 8009664:	689b      	ldr	r3, [r3, #8]
 8009666:	4798      	blx	r3
  while (*msgp)
 8009668:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800966c:	2900      	cmp	r1, #0
 800966e:	d1f7      	bne.n	8009660 <test_execute+0x180>
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
 8009670:	4b3a      	ldr	r3, [pc, #232]	; (800975c <test_execute+0x27c>)
 8009672:	681d      	ldr	r5, [r3, #0]
  while (*msgp)
 8009674:	7829      	ldrb	r1, [r5, #0]
 8009676:	b139      	cbz	r1, 8009688 <test_execute+0x1a8>
    streamPut(test_chp, *msgp++);
 8009678:	6820      	ldr	r0, [r4, #0]
 800967a:	6803      	ldr	r3, [r0, #0]
 800967c:	689b      	ldr	r3, [r3, #8]
 800967e:	4798      	blx	r3
  while (*msgp)
 8009680:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8009684:	2900      	cmp	r1, #0
 8009686:	d1f7      	bne.n	8009678 <test_execute+0x198>
        test_println("\")");
 8009688:	4835      	ldr	r0, [pc, #212]	; (8009760 <test_execute+0x280>)
 800968a:	f7ff fec1 	bl	8009410 <test_println>
 800968e:	eb08 0387 	add.w	r3, r8, r7, lsl #2
  while (cp < test_tokp)
 8009692:	464f      	mov	r7, r9
 8009694:	685b      	ldr	r3, [r3, #4]
    while (test_suite[i][j]) {
 8009696:	2b00      	cmp	r3, #0
 8009698:	f47f af71 	bne.w	800957e <test_execute+0x9e>
  while (test_suite[i]) {
 800969c:	9902      	ldr	r1, [sp, #8]
 800969e:	b161      	cbz	r1, 80096ba <test_execute+0x1da>
      }
      else
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
 80096a0:	9a03      	ldr	r2, [sp, #12]
 80096a2:	680b      	ldr	r3, [r1, #0]
 80096a4:	4688      	mov	r8, r1
 80096a6:	4611      	mov	r1, r2
 80096a8:	f851 2b04 	ldr.w	r2, [r1], #4
 80096ac:	9202      	str	r2, [sp, #8]
 80096ae:	9103      	str	r1, [sp, #12]
 80096b0:	e75e      	b.n	8009570 <test_execute+0x90>
        test_println("--- Result: SUCCESS");
 80096b2:	482c      	ldr	r0, [pc, #176]	; (8009764 <test_execute+0x284>)
 80096b4:	f7ff feac 	bl	8009410 <test_println>
 80096b8:	e7e9      	b.n	800968e <test_execute+0x1ae>
  }
  print_line();
 80096ba:	f7ff fdf1 	bl	80092a0 <print_line>
  test_println("");
 80096be:	4d2a      	ldr	r5, [pc, #168]	; (8009768 <test_execute+0x288>)
 80096c0:	4811      	ldr	r0, [pc, #68]	; (8009708 <test_execute+0x228>)
 80096c2:	f7ff fea5 	bl	8009410 <test_println>
 80096c6:	2146      	movs	r1, #70	; 0x46
    streamPut(test_chp, *msgp++);
 80096c8:	6820      	ldr	r0, [r4, #0]
 80096ca:	6803      	ldr	r3, [r0, #0]
 80096cc:	689b      	ldr	r3, [r3, #8]
 80096ce:	4798      	blx	r3
  while (*msgp)
 80096d0:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80096d4:	2900      	cmp	r1, #0
 80096d6:	d1f7      	bne.n	80096c8 <test_execute+0x1e8>
  test_print("Final result: ");
  if (test_global_fail)
 80096d8:	4b16      	ldr	r3, [pc, #88]	; (8009734 <test_execute+0x254>)
 80096da:	781b      	ldrb	r3, [r3, #0]
 80096dc:	b93b      	cbnz	r3, 80096ee <test_execute+0x20e>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 80096de:	4823      	ldr	r0, [pc, #140]	; (800976c <test_execute+0x28c>)
 80096e0:	f7ff fe96 	bl	8009410 <test_println>
#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END
#endif

  return (msg_t)test_global_fail;
}
 80096e4:	4b13      	ldr	r3, [pc, #76]	; (8009734 <test_execute+0x254>)
 80096e6:	7818      	ldrb	r0, [r3, #0]
 80096e8:	b005      	add	sp, #20
 80096ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    test_println("FAILURE");
 80096ee:	4820      	ldr	r0, [pc, #128]	; (8009770 <test_execute+0x290>)
 80096f0:	f7ff fe8e 	bl	8009410 <test_println>
}
 80096f4:	4b0f      	ldr	r3, [pc, #60]	; (8009734 <test_execute+0x254>)
 80096f6:	7818      	ldrb	r0, [r3, #0]
 80096f8:	b005      	add	sp, #20
 80096fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80096fe:	bf00      	nop
 8009700:	20001e50 	.word	0x20001e50
 8009704:	0800c2fc 	.word	0x0800c2fc
 8009708:	0800b200 	.word	0x0800b200
 800970c:	0800c37c 	.word	0x0800c37c
 8009710:	0800c398 	.word	0x0800c398
 8009714:	0800c39c 	.word	0x0800c39c
 8009718:	0800c310 	.word	0x0800c310
 800971c:	0800afb8 	.word	0x0800afb8
 8009720:	0800c324 	.word	0x0800c324
 8009724:	0800c4dc 	.word	0x0800c4dc
 8009728:	0800aff8 	.word	0x0800aff8
 800972c:	0800c3ec 	.word	0x0800c3ec
 8009730:	20001e64 	.word	0x20001e64
 8009734:	200015a0 	.word	0x200015a0
 8009738:	0800bfcc 	.word	0x0800bfcc
 800973c:	0800c338 	.word	0x0800c338
 8009740:	0800c348 	.word	0x0800c348
 8009744:	0800c3b4 	.word	0x0800c3b4
 8009748:	0800c34c 	.word	0x0800c34c
 800974c:	20001df8 	.word	0x20001df8
 8009750:	0800c364 	.word	0x0800c364
 8009754:	20001e54 	.word	0x20001e54
 8009758:	0800c368 	.word	0x0800c368
 800975c:	2000159c 	.word	0x2000159c
 8009760:	0800c3b8 	.word	0x0800c3b8
 8009764:	0800c3bc 	.word	0x0800c3bc
 8009768:	0800c36c 	.word	0x0800c36c
 800976c:	0800c3c8 	.word	0x0800c3c8
 8009770:	0800c3d0 	.word	0x0800c3d0
 8009774:	0800c3d8 	.word	0x0800c3d8
 8009778:	200015a1 	.word	0x200015a1
 800977c:	00000000 	.word	0x00000000

08009780 <_test_assert_sequence>:
bool _test_assert_sequence(char *expected, const char *msg) {
 8009780:	b4f0      	push	{r4, r5, r6, r7}
 8009782:	4e0d      	ldr	r6, [pc, #52]	; (80097b8 <_test_assert_sequence+0x38>)
  char *cp = test_tokens_buffer;
 8009784:	4f0d      	ldr	r7, [pc, #52]	; (80097bc <_test_assert_sequence+0x3c>)
 8009786:	6835      	ldr	r5, [r6, #0]
 8009788:	463b      	mov	r3, r7
 800978a:	e005      	b.n	8009798 <_test_assert_sequence+0x18>
    if (*cp++ != *expected++)
 800978c:	f813 4b01 	ldrb.w	r4, [r3], #1
 8009790:	f810 2b01 	ldrb.w	r2, [r0], #1
 8009794:	4294      	cmp	r4, r2
 8009796:	d106      	bne.n	80097a6 <_test_assert_sequence+0x26>
  while (cp < test_tokp) {
 8009798:	42ab      	cmp	r3, r5
 800979a:	d3f7      	bcc.n	800978c <_test_assert_sequence+0xc>
  if (*expected)
 800979c:	7800      	ldrb	r0, [r0, #0]
 800979e:	b910      	cbnz	r0, 80097a6 <_test_assert_sequence+0x26>
  test_tokp = test_tokens_buffer;
 80097a0:	6037      	str	r7, [r6, #0]
}
 80097a2:	bcf0      	pop	{r4, r5, r6, r7}
 80097a4:	4770      	bx	lr
  test_local_fail      = true;
 80097a6:	4c06      	ldr	r4, [pc, #24]	; (80097c0 <_test_assert_sequence+0x40>)
  test_global_fail     = true;
 80097a8:	4a06      	ldr	r2, [pc, #24]	; (80097c4 <_test_assert_sequence+0x44>)
  test_failure_message = msg;
 80097aa:	4b07      	ldr	r3, [pc, #28]	; (80097c8 <_test_assert_sequence+0x48>)
  test_local_fail      = true;
 80097ac:	2001      	movs	r0, #1
 80097ae:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 80097b0:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 80097b2:	6019      	str	r1, [r3, #0]
}
 80097b4:	bcf0      	pop	{r4, r5, r6, r7}
 80097b6:	4770      	bx	lr
 80097b8:	20001e64 	.word	0x20001e64
 80097bc:	20001e54 	.word	0x20001e54
 80097c0:	200015a1 	.word	0x200015a1
 80097c4:	200015a0 	.word	0x200015a0
 80097c8:	2000159c 	.word	0x2000159c
 80097cc:	00000000 	.word	0x00000000

080097d0 <_test_assert>:
  if (!condition)
 80097d0:	b948      	cbnz	r0, 80097e6 <_test_assert+0x16>
bool _test_assert(bool condition, const char *msg) {
 80097d2:	b410      	push	{r4}
  test_global_fail     = true;
 80097d4:	4a05      	ldr	r2, [pc, #20]	; (80097ec <_test_assert+0x1c>)
  test_local_fail      = true;
 80097d6:	4c06      	ldr	r4, [pc, #24]	; (80097f0 <_test_assert+0x20>)
  test_failure_message = msg;
 80097d8:	4b06      	ldr	r3, [pc, #24]	; (80097f4 <_test_assert+0x24>)
  test_local_fail      = true;
 80097da:	2001      	movs	r0, #1
 80097dc:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 80097de:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 80097e0:	6019      	str	r1, [r3, #0]
}
 80097e2:	bc10      	pop	{r4}
 80097e4:	4770      	bx	lr
  return false;
 80097e6:	2000      	movs	r0, #0
 80097e8:	4770      	bx	lr
 80097ea:	bf00      	nop
 80097ec:	200015a0 	.word	0x200015a0
 80097f0:	200015a1 	.word	0x200015a1
 80097f4:	2000159c 	.word	0x2000159c
	...

08009800 <__early_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8009800:	4a32      	ldr	r2, [pc, #200]	; (80098cc <__early_init+0xcc>)
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8009802:	4b33      	ldr	r3, [pc, #204]	; (80098d0 <__early_init+0xd0>)
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8009804:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
  PWR->CR = STM32_VOS;
 8009808:	f44f 4140 	mov.w	r1, #49152	; 0xc000
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800980c:	6410      	str	r0, [r2, #64]	; 0x40
  PWR->CR = STM32_VOS;
 800980e:	6019      	str	r1, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8009810:	6813      	ldr	r3, [r2, #0]
 8009812:	f043 0301 	orr.w	r3, r3, #1
 8009816:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8009818:	6813      	ldr	r3, [r2, #0]
 800981a:	0799      	lsls	r1, r3, #30
 800981c:	d5fc      	bpl.n	8009818 <__early_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800981e:	6893      	ldr	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8009820:	492a      	ldr	r1, [pc, #168]	; (80098cc <__early_init+0xcc>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8009822:	f023 0303 	bic.w	r3, r3, #3
 8009826:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8009828:	6893      	ldr	r3, [r2, #8]
 800982a:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800982c:	688b      	ldr	r3, [r1, #8]
 800982e:	f013 030c 	ands.w	r3, r3, #12
 8009832:	d1fb      	bne.n	800982c <__early_init+0x2c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8009834:	680a      	ldr	r2, [r1, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8009836:	4825      	ldr	r0, [pc, #148]	; (80098cc <__early_init+0xcc>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8009838:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 800983c:	600a      	str	r2, [r1, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800983e:	608b      	str	r3, [r1, #8]
  RCC->CR |= RCC_CR_HSEON;
 8009840:	680b      	ldr	r3, [r1, #0]
 8009842:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009846:	600b      	str	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8009848:	6803      	ldr	r3, [r0, #0]
 800984a:	039b      	lsls	r3, r3, #14
 800984c:	d5fc      	bpl.n	8009848 <__early_init+0x48>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800984e:	6f43      	ldr	r3, [r0, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8009850:	4a1e      	ldr	r2, [pc, #120]	; (80098cc <__early_init+0xcc>)
  RCC->CSR |= RCC_CSR_LSION;
 8009852:	f043 0301 	orr.w	r3, r3, #1
 8009856:	6743      	str	r3, [r0, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8009858:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800985a:	0799      	lsls	r1, r3, #30
 800985c:	d5fc      	bpl.n	8009858 <__early_init+0x58>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800985e:	4b1d      	ldr	r3, [pc, #116]	; (80098d4 <__early_init+0xd4>)
 8009860:	6053      	str	r3, [r2, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8009862:	6813      	ldr	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8009864:	491a      	ldr	r1, [pc, #104]	; (80098d0 <__early_init+0xd0>)
  RCC->CR |= RCC_CR_PLLON;
 8009866:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800986a:	6013      	str	r3, [r2, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800986c:	684b      	ldr	r3, [r1, #4]
 800986e:	045a      	lsls	r2, r3, #17
 8009870:	d5fc      	bpl.n	800986c <__early_init+0x6c>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8009872:	4a16      	ldr	r2, [pc, #88]	; (80098cc <__early_init+0xcc>)
 8009874:	6813      	ldr	r3, [r2, #0]
 8009876:	019b      	lsls	r3, r3, #6
 8009878:	d5fc      	bpl.n	8009874 <__early_init+0x74>

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800987a:	4b17      	ldr	r3, [pc, #92]	; (80098d8 <__early_init+0xd8>)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800987c:	4917      	ldr	r1, [pc, #92]	; (80098dc <__early_init+0xdc>)
 800987e:	6091      	str	r1, [r2, #8]
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8009880:	681a      	ldr	r2, [r3, #0]
 8009882:	4b17      	ldr	r3, [pc, #92]	; (80098e0 <__early_init+0xe0>)
 8009884:	429a      	cmp	r2, r3
 8009886:	d016      	beq.n	80098b6 <__early_init+0xb6>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8009888:	4b16      	ldr	r3, [pc, #88]	; (80098e4 <__early_init+0xe4>)
 800988a:	f240 7205 	movw	r2, #1797	; 0x705
 800988e:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8009890:	4a0e      	ldr	r2, [pc, #56]	; (80098cc <__early_init+0xcc>)
 8009892:	6893      	ldr	r3, [r2, #8]
 8009894:	f043 0302 	orr.w	r3, r3, #2
 8009898:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800989a:	6893      	ldr	r3, [r2, #8]
 800989c:	f003 030c 	and.w	r3, r3, #12
 80098a0:	2b08      	cmp	r3, #8
 80098a2:	d1fa      	bne.n	800989a <__early_init+0x9a>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80098a4:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80098a6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80098aa:	6453      	str	r3, [r2, #68]	; 0x44
 80098ac:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80098ae:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80098b2:	6653      	str	r3, [r2, #100]	; 0x64
 80098b4:	4770      	bx	lr
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80098b6:	4a0c      	ldr	r2, [pc, #48]	; (80098e8 <__early_init+0xe8>)
 80098b8:	4b0c      	ldr	r3, [pc, #48]	; (80098ec <__early_init+0xec>)
 80098ba:	6812      	ldr	r2, [r2, #0]
 80098bc:	429a      	cmp	r2, r3
 80098be:	d1e3      	bne.n	8009888 <__early_init+0x88>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 80098c0:	4b08      	ldr	r3, [pc, #32]	; (80098e4 <__early_init+0xe4>)
 80098c2:	f240 1205 	movw	r2, #261	; 0x105
 80098c6:	601a      	str	r2, [r3, #0]
 80098c8:	e7e2      	b.n	8009890 <__early_init+0x90>
 80098ca:	bf00      	nop
 80098cc:	40023800 	.word	0x40023800
 80098d0:	40007000 	.word	0x40007000
 80098d4:	07405408 	.word	0x07405408
 80098d8:	e0042000 	.word	0xe0042000
 80098dc:	38889400 	.word	0x38889400
 80098e0:	20006411 	.word	0x20006411
 80098e4:	40023c00 	.word	0x40023c00
 80098e8:	e000ed00 	.word	0xe000ed00
 80098ec:	410fc241 	.word	0x410fc241

080098f0 <usb_lld_start_in>:
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80098f0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 80098f4:	b4f0      	push	{r4, r5, r6, r7}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80098f6:	68dc      	ldr	r4, [r3, #12]
 80098f8:	6962      	ldr	r2, [r4, #20]
  isp->totsize = isp->txsize;
 80098fa:	6813      	ldr	r3, [r2, #0]
 80098fc:	60d3      	str	r3, [r2, #12]
  if (isp->txsize == 0) {
 80098fe:	b9f3      	cbnz	r3, 800993e <usb_lld_start_in+0x4e>
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8009900:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8009902:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 8009906:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800990a:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800990e:	6823      	ldr	r3, [r4, #0]
 8009910:	f003 0303 	and.w	r3, r3, #3
 8009914:	2b01      	cmp	r3, #1
 8009916:	d026      	beq.n	8009966 <usb_lld_start_in+0x76>
 8009918:	b208      	sxth	r0, r1
 800991a:	eb02 1040 	add.w	r0, r2, r0, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800991e:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8009920:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
 8009924:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8009928:	f8c0 4900 	str.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800992c:	f8d2 0834 	ldr.w	r0, [r2, #2100]	; 0x834
 8009930:	fa03 f101 	lsl.w	r1, r3, r1
 8009934:	4301      	orrs	r1, r0
 8009936:	f8c2 1834 	str.w	r1, [r2, #2100]	; 0x834
}
 800993a:	bcf0      	pop	{r4, r5, r6, r7}
 800993c:	4770      	bx	lr
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 800993e:	b319      	cbz	r1, 8009988 <usb_lld_start_in+0x98>
 8009940:	f043 5500 	orr.w	r5, r3, #536870912	; 0x20000000
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8009944:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8009946:	8a26      	ldrh	r6, [r4, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8009948:	eb02 1741 	add.w	r7, r2, r1, lsl #5
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800994c:	1e70      	subs	r0, r6, #1
 800994e:	4403      	add	r3, r0
 8009950:	fbb3 f3f6 	udiv	r3, r3, r6
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8009954:	ea45 43c3 	orr.w	r3, r5, r3, lsl #19
 8009958:	f8c7 3910 	str.w	r3, [r7, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800995c:	6823      	ldr	r3, [r4, #0]
 800995e:	f003 0303 	and.w	r3, r3, #3
 8009962:	2b01      	cmp	r3, #1
 8009964:	d1d8      	bne.n	8009918 <usb_lld_start_in+0x28>
 8009966:	b208      	sxth	r0, r1
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8009968:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
 800996c:	eb02 1440 	add.w	r4, r2, r0, lsl #5
 8009970:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8009974:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
 8009978:	bf14      	ite	ne
 800997a:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 800997e:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 8009982:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
 8009986:	e7c8      	b.n	800991a <usb_lld_start_in+0x2a>
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8009988:	2b40      	cmp	r3, #64	; 0x40
 800998a:	d9d9      	bls.n	8009940 <usb_lld_start_in+0x50>
      isp->txsize = EP0_MAX_INSIZE;
 800998c:	2340      	movs	r3, #64	; 0x40
 800998e:	4d01      	ldr	r5, [pc, #4]	; (8009994 <usb_lld_start_in+0xa4>)
 8009990:	6013      	str	r3, [r2, #0]
 8009992:	e7d7      	b.n	8009944 <usb_lld_start_in+0x54>
 8009994:	20000040 	.word	0x20000040
	...

080099a0 <usb_lld_start_out>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80099a0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 80099a4:	b430      	push	{r4, r5}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80099a6:	68dd      	ldr	r5, [r3, #12]
 80099a8:	69ab      	ldr	r3, [r5, #24]
  osp->totsize = osp->rxsize;
 80099aa:	681c      	ldr	r4, [r3, #0]
 80099ac:	60dc      	str	r4, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 80099ae:	b919      	cbnz	r1, 80099b8 <usb_lld_start_out+0x18>
 80099b0:	2c40      	cmp	r4, #64	; 0x40
      osp->rxsize = EP0_MAX_OUTSIZE;
 80099b2:	bf84      	itt	hi
 80099b4:	2440      	movhi	r4, #64	; 0x40
 80099b6:	601c      	strhi	r4, [r3, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 80099b8:	8a6b      	ldrh	r3, [r5, #18]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80099ba:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80099bc:	682d      	ldr	r5, [r5, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 80099be:	1e5a      	subs	r2, r3, #1
 80099c0:	4422      	add	r2, r4
 80099c2:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 80099c6:	fb02 f303 	mul.w	r3, r2, r3
 80099ca:	3303      	adds	r3, #3
 80099cc:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80099d0:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 80099d4:	eb00 1441 	add.w	r4, r0, r1, lsl #5
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80099d8:	f005 0203 	and.w	r2, r5, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80099dc:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80099e0:	2a01      	cmp	r2, #1
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80099e2:	f8c4 3b10 	str.w	r3, [r4, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80099e6:	d00a      	beq.n	80099fe <usb_lld_start_out+0x5e>
 80099e8:	b209      	sxth	r1, r1
 80099ea:	eb00 1141 	add.w	r1, r0, r1, lsl #5
}
 80099ee:	bc30      	pop	{r4, r5}
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 80099f0:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 80099f4:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80099f8:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 80099fc:	4770      	bx	lr
 80099fe:	b209      	sxth	r1, r1
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8009a00:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8009a04:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 8009a08:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 8009a0c:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8009a10:	bf14      	ite	ne
 8009a12:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8009a16:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 8009a1a:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 8009a1e:	e7e4      	b.n	80099ea <usb_lld_start_out+0x4a>

08009a20 <test_emit_token>:
void test_emit_token(char token) {
 8009a20:	b510      	push	{r4, lr}
 8009a22:	2320      	movs	r3, #32
 8009a24:	4604      	mov	r4, r0
 8009a26:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009a2a:	f7f7 fc19 	bl	8001260 <_dbg_check_lock>
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 8009a2e:	4a0d      	ldr	r2, [pc, #52]	; (8009a64 <test_emit_token+0x44>)
 8009a30:	490d      	ldr	r1, [pc, #52]	; (8009a68 <test_emit_token+0x48>)
 8009a32:	6813      	ldr	r3, [r2, #0]
 8009a34:	428b      	cmp	r3, r1
 8009a36:	d202      	bcs.n	8009a3e <test_emit_token+0x1e>
    *test_tokp++ = token;
 8009a38:	1c59      	adds	r1, r3, #1
 8009a3a:	701c      	strb	r4, [r3, #0]
 8009a3c:	6011      	str	r1, [r2, #0]
  _dbg_check_unlock();
 8009a3e:	f7f7 fbe7 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009a42:	4b0a      	ldr	r3, [pc, #40]	; (8009a6c <test_emit_token+0x4c>)
 8009a44:	681a      	ldr	r2, [r3, #0]
 8009a46:	429a      	cmp	r2, r3
 8009a48:	d004      	beq.n	8009a54 <test_emit_token+0x34>
 8009a4a:	6999      	ldr	r1, [r3, #24]
 8009a4c:	6893      	ldr	r3, [r2, #8]
 8009a4e:	688a      	ldr	r2, [r1, #8]
 8009a50:	429a      	cmp	r2, r3
 8009a52:	d303      	bcc.n	8009a5c <test_emit_token+0x3c>
 8009a54:	2300      	movs	r3, #0
 8009a56:	f383 8811 	msr	BASEPRI, r3
 8009a5a:	bd10      	pop	{r4, pc}
 8009a5c:	4804      	ldr	r0, [pc, #16]	; (8009a70 <test_emit_token+0x50>)
 8009a5e:	f7f6 fedf 	bl	8000820 <chSysHalt>
 8009a62:	bf00      	nop
 8009a64:	20001e64 	.word	0x20001e64
 8009a68:	20001e64 	.word	0x20001e64
 8009a6c:	20001e68 	.word	0x20001e68
 8009a70:	0800b8b0 	.word	0x0800b8b0
	...

08009a80 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8009a80:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8009a84:	4604      	mov	r4, r0
 8009a86:	b083      	sub	sp, #12
 8009a88:	2320      	movs	r3, #32
  USBDriver *usbp = (USBDriver *)p;
  stm32_otg_t *otgp = usbp->otg;
 8009a8a:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
 8009a8c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009a90:	f7f7 fbe6 	bl	8001260 <_dbg_check_lock>
  return ch.rlist.current;
 8009a94:	f8df a264 	ldr.w	sl, [pc, #612]	; 8009cfc <usb_lld_pump+0x27c>
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 8009a98:	7823      	ldrb	r3, [r4, #0]
 8009a9a:	2b01      	cmp	r3, #1
 8009a9c:	d004      	beq.n	8009aa8 <usb_lld_pump+0x28>
 8009a9e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8009aa0:	b9a3      	cbnz	r3, 8009acc <usb_lld_pump+0x4c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8009aa2:	696b      	ldr	r3, [r5, #20]
 8009aa4:	06db      	lsls	r3, r3, #27
 8009aa6:	d411      	bmi.n	8009acc <usb_lld_pump+0x4c>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 8009aa8:	69ab      	ldr	r3, [r5, #24]
  chDbgAssert(*trp == NULL, "not NULL");
 8009aaa:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 8009aac:	f043 0310 	orr.w	r3, r3, #16
 8009ab0:	61ab      	str	r3, [r5, #24]
 8009ab2:	b112      	cbz	r2, 8009aba <usb_lld_pump+0x3a>
 8009ab4:	488e      	ldr	r0, [pc, #568]	; (8009cf0 <usb_lld_pump+0x270>)
 8009ab6:	f7f6 feb3 	bl	8000820 <chSysHalt>
  *trp = tp;
 8009aba:	4623      	mov	r3, r4
 8009abc:	f8da 2018 	ldr.w	r2, [sl, #24]
 8009ac0:	f843 2f7c 	str.w	r2, [r3, #124]!
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8009ac4:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 8009ac6:	6253      	str	r3, [r2, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8009ac8:	f7f6 fed2 	bl	8000870 <chSchGoSleepS>
  _dbg_check_unlock();
 8009acc:	f7f7 fba0 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009ad0:	f8da 3000 	ldr.w	r3, [sl]
 8009ad4:	4553      	cmp	r3, sl
 8009ad6:	d005      	beq.n	8009ae4 <usb_lld_pump+0x64>
 8009ad8:	f8da 2018 	ldr.w	r2, [sl, #24]
 8009adc:	689b      	ldr	r3, [r3, #8]
 8009ade:	6892      	ldr	r2, [r2, #8]
 8009ae0:	429a      	cmp	r2, r3
 8009ae2:	d36c      	bcc.n	8009bbe <usb_lld_pump+0x13e>
 8009ae4:	2300      	movs	r3, #0
 8009ae6:	f383 8811 	msr	BASEPRI, r3
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 8009aea:	f04f 0901 	mov.w	r9, #1
 8009aee:	461e      	mov	r6, r3
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8009af0:	696b      	ldr	r3, [r5, #20]
 8009af2:	06db      	lsls	r3, r3, #27
 8009af4:	d552      	bpl.n	8009b9c <usb_lld_pump+0x11c>
  sts = usbp->otg->GRXSTSP;
 8009af6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8009af8:	6a1a      	ldr	r2, [r3, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8009afa:	f402 11f0 	and.w	r1, r2, #1966080	; 0x1e0000
 8009afe:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 8009b02:	d01e      	beq.n	8009b42 <usb_lld_pump+0xc2>
 8009b04:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
 8009b08:	d1f2      	bne.n	8009af0 <usb_lld_pump+0x70>
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8009b0a:	f002 010f 	and.w	r1, r2, #15
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8009b0e:	eb04 0181 	add.w	r1, r4, r1, lsl #2
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8009b12:	f3c2 120a 	ubfx	r2, r2, #4, #11
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8009b16:	68c9      	ldr	r1, [r1, #12]
 8009b18:	6a0f      	ldr	r7, [r1, #32]
  while (i < n) {
 8009b1a:	2a00      	cmp	r2, #0
 8009b1c:	d0e8      	beq.n	8009af0 <usb_lld_pump+0x70>
 8009b1e:	2100      	movs	r1, #0
      w = *fifop;
 8009b20:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
  while (i < n) {
 8009b24:	460b      	mov	r3, r1
 8009b26:	e002      	b.n	8009b2e <usb_lld_pump+0xae>
    i++;
 8009b28:	3301      	adds	r3, #1
  while (i < n) {
 8009b2a:	429a      	cmp	r2, r3
 8009b2c:	d0e0      	beq.n	8009af0 <usb_lld_pump+0x70>
    if ((i & 3) == 0){
 8009b2e:	f013 0f03 	tst.w	r3, #3
      w = *fifop;
 8009b32:	bf08      	it	eq
 8009b34:	6801      	ldreq	r1, [r0, #0]
    if (i < max) {
 8009b36:	2b07      	cmp	r3, #7
 8009b38:	d8f6      	bhi.n	8009b28 <usb_lld_pump+0xa8>
      *buf++ = (uint8_t)w;
 8009b3a:	7039      	strb	r1, [r7, #0]
      w >>= 8;
 8009b3c:	0a09      	lsrs	r1, r1, #8
      *buf++ = (uint8_t)w;
 8009b3e:	3701      	adds	r7, #1
 8009b40:	e7f2      	b.n	8009b28 <usb_lld_pump+0xa8>
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8009b42:	f002 0c0f 	and.w	ip, r2, #15
 8009b46:	eb04 0c8c 	add.w	ip, r4, ip, lsl #2
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8009b4a:	f3c2 120a 	ubfx	r2, r2, #4, #11
                            usbp->epc[ep]->out_state->rxbuf,
 8009b4e:	f8dc 100c 	ldr.w	r1, [ip, #12]
 8009b52:	698f      	ldr	r7, [r1, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8009b54:	e897 0103 	ldmia.w	r7, {r0, r1, r8}
 8009b58:	eba0 0e01 	sub.w	lr, r0, r1
  while (i < n) {
 8009b5c:	b1b2      	cbz	r2, 8009b8c <usb_lld_pump+0x10c>
 8009b5e:	2100      	movs	r1, #0
      w = *fifop;
 8009b60:	f503 5780 	add.w	r7, r3, #4096	; 0x1000
  while (i < n) {
 8009b64:	4640      	mov	r0, r8
 8009b66:	460b      	mov	r3, r1
    if ((i & 3) == 0){
 8009b68:	f013 0f03 	tst.w	r3, #3
      w = *fifop;
 8009b6c:	bf08      	it	eq
 8009b6e:	6839      	ldreq	r1, [r7, #0]
    if (i < max) {
 8009b70:	459e      	cmp	lr, r3
 8009b72:	d902      	bls.n	8009b7a <usb_lld_pump+0xfa>
      *buf++ = (uint8_t)w;
 8009b74:	7001      	strb	r1, [r0, #0]
      w >>= 8;
 8009b76:	0a09      	lsrs	r1, r1, #8
      *buf++ = (uint8_t)w;
 8009b78:	3001      	adds	r0, #1
    i++;
 8009b7a:	3301      	adds	r3, #1
  while (i < n) {
 8009b7c:	429a      	cmp	r2, r3
 8009b7e:	d1f3      	bne.n	8009b68 <usb_lld_pump+0xe8>
 8009b80:	f8dc 300c 	ldr.w	r3, [ip, #12]
 8009b84:	699f      	ldr	r7, [r3, #24]
 8009b86:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8009b8a:	6879      	ldr	r1, [r7, #4]
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8009b8c:	696b      	ldr	r3, [r5, #20]
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8009b8e:	eb08 0002 	add.w	r0, r8, r2
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8009b92:	06db      	lsls	r3, r3, #27
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8009b94:	440a      	add	r2, r1
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8009b96:	60b8      	str	r0, [r7, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8009b98:	607a      	str	r2, [r7, #4]
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8009b9a:	d4ac      	bmi.n	8009af6 <usb_lld_pump+0x76>
      if (usbp->txpending & epmask) {
 8009b9c:	6fa3      	ldr	r3, [r4, #120]	; 0x78
      epmask = (1 << ep);
 8009b9e:	fa09 f706 	lsl.w	r7, r9, r6
      if (usbp->txpending & epmask) {
 8009ba2:	421f      	tst	r7, r3
 8009ba4:	d10e      	bne.n	8009bc4 <usb_lld_pump+0x144>
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8009ba6:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8009ba8:	3601      	adds	r6, #1
 8009baa:	689b      	ldr	r3, [r3, #8]
 8009bac:	b2f6      	uxtb	r6, r6
 8009bae:	429e      	cmp	r6, r3
 8009bb0:	d99e      	bls.n	8009af0 <usb_lld_pump+0x70>
 8009bb2:	2320      	movs	r3, #32
 8009bb4:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009bb8:	f7f7 fb52 	bl	8001260 <_dbg_check_lock>
 8009bbc:	e76c      	b.n	8009a98 <usb_lld_pump+0x18>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009bbe:	484d      	ldr	r0, [pc, #308]	; (8009cf4 <usb_lld_pump+0x274>)
 8009bc0:	f7f6 fe2e 	bl	8000820 <chSysHalt>
 8009bc4:	2320      	movs	r3, #32
 8009bc6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009bca:	f7f7 fb49 	bl	8001260 <_dbg_check_lock>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8009bce:	68aa      	ldr	r2, [r5, #8]
        usbp->txpending &= ~epmask;
 8009bd0:	6fa3      	ldr	r3, [r4, #120]	; 0x78
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8009bd2:	f022 0201 	bic.w	r2, r2, #1
        usbp->txpending &= ~epmask;
 8009bd6:	ea23 0307 	bic.w	r3, r3, r7
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8009bda:	60aa      	str	r2, [r5, #8]
        usbp->txpending &= ~epmask;
 8009bdc:	67a3      	str	r3, [r4, #120]	; 0x78
  _dbg_check_unlock();
 8009bde:	f7f7 fb17 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009be2:	f8da 3000 	ldr.w	r3, [sl]
 8009be6:	4553      	cmp	r3, sl
 8009be8:	d005      	beq.n	8009bf6 <usb_lld_pump+0x176>
 8009bea:	f8da 2018 	ldr.w	r2, [sl, #24]
 8009bee:	689b      	ldr	r3, [r3, #8]
 8009bf0:	6892      	ldr	r2, [r2, #8]
 8009bf2:	429a      	cmp	r2, r3
 8009bf4:	d3e3      	bcc.n	8009bbe <usb_lld_pump+0x13e>
 8009bf6:	2300      	movs	r3, #0
 8009bf8:	f383 8811 	msr	BASEPRI, r3
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8009bfc:	eb04 0386 	add.w	r3, r4, r6, lsl #2
 8009c00:	68db      	ldr	r3, [r3, #12]
 8009c02:	f8d3 e014 	ldr.w	lr, [r3, #20]
 8009c06:	f8de 0004 	ldr.w	r0, [lr, #4]
 8009c0a:	f8de 2000 	ldr.w	r2, [lr]
 8009c0e:	4290      	cmp	r0, r2
 8009c10:	d263      	bcs.n	8009cda <usb_lld_pump+0x25a>
 8009c12:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
    if (n > usbp->epc[ep]->in_maxsize)
 8009c14:	f8b3 8010 	ldrh.w	r8, [r3, #16]
 8009c18:	f106 0c01 	add.w	ip, r6, #1
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8009c1c:	eb01 1346 	add.w	r3, r1, r6, lsl #5
 8009c20:	9301      	str	r3, [sp, #4]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8009c22:	eb01 310c 	add.w	r1, r1, ip, lsl #12
 8009c26:	4613      	mov	r3, r2
 8009c28:	46a3      	mov	fp, r4
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8009c2a:	1a18      	subs	r0, r3, r0
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8009c2c:	9b01      	ldr	r3, [sp, #4]
 8009c2e:	f8d3 3918 	ldr.w	r3, [r3, #2328]	; 0x918
    if (n > usbp->epc[ep]->in_maxsize)
 8009c32:	4540      	cmp	r0, r8
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8009c34:	b29b      	uxth	r3, r3
    if (n > usbp->epc[ep]->in_maxsize)
 8009c36:	d90a      	bls.n	8009c4e <usb_lld_pump+0x1ce>
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8009c38:	ebb8 0f83 	cmp.w	r8, r3, lsl #2
 8009c3c:	d849      	bhi.n	8009cd2 <usb_lld_pump+0x252>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8009c3e:	f8de 2008 	ldr.w	r2, [lr, #8]
  osalDbgAssert(n > 0, "is zero");
 8009c42:	f1b8 0f00 	cmp.w	r8, #0
 8009c46:	d142      	bne.n	8009cce <usb_lld_pump+0x24e>
 8009c48:	482b      	ldr	r0, [pc, #172]	; (8009cf8 <usb_lld_pump+0x278>)
 8009c4a:	f7f6 fde9 	bl	8000820 <chSysHalt>
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8009c4e:	ebb0 0f83 	cmp.w	r0, r3, lsl #2
 8009c52:	d83e      	bhi.n	8009cd2 <usb_lld_pump+0x252>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8009c54:	f8de 2008 	ldr.w	r2, [lr, #8]
    *fifop = *((uint32_t *)buf);
 8009c58:	6813      	ldr	r3, [r2, #0]
 8009c5a:	600b      	str	r3, [r1, #0]
    if (n <= 4) {
 8009c5c:	2804      	cmp	r0, #4
 8009c5e:	d907      	bls.n	8009c70 <usb_lld_pump+0x1f0>
 8009c60:	4603      	mov	r3, r0
 8009c62:	4694      	mov	ip, r2
    n -= 4;
 8009c64:	3b04      	subs	r3, #4
    *fifop = *((uint32_t *)buf);
 8009c66:	f85c 4f04 	ldr.w	r4, [ip, #4]!
 8009c6a:	600c      	str	r4, [r1, #0]
    if (n <= 4) {
 8009c6c:	2b04      	cmp	r3, #4
 8009c6e:	d8f9      	bhi.n	8009c64 <usb_lld_pump+0x1e4>
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8009c70:	e89e 0018 	ldmia.w	lr, {r3, r4}
    usbp->epc[ep]->in_state->txbuf += n;
 8009c74:	4402      	add	r2, r0
    usbp->epc[ep]->in_state->txcnt += n;
 8009c76:	4420      	add	r0, r4
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8009c78:	4283      	cmp	r3, r0
    usbp->epc[ep]->in_state->txbuf += n;
 8009c7a:	f8ce 2008 	str.w	r2, [lr, #8]
    usbp->epc[ep]->in_state->txcnt += n;
 8009c7e:	f8ce 0004 	str.w	r0, [lr, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8009c82:	d8d2      	bhi.n	8009c2a <usb_lld_pump+0x1aa>
 8009c84:	465c      	mov	r4, fp
      return true;
 8009c86:	f04f 0801 	mov.w	r8, #1
 8009c8a:	2320      	movs	r3, #32
 8009c8c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009c90:	f7f7 fae6 	bl	8001260 <_dbg_check_lock>
        osalSysUnlock();

        done = otg_txfifo_handler(usbp, ep);

        osalSysLock();
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8009c94:	68ab      	ldr	r3, [r5, #8]
 8009c96:	f043 0301 	orr.w	r3, r3, #1
 8009c9a:	60ab      	str	r3, [r5, #8]
        if (!done)
 8009c9c:	f1b8 0f00 	cmp.w	r8, #0
 8009ca0:	d104      	bne.n	8009cac <usb_lld_pump+0x22c>
          otgp->DIEPEMPMSK |= epmask;
 8009ca2:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
 8009ca6:	431f      	orrs	r7, r3
 8009ca8:	f8c5 7834 	str.w	r7, [r5, #2100]	; 0x834
  _dbg_check_unlock();
 8009cac:	f7f7 fab0 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009cb0:	f8da 3000 	ldr.w	r3, [sl]
 8009cb4:	4553      	cmp	r3, sl
 8009cb6:	d006      	beq.n	8009cc6 <usb_lld_pump+0x246>
 8009cb8:	f8da 2018 	ldr.w	r2, [sl, #24]
 8009cbc:	689b      	ldr	r3, [r3, #8]
 8009cbe:	6892      	ldr	r2, [r2, #8]
 8009cc0:	429a      	cmp	r2, r3
 8009cc2:	f4ff af7c 	bcc.w	8009bbe <usb_lld_pump+0x13e>
 8009cc6:	2300      	movs	r3, #0
 8009cc8:	f383 8811 	msr	BASEPRI, r3
 8009ccc:	e76b      	b.n	8009ba6 <usb_lld_pump+0x126>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8009cce:	4640      	mov	r0, r8
 8009cd0:	e7c2      	b.n	8009c58 <usb_lld_pump+0x1d8>
 8009cd2:	465c      	mov	r4, fp
      return false;
 8009cd4:	f04f 0800 	mov.w	r8, #0
 8009cd8:	e7d7      	b.n	8009c8a <usb_lld_pump+0x20a>
 8009cda:	2320      	movs	r3, #32
 8009cdc:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8009ce0:	f7f7 fabe 	bl	8001260 <_dbg_check_lock>
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8009ce4:	68ab      	ldr	r3, [r5, #8]
 8009ce6:	f043 0301 	orr.w	r3, r3, #1
 8009cea:	60ab      	str	r3, [r5, #8]
 8009cec:	e7de      	b.n	8009cac <usb_lld_pump+0x22c>
 8009cee:	bf00      	nop
 8009cf0:	0800b8d4 	.word	0x0800b8d4
 8009cf4:	0800b8c8 	.word	0x0800b8c8
 8009cf8:	0800b8f0 	.word	0x0800b8f0
 8009cfc:	20001e68 	.word	0x20001e68

08009d00 <_trace_switch.constprop.78>:
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8009d00:	4b0b      	ldr	r3, [pc, #44]	; (8009d30 <_trace_switch.constprop.78+0x30>)
 8009d02:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 8009d04:	07d2      	lsls	r2, r2, #31
 8009d06:	d500      	bpl.n	8009d0a <_trace_switch.constprop.78+0xa>
 8009d08:	4770      	bx	lr
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8009d0a:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8009d0c:	780a      	ldrb	r2, [r1, #0]
void _trace_switch(thread_t *ntp, thread_t *otp) {
 8009d0e:	b410      	push	{r4}
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8009d10:	2401      	movs	r4, #1
 8009d12:	f364 0202 	bfi	r2, r4, #0, #3
 8009d16:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8009d18:	f890 4020 	ldrb.w	r4, [r0, #32]
 8009d1c:	f364 02c7 	bfi	r2, r4, #3, #5
 8009d20:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8009d22:	699b      	ldr	r3, [r3, #24]
 8009d24:	608b      	str	r3, [r1, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8009d26:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8009d28:	60cb      	str	r3, [r1, #12]
}
 8009d2a:	bc10      	pop	{r4}
    trace_next();
 8009d2c:	f7f6 bd08 	b.w	8000740 <trace_next.lto_priv.92>
 8009d30:	20001e68 	.word	0x20001e68
	...

08009d40 <chTMStartMeasurementX.constprop.75>:
  return DWT->CYCCNT;
 8009d40:	4b01      	ldr	r3, [pc, #4]	; (8009d48 <chTMStartMeasurementX.constprop.75+0x8>)
 8009d42:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8009d44:	6083      	str	r3, [r0, #8]
 8009d46:	4770      	bx	lr
 8009d48:	e0001000 	.word	0xe0001000
 8009d4c:	00000000 	.word	0x00000000

08009d50 <chThdResumeI.constprop.70>:
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8009d50:	b508      	push	{r3, lr}
  if (*trp != NULL) {
 8009d52:	6803      	ldr	r3, [r0, #0]
 8009d54:	b173      	cbz	r3, 8009d74 <chThdResumeI.constprop.70+0x24>
    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8009d56:	f893 2020 	ldrb.w	r2, [r3, #32]
 8009d5a:	2a03      	cmp	r2, #3
 8009d5c:	d002      	beq.n	8009d64 <chThdResumeI.constprop.70+0x14>
 8009d5e:	4806      	ldr	r0, [pc, #24]	; (8009d78 <chThdResumeI.constprop.70+0x28>)
 8009d60:	f7f6 fd5e 	bl	8000820 <chSysHalt>
    *trp = NULL;
 8009d64:	2200      	movs	r2, #0
 8009d66:	6002      	str	r2, [r0, #0]
    tp->u.rdymsg = msg;
 8009d68:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8009d6a:	4618      	mov	r0, r3
}
 8009d6c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    (void) chSchReadyI(tp);
 8009d70:	f7f6 be6e 	b.w	8000a50 <chSchReadyI>
 8009d74:	bd08      	pop	{r3, pc}
 8009d76:	bf00      	nop
 8009d78:	0800c59c 	.word	0x0800c59c
 8009d7c:	00000000 	.word	0x00000000

08009d80 <chThdDequeueNextI.constprop.69>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8009d80:	b508      	push	{r3, lr}
  return (bool)(tqp->next != (const thread_t *)tqp);
 8009d82:	6803      	ldr	r3, [r0, #0]

  if (queue_notempty(tqp)) {
 8009d84:	4298      	cmp	r0, r3
 8009d86:	d009      	beq.n	8009d9c <chThdDequeueNextI.constprop.69+0x1c>
  tqp->next             = tp->queue.next;
 8009d88:	681a      	ldr	r2, [r3, #0]
 8009d8a:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8009d8c:	6050      	str	r0, [r2, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8009d8e:	f893 2020 	ldrb.w	r2, [r3, #32]
 8009d92:	2a04      	cmp	r2, #4
 8009d94:	d003      	beq.n	8009d9e <chThdDequeueNextI.constprop.69+0x1e>
 8009d96:	4805      	ldr	r0, [pc, #20]	; (8009dac <chThdDequeueNextI.constprop.69+0x2c>)
 8009d98:	f7f6 fd42 	bl	8000820 <chSysHalt>
 8009d9c:	bd08      	pop	{r3, pc}

  tp->u.rdymsg = msg;
 8009d9e:	2200      	movs	r2, #0
 8009da0:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8009da2:	4618      	mov	r0, r3
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8009da4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8009da8:	f7f6 be52 	b.w	8000a50 <chSchReadyI>
 8009dac:	0800c550 	.word	0x0800c550

08009db0 <chThdDequeueAllI.constprop.68>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8009db0:	b538      	push	{r3, r4, r5, lr}
  return (bool)(tqp->next != (const thread_t *)tqp);
 8009db2:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 8009db4:	4298      	cmp	r0, r3
 8009db6:	d00a      	beq.n	8009dce <chThdDequeueAllI.constprop.68+0x1e>
  tqp->next             = tp->queue.next;
 8009db8:	681a      	ldr	r2, [r3, #0]
 8009dba:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8009dbc:	6050      	str	r0, [r2, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8009dbe:	f893 2020 	ldrb.w	r2, [r3, #32]
 8009dc2:	2a04      	cmp	r2, #4
 8009dc4:	4604      	mov	r4, r0
 8009dc6:	d003      	beq.n	8009dd0 <chThdDequeueAllI.constprop.68+0x20>
 8009dc8:	480a      	ldr	r0, [pc, #40]	; (8009df4 <chThdDequeueAllI.constprop.68+0x44>)
 8009dca:	f7f6 fd29 	bl	8000820 <chSysHalt>
 8009dce:	bd38      	pop	{r3, r4, r5, pc}
  tp->u.rdymsg = msg;
 8009dd0:	f06f 0501 	mvn.w	r5, #1
 8009dd4:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8009dd6:	4618      	mov	r0, r3
 8009dd8:	f7f6 fe3a 	bl	8000a50 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8009ddc:	6823      	ldr	r3, [r4, #0]
 8009dde:	429c      	cmp	r4, r3
 8009de0:	d0f5      	beq.n	8009dce <chThdDequeueAllI.constprop.68+0x1e>
  tqp->next             = tp->queue.next;
 8009de2:	681a      	ldr	r2, [r3, #0]
 8009de4:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8009de6:	6054      	str	r4, [r2, #4]
  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8009de8:	f893 2020 	ldrb.w	r2, [r3, #32]
 8009dec:	2a04      	cmp	r2, #4
 8009dee:	d1eb      	bne.n	8009dc8 <chThdDequeueAllI.constprop.68+0x18>
 8009df0:	e7f0      	b.n	8009dd4 <chThdDequeueAllI.constprop.68+0x24>
 8009df2:	bf00      	nop
 8009df4:	0800c550 	.word	0x0800c550
	...

08009e00 <chCondSignalI.constprop.59>:
void chCondSignalI(condition_variable_t *cp) {
 8009e00:	b510      	push	{r4, lr}
  chDbgCheckClassI();
 8009e02:	f7f6 fd5d 	bl	80008c0 <chDbgCheckClassI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8009e06:	4b07      	ldr	r3, [pc, #28]	; (8009e24 <chCondSignalI.constprop.59+0x24>)
 8009e08:	681a      	ldr	r2, [r3, #0]
  if (queue_notempty(&cp->queue)) {
 8009e0a:	429a      	cmp	r2, r3
 8009e0c:	d009      	beq.n	8009e22 <chCondSignalI.constprop.59+0x22>
  tqp->next             = tp->queue.next;
 8009e0e:	6811      	ldr	r1, [r2, #0]
 8009e10:	6019      	str	r1, [r3, #0]
    tp->u.rdymsg = MSG_OK;
 8009e12:	2400      	movs	r4, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8009e14:	604b      	str	r3, [r1, #4]
 8009e16:	6254      	str	r4, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
 8009e18:	4610      	mov	r0, r2
}
 8009e1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    (void) chSchReadyI(tp);
 8009e1e:	f7f6 be17 	b.w	8000a50 <chSchReadyI>
 8009e22:	bd10      	pop	{r4, pc}
 8009e24:	20000c48 	.word	0x20000c48
	...

08009e30 <chHeapAllocAligned.constprop.41>:
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8009e30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
 8009e34:	2900      	cmp	r1, #0
 8009e36:	d03d      	beq.n	8009eb4 <chHeapAllocAligned.constprop.41+0x84>
    heapp = &default_heap;
 8009e38:	4b3d      	ldr	r3, [pc, #244]	; (8009f30 <chHeapAllocAligned.constprop.41+0x100>)
 8009e3a:	4606      	mov	r6, r0
 8009e3c:	2800      	cmp	r0, #0
 8009e3e:	bf08      	it	eq
 8009e40:	461e      	moveq	r6, r3
  H_LOCK(heapp);
 8009e42:	f106 0710 	add.w	r7, r6, #16
 8009e46:	4638      	mov	r0, r7
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8009e48:	f101 0807 	add.w	r8, r1, #7
 8009e4c:	460d      	mov	r5, r1
  H_LOCK(heapp);
 8009e4e:	f7f7 fbbf 	bl	80015d0 <chMtxLock>
  qp = &heapp->header;
 8009e52:	f106 0108 	add.w	r1, r6, #8
  while (H_NEXT(qp) != NULL) {
 8009e56:	680b      	ldr	r3, [r1, #0]
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8009e58:	ea4f 08d8 	mov.w	r8, r8, lsr #3
  while (H_NEXT(qp) != NULL) {
 8009e5c:	b1c3      	cbz	r3, 8009e90 <chHeapAllocAligned.constprop.41+0x60>
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8009e5e:	f8d3 e004 	ldr.w	lr, [r3, #4]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8009e62:	f103 000f 	add.w	r0, r3, #15
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8009e66:	f10e 0201 	add.w	r2, lr, #1
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8009e6a:	f020 0007 	bic.w	r0, r0, #7
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8009e6e:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8009e72:	f1a0 0908 	sub.w	r9, r0, #8
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8009e76:	4591      	cmp	r9, r2
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8009e78:	f103 0c08 	add.w	ip, r3, #8
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8009e7c:	d204      	bcs.n	8009e88 <chHeapAllocAligned.constprop.41+0x58>
 8009e7e:	4604      	mov	r4, r0
 8009e80:	1a10      	subs	r0, r2, r0
 8009e82:	10c0      	asrs	r0, r0, #3
 8009e84:	4580      	cmp	r8, r0
 8009e86:	d918      	bls.n	8009eba <chHeapAllocAligned.constprop.41+0x8a>
          H_NEXT(qp) = fp;
 8009e88:	4619      	mov	r1, r3
  while (H_NEXT(qp) != NULL) {
 8009e8a:	680b      	ldr	r3, [r1, #0]
 8009e8c:	2b00      	cmp	r3, #0
 8009e8e:	d1e6      	bne.n	8009e5e <chHeapAllocAligned.constprop.41+0x2e>
  H_UNLOCK(heapp);
 8009e90:	4638      	mov	r0, r7
 8009e92:	f7f7 fb3d 	bl	8001510 <chMtxUnlock>
  if (heapp->provider != NULL) {
 8009e96:	6833      	ldr	r3, [r6, #0]
 8009e98:	2b00      	cmp	r3, #0
 8009e9a:	d045      	beq.n	8009f28 <chHeapAllocAligned.constprop.41+0xf8>
    hp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT, align);
 8009e9c:	f108 0001 	add.w	r0, r8, #1
 8009ea0:	00c0      	lsls	r0, r0, #3
 8009ea2:	2108      	movs	r1, #8
 8009ea4:	4798      	blx	r3
    if (hp != NULL) {
 8009ea6:	2800      	cmp	r0, #0
 8009ea8:	d03e      	beq.n	8009f28 <chHeapAllocAligned.constprop.41+0xf8>
      H_HEAP(hp) = heapp;
 8009eaa:	6006      	str	r6, [r0, #0]
      H_SIZE(hp) = size;
 8009eac:	6045      	str	r5, [r0, #4]
      return (void *)H_BLOCK(hp);
 8009eae:	3008      	adds	r0, #8
}
 8009eb0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
 8009eb4:	481f      	ldr	r0, [pc, #124]	; (8009f34 <chHeapAllocAligned.constprop.41+0x104>)
 8009eb6:	f7f6 fcb3 	bl	8000820 <chSysHalt>
      if (ahp > hp) {
 8009eba:	454b      	cmp	r3, r9
 8009ebc:	d31c      	bcc.n	8009ef8 <chHeapAllocAligned.constprop.41+0xc8>
        if (H_PAGES(hp) == pages) {
 8009ebe:	45f0      	cmp	r8, lr
 8009ec0:	d02d      	beq.n	8009f1e <chHeapAllocAligned.constprop.41+0xee>
          fp = H_BLOCK(hp) + pages;
 8009ec2:	f108 0801 	add.w	r8, r8, #1
 8009ec6:	eb03 0ec8 	add.w	lr, r3, r8, lsl #3
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8009eca:	f10e 0008 	add.w	r0, lr, #8
 8009ece:	1a12      	subs	r2, r2, r0
 8009ed0:	10d2      	asrs	r2, r2, #3
          H_NEXT(fp) = H_NEXT(hp);
 8009ed2:	6818      	ldr	r0, [r3, #0]
 8009ed4:	f843 0038 	str.w	r0, [r3, r8, lsl #3]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8009ed8:	4664      	mov	r4, ip
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8009eda:	f8ce 2004 	str.w	r2, [lr, #4]
          H_NEXT(qp) = fp;
 8009ede:	4699      	mov	r9, r3
 8009ee0:	f8c1 e000 	str.w	lr, [r1]
      H_UNLOCK(heapp);
 8009ee4:	4638      	mov	r0, r7
      H_SIZE(hp) = size;
 8009ee6:	f8c9 5004 	str.w	r5, [r9, #4]
      H_HEAP(hp) = heapp;
 8009eea:	f8c9 6000 	str.w	r6, [r9]
      H_UNLOCK(heapp);
 8009eee:	f7f7 fb0f 	bl	8001510 <chMtxUnlock>
      return (void *)H_BLOCK(hp);
 8009ef2:	4620      	mov	r0, r4
 8009ef4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8009ef8:	eba9 020c 	sub.w	r2, r9, ip
 8009efc:	10d2      	asrs	r2, r2, #3
        if (bpages > pages) {
 8009efe:	4580      	cmp	r8, r0
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8009f00:	605a      	str	r2, [r3, #4]
        if (bpages > pages) {
 8009f02:	d2ef      	bcs.n	8009ee4 <chHeapAllocAligned.constprop.41+0xb4>
          fp = H_BLOCK(ahp) + pages;
 8009f04:	f108 0e01 	add.w	lr, r8, #1
 8009f08:	eb09 02ce 	add.w	r2, r9, lr, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 8009f0c:	ea6f 0808 	mvn.w	r8, r8
 8009f10:	4440      	add	r0, r8
 8009f12:	6050      	str	r0, [r2, #4]
          H_NEXT(fp) = H_NEXT(hp);
 8009f14:	6819      	ldr	r1, [r3, #0]
 8009f16:	f849 103e 	str.w	r1, [r9, lr, lsl #3]
          H_NEXT(hp) = fp;
 8009f1a:	601a      	str	r2, [r3, #0]
 8009f1c:	e7e2      	b.n	8009ee4 <chHeapAllocAligned.constprop.41+0xb4>
          H_NEXT(qp) = H_NEXT(hp);
 8009f1e:	681a      	ldr	r2, [r3, #0]
 8009f20:	600a      	str	r2, [r1, #0]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8009f22:	4664      	mov	r4, ip
          H_NEXT(qp) = H_NEXT(hp);
 8009f24:	4699      	mov	r9, r3
 8009f26:	e7dd      	b.n	8009ee4 <chHeapAllocAligned.constprop.41+0xb4>
  return NULL;
 8009f28:	2000      	movs	r0, #0
 8009f2a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009f2e:	bf00      	nop
 8009f30:	200026f0 	.word	0x200026f0
 8009f34:	0800c564 	.word	0x0800c564
	...

08009f40 <chMBResetI.constprop.35>:
void chMBResetI(mailbox_t *mbp) {
 8009f40:	b510      	push	{r4, lr}
  mbp->wrptr = mbp->buffer;
 8009f42:	4c0a      	ldr	r4, [pc, #40]	; (8009f6c <chMBResetI.constprop.35+0x2c>)
  chDbgCheckClassI();
 8009f44:	f7f6 fcbc 	bl	80008c0 <chDbgCheckClassI>
  mbp->wrptr = mbp->buffer;
 8009f48:	6823      	ldr	r3, [r4, #0]
 8009f4a:	60a3      	str	r3, [r4, #8]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8009f4c:	f104 0018 	add.w	r0, r4, #24
  mbp->cnt   = (cnt_t)0;
 8009f50:	2100      	movs	r1, #0
  mbp->reset = true;
 8009f52:	2201      	movs	r2, #1
  mbp->cnt   = (cnt_t)0;
 8009f54:	6121      	str	r1, [r4, #16]
  mbp->reset = true;
 8009f56:	7522      	strb	r2, [r4, #20]
  mbp->rdptr = mbp->buffer;
 8009f58:	60e3      	str	r3, [r4, #12]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8009f5a:	f7ff ff29 	bl	8009db0 <chThdDequeueAllI.constprop.68>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8009f5e:	f104 0020 	add.w	r0, r4, #32
}
 8009f62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8009f66:	f7ff bf23 	b.w	8009db0 <chThdDequeueAllI.constprop.68>
 8009f6a:	bf00      	nop
 8009f6c:	20000c60 	.word	0x20000c60

08009f70 <chThdCreateStatic.constprop.72>:
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8009f70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009f72:	b085      	sub	sp, #20
  chDbgCheck((wsp != NULL) &&
 8009f74:	b110      	cbz	r0, 8009f7c <chThdCreateStatic.constprop.72+0xc>
 8009f76:	0745      	lsls	r5, r0, #29
 8009f78:	4604      	mov	r4, r0
 8009f7a:	d002      	beq.n	8009f82 <chThdCreateStatic.constprop.72+0x12>
 8009f7c:	4837      	ldr	r0, [pc, #220]	; (800a05c <chThdCreateStatic.constprop.72+0xec>)
 8009f7e:	f7f6 fc4f 	bl	8000820 <chSysHalt>
 8009f82:	29ff      	cmp	r1, #255	; 0xff
 8009f84:	d8fa      	bhi.n	8009f7c <chThdCreateStatic.constprop.72+0xc>
 8009f86:	2a00      	cmp	r2, #0
 8009f88:	d0f8      	beq.n	8009f7c <chThdCreateStatic.constprop.72+0xc>
 8009f8a:	9303      	str	r3, [sp, #12]
 8009f8c:	9202      	str	r2, [sp, #8]
 8009f8e:	9101      	str	r1, [sp, #4]
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8009f90:	f7f7 fd4e 	bl	8001a30 <chRegFindThreadByWorkingArea>
 8009f94:	a901      	add	r1, sp, #4
 8009f96:	c90e      	ldmia	r1, {r1, r2, r3}
 8009f98:	2800      	cmp	r0, #0
 8009f9a:	d1ef      	bne.n	8009f7c <chThdCreateStatic.constprop.72+0xc>
  _thread_memfill((uint8_t *)wsp,
 8009f9c:	f504 76a4 	add.w	r6, r4, #328	; 0x148
 8009fa0:	4620      	mov	r0, r4
    *startp++ = v;
 8009fa2:	2555      	movs	r5, #85	; 0x55
 8009fa4:	f800 5b01 	strb.w	r5, [r0], #1
  while (startp < endp) {
 8009fa8:	4286      	cmp	r6, r0
 8009faa:	d1fb      	bne.n	8009fa4 <chThdCreateStatic.constprop.72+0x34>
 8009fac:	9303      	str	r3, [sp, #12]
 8009fae:	9202      	str	r2, [sp, #8]
 8009fb0:	9101      	str	r1, [sp, #4]
 8009fb2:	2020      	movs	r0, #32
 8009fb4:	f380 8811 	msr	BASEPRI, r0
  REG_INSERT(tp);
 8009fb8:	4d29      	ldr	r5, [pc, #164]	; (800a060 <chThdCreateStatic.constprop.72+0xf0>)
  tp->name      = name;
 8009fba:	4f2a      	ldr	r7, [pc, #168]	; (800a064 <chThdCreateStatic.constprop.72+0xf4>)
 8009fbc:	f7f7 f950 	bl	8001260 <_dbg_check_lock>
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8009fc0:	9a02      	ldr	r2, [sp, #8]
 8009fc2:	9b03      	ldr	r3, [sp, #12]
  REG_INSERT(tp);
 8009fc4:	6968      	ldr	r0, [r5, #20]
  tp->prio      = prio;
 8009fc6:	9901      	ldr	r1, [sp, #4]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8009fc8:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
 8009fcc:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 8009fd0:	f104 06dc 	add.w	r6, r4, #220	; 0xdc
  tp->state     = CH_STATE_WTSTART;
 8009fd4:	2202      	movs	r2, #2
  tp->refs      = (trefs_t)1;
 8009fd6:	2301      	movs	r3, #1
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8009fd8:	f8df e090 	ldr.w	lr, [pc, #144]	; 800a06c <chThdCreateStatic.constprop.72+0xfc>
  tp->prio      = prio;
 8009fdc:	f8c4 1108 	str.w	r1, [r4, #264]	; 0x108
  tp->realprio  = prio;
 8009fe0:	f8c4 113c 	str.w	r1, [r4, #316]	; 0x13c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8009fe4:	f8c4 610c 	str.w	r6, [r4, #268]	; 0x10c
  tp->flags     = CH_FLAG_MODE_STATIC;
 8009fe8:	2100      	movs	r1, #0
  tp = (thread_t *)((uint8_t *)wsp + size -
 8009fea:	f504 7680 	add.w	r6, r4, #256	; 0x100
  tp->state     = CH_STATE_WTSTART;
 8009fee:	f884 2120 	strb.w	r2, [r4, #288]	; 0x120
  tp->refs      = (trefs_t)1;
 8009ff2:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
  list_init(&tp->waiting);
 8009ff6:	f504 7294 	add.w	r2, r4, #296	; 0x128
  queue_init(&tp->msgqueue);
 8009ffa:	f504 7396 	add.w	r3, r4, #300	; 0x12c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8009ffe:	f8c4 e0fc 	str.w	lr, [r4, #252]	; 0xfc
  tp->flags     = CH_FLAG_MODE_STATIC;
 800a002:	f884 1121 	strb.w	r1, [r4, #289]	; 0x121
  tp->mtxlist   = NULL;
 800a006:	f8c4 1138 	str.w	r1, [r4, #312]	; 0x138
  tp->epending  = (eventmask_t)0;
 800a00a:	f8c4 1134 	str.w	r1, [r4, #308]	; 0x134
  REG_INSERT(tp);
 800a00e:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
  tp->wabase = (stkalign_t *)wsp;
 800a012:	f8c4 411c 	str.w	r4, [r4, #284]	; 0x11c
  tp->name      = name;
 800a016:	f8c4 7118 	str.w	r7, [r4, #280]	; 0x118
  REG_INSERT(tp);
 800a01a:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
 800a01e:	6106      	str	r6, [r0, #16]
  tqp->next = (thread_t *)tqp;
 800a020:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
 800a024:	f8c4 3130 	str.w	r3, [r4, #304]	; 0x130
  chSchWakeupS(tp, MSG_OK);
 800a028:	4630      	mov	r0, r6
  tlp->next = (thread_t *)tlp;
 800a02a:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
  REG_INSERT(tp);
 800a02e:	616e      	str	r6, [r5, #20]
  chSchWakeupS(tp, MSG_OK);
 800a030:	f7f6 fe8e 	bl	8000d50 <chSchWakeupS>
  _dbg_check_unlock();
 800a034:	f7f7 f8ec 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a038:	682b      	ldr	r3, [r5, #0]
 800a03a:	42ab      	cmp	r3, r5
 800a03c:	d004      	beq.n	800a048 <chThdCreateStatic.constprop.72+0xd8>
 800a03e:	69aa      	ldr	r2, [r5, #24]
 800a040:	689b      	ldr	r3, [r3, #8]
 800a042:	6892      	ldr	r2, [r2, #8]
 800a044:	429a      	cmp	r2, r3
 800a046:	d305      	bcc.n	800a054 <chThdCreateStatic.constprop.72+0xe4>
 800a048:	2300      	movs	r3, #0
 800a04a:	f383 8811 	msr	BASEPRI, r3
}
 800a04e:	4630      	mov	r0, r6
 800a050:	b005      	add	sp, #20
 800a052:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a054:	4804      	ldr	r0, [pc, #16]	; (800a068 <chThdCreateStatic.constprop.72+0xf8>)
 800a056:	f7f6 fbe3 	bl	8000820 <chSysHalt>
 800a05a:	bf00      	nop
 800a05c:	0800c578 	.word	0x0800c578
 800a060:	20001e68 	.word	0x20001e68
 800a064:	0800c5ac 	.word	0x0800c5ac
 800a068:	0800c508 	.word	0x0800c508
 800a06c:	080002a5 	.word	0x080002a5

0800a070 <chSemSignalWait.constprop.65>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 800a070:	b570      	push	{r4, r5, r6, lr}
  msg_t msg;

  chDbgCheck((sps != NULL) && (spw != NULL));
  chDbgAssert(((sps->cnt >= (cnt_t)0) && queue_isempty(&sps->queue)) ||
 800a072:	4c23      	ldr	r4, [pc, #140]	; (800a100 <chSemSignalWait.constprop.65+0x90>)
 800a074:	68a3      	ldr	r3, [r4, #8]
 800a076:	2b00      	cmp	r3, #0
 800a078:	6823      	ldr	r3, [r4, #0]
 800a07a:	db04      	blt.n	800a086 <chSemSignalWait.constprop.65+0x16>
 800a07c:	42a3      	cmp	r3, r4
 800a07e:	d004      	beq.n	800a08a <chSemSignalWait.constprop.65+0x1a>
 800a080:	4820      	ldr	r0, [pc, #128]	; (800a104 <chSemSignalWait.constprop.65+0x94>)
 800a082:	f7f6 fbcd 	bl	8000820 <chSysHalt>
 800a086:	42a3      	cmp	r3, r4
 800a088:	d0fa      	beq.n	800a080 <chSemSignalWait.constprop.65+0x10>
 800a08a:	2320      	movs	r3, #32
 800a08c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a090:	f7f7 f8e6 	bl	8001260 <_dbg_check_lock>
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
 800a094:	68a3      	ldr	r3, [r4, #8]
 800a096:	3301      	adds	r3, #1
 800a098:	2b00      	cmp	r3, #0
 800a09a:	60a3      	str	r3, [r4, #8]
 800a09c:	dd26      	ble.n	800a0ec <chSemSignalWait.constprop.65+0x7c>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
 800a09e:	3b01      	subs	r3, #1
 800a0a0:	2b00      	cmp	r3, #0
 800a0a2:	60a3      	str	r3, [r4, #8]
 800a0a4:	db15      	blt.n	800a0d2 <chSemSignalWait.constprop.65+0x62>
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
 800a0a6:	f7f6 fcbb 	bl	8000a20 <chSchRescheduleS>
 800a0aa:	4d17      	ldr	r5, [pc, #92]	; (800a108 <chSemSignalWait.constprop.65+0x98>)
    msg = MSG_OK;
 800a0ac:	2400      	movs	r4, #0
  _dbg_check_unlock();
 800a0ae:	f7f7 f8af 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a0b2:	682b      	ldr	r3, [r5, #0]
 800a0b4:	42ab      	cmp	r3, r5
 800a0b6:	d004      	beq.n	800a0c2 <chSemSignalWait.constprop.65+0x52>
 800a0b8:	69aa      	ldr	r2, [r5, #24]
 800a0ba:	689b      	ldr	r3, [r3, #8]
 800a0bc:	6892      	ldr	r2, [r2, #8]
 800a0be:	429a      	cmp	r2, r3
 800a0c0:	d304      	bcc.n	800a0cc <chSemSignalWait.constprop.65+0x5c>
 800a0c2:	2300      	movs	r3, #0
 800a0c4:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 800a0c8:	4620      	mov	r0, r4
 800a0ca:	bd70      	pop	{r4, r5, r6, pc}
 800a0cc:	480f      	ldr	r0, [pc, #60]	; (800a10c <chSemSignalWait.constprop.65+0x9c>)
 800a0ce:	f7f6 fba7 	bl	8000820 <chSysHalt>
    thread_t *ctp = currp;
 800a0d2:	4d0d      	ldr	r5, [pc, #52]	; (800a108 <chSemSignalWait.constprop.65+0x98>)
  tp->queue.prev             = tqp->prev;
 800a0d4:	6863      	ldr	r3, [r4, #4]
 800a0d6:	69ae      	ldr	r6, [r5, #24]
    chSchGoSleepS(CH_STATE_WTSEM);
 800a0d8:	2005      	movs	r0, #5
  tp->queue.next             = (thread_t *)tqp;
 800a0da:	6034      	str	r4, [r6, #0]
  tp->queue.prev             = tqp->prev;
 800a0dc:	6073      	str	r3, [r6, #4]
  tp->queue.prev->queue.next = tp;
 800a0de:	601e      	str	r6, [r3, #0]
    ctp->u.wtsemp = spw;
 800a0e0:	6274      	str	r4, [r6, #36]	; 0x24
  tqp->prev                  = tp;
 800a0e2:	6066      	str	r6, [r4, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 800a0e4:	f7f6 fbc4 	bl	8000870 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 800a0e8:	6a74      	ldr	r4, [r6, #36]	; 0x24
 800a0ea:	e7e0      	b.n	800a0ae <chSemSignalWait.constprop.65+0x3e>
  thread_t *tp = tqp->next;
 800a0ec:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 800a0ee:	6803      	ldr	r3, [r0, #0]
 800a0f0:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800a0f2:	605c      	str	r4, [r3, #4]
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 800a0f4:	f7f6 fcac 	bl	8000a50 <chSchReadyI>
 800a0f8:	2200      	movs	r2, #0
 800a0fa:	68a3      	ldr	r3, [r4, #8]
 800a0fc:	6242      	str	r2, [r0, #36]	; 0x24
 800a0fe:	e7ce      	b.n	800a09e <chSemSignalWait.constprop.65+0x2e>
 800a100:	2000272c 	.word	0x2000272c
 800a104:	0800c58c 	.word	0x0800c58c
 800a108:	20001e68 	.word	0x20001e68
 800a10c:	0800c514 	.word	0x0800c514

0800a110 <chMtxTryLock.constprop.62>:
bool chMtxTryLock(mutex_t *mp) {
 800a110:	b538      	push	{r3, r4, r5, lr}
 800a112:	2320      	movs	r3, #32
 800a114:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a118:	f7f7 f8a2 	bl	8001260 <_dbg_check_lock>
  chDbgCheckClassS();
 800a11c:	f7f6 fb98 	bl	8000850 <chDbgCheckClassS>
  if (mp->owner != NULL) {
 800a120:	4b0e      	ldr	r3, [pc, #56]	; (800a15c <chMtxTryLock.constprop.62+0x4c>)
 800a122:	4c0f      	ldr	r4, [pc, #60]	; (800a160 <chMtxTryLock.constprop.62+0x50>)
 800a124:	689a      	ldr	r2, [r3, #8]
 800a126:	b192      	cbz	r2, 800a14e <chMtxTryLock.constprop.62+0x3e>
    return false;
 800a128:	2500      	movs	r5, #0
  _dbg_check_unlock();
 800a12a:	f7f7 f871 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a12e:	6823      	ldr	r3, [r4, #0]
 800a130:	42a3      	cmp	r3, r4
 800a132:	d004      	beq.n	800a13e <chMtxTryLock.constprop.62+0x2e>
 800a134:	69a2      	ldr	r2, [r4, #24]
 800a136:	689b      	ldr	r3, [r3, #8]
 800a138:	6892      	ldr	r2, [r2, #8]
 800a13a:	429a      	cmp	r2, r3
 800a13c:	d304      	bcc.n	800a148 <chMtxTryLock.constprop.62+0x38>
 800a13e:	2300      	movs	r3, #0
 800a140:	f383 8811 	msr	BASEPRI, r3
}
 800a144:	4628      	mov	r0, r5
 800a146:	bd38      	pop	{r3, r4, r5, pc}
 800a148:	4806      	ldr	r0, [pc, #24]	; (800a164 <chMtxTryLock.constprop.62+0x54>)
 800a14a:	f7f6 fb69 	bl	8000820 <chSysHalt>
  mp->owner = currp;
 800a14e:	69a2      	ldr	r2, [r4, #24]
 800a150:	609a      	str	r2, [r3, #8]
  mp->next = currp->mtxlist;
 800a152:	6b91      	ldr	r1, [r2, #56]	; 0x38
 800a154:	60d9      	str	r1, [r3, #12]
  currp->mtxlist = mp;
 800a156:	6393      	str	r3, [r2, #56]	; 0x38
 800a158:	2501      	movs	r5, #1
 800a15a:	e7e6      	b.n	800a12a <chMtxTryLock.constprop.62+0x1a>
 800a15c:	20000c50 	.word	0x20000c50
 800a160:	20001e68 	.word	0x20001e68
 800a164:	0800c520 	.word	0x0800c520
	...

0800a170 <chCondSignal.constprop.60>:
void chCondSignal(condition_variable_t *cp) {
 800a170:	b508      	push	{r3, lr}
 800a172:	2320      	movs	r3, #32
 800a174:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a178:	f7f7 f872 	bl	8001260 <_dbg_check_lock>
  return (bool)(tqp->next != (const thread_t *)tqp);
 800a17c:	4b0d      	ldr	r3, [pc, #52]	; (800a1b4 <chCondSignal.constprop.60+0x44>)
 800a17e:	6818      	ldr	r0, [r3, #0]
  if (queue_notempty(&cp->queue)) {
 800a180:	4298      	cmp	r0, r3
 800a182:	d005      	beq.n	800a190 <chCondSignal.constprop.60+0x20>
  tqp->next             = tp->queue.next;
 800a184:	6802      	ldr	r2, [r0, #0]
 800a186:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800a188:	6053      	str	r3, [r2, #4]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 800a18a:	2100      	movs	r1, #0
 800a18c:	f7f6 fde0 	bl	8000d50 <chSchWakeupS>
  _dbg_check_unlock();
 800a190:	f7f7 f83e 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a194:	4b08      	ldr	r3, [pc, #32]	; (800a1b8 <chCondSignal.constprop.60+0x48>)
 800a196:	681a      	ldr	r2, [r3, #0]
 800a198:	429a      	cmp	r2, r3
 800a19a:	d004      	beq.n	800a1a6 <chCondSignal.constprop.60+0x36>
 800a19c:	6999      	ldr	r1, [r3, #24]
 800a19e:	6893      	ldr	r3, [r2, #8]
 800a1a0:	688a      	ldr	r2, [r1, #8]
 800a1a2:	429a      	cmp	r2, r3
 800a1a4:	d303      	bcc.n	800a1ae <chCondSignal.constprop.60+0x3e>
 800a1a6:	2300      	movs	r3, #0
 800a1a8:	f383 8811 	msr	BASEPRI, r3
 800a1ac:	bd08      	pop	{r3, pc}
 800a1ae:	4803      	ldr	r0, [pc, #12]	; (800a1bc <chCondSignal.constprop.60+0x4c>)
 800a1b0:	f7f6 fb36 	bl	8000820 <chSysHalt>
 800a1b4:	20000c48 	.word	0x20000c48
 800a1b8:	20001e68 	.word	0x20001e68
 800a1bc:	0800c52c 	.word	0x0800c52c

0800a1c0 <chEvtGetAndClearEvents.constprop.51>:
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 800a1c0:	b538      	push	{r3, r4, r5, lr}
 800a1c2:	2320      	movs	r3, #32
 800a1c4:	f383 8811 	msr	BASEPRI, r3
  m = currp->epending & events;
 800a1c8:	4c0c      	ldr	r4, [pc, #48]	; (800a1fc <chEvtGetAndClearEvents.constprop.51+0x3c>)
  _dbg_check_lock();
 800a1ca:	f7f7 f849 	bl	8001260 <_dbg_check_lock>
 800a1ce:	69a3      	ldr	r3, [r4, #24]
  currp->epending &= ~events;
 800a1d0:	2200      	movs	r2, #0
  m = currp->epending & events;
 800a1d2:	6b5d      	ldr	r5, [r3, #52]	; 0x34
  currp->epending &= ~events;
 800a1d4:	635a      	str	r2, [r3, #52]	; 0x34
  _dbg_check_unlock();
 800a1d6:	f7f7 f81b 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a1da:	6823      	ldr	r3, [r4, #0]
 800a1dc:	42a3      	cmp	r3, r4
 800a1de:	d004      	beq.n	800a1ea <chEvtGetAndClearEvents.constprop.51+0x2a>
 800a1e0:	69a2      	ldr	r2, [r4, #24]
 800a1e2:	689b      	ldr	r3, [r3, #8]
 800a1e4:	6892      	ldr	r2, [r2, #8]
 800a1e6:	429a      	cmp	r2, r3
 800a1e8:	d304      	bcc.n	800a1f4 <chEvtGetAndClearEvents.constprop.51+0x34>
 800a1ea:	2300      	movs	r3, #0
 800a1ec:	f383 8811 	msr	BASEPRI, r3
}
 800a1f0:	4628      	mov	r0, r5
 800a1f2:	bd38      	pop	{r3, r4, r5, pc}
 800a1f4:	4802      	ldr	r0, [pc, #8]	; (800a200 <chEvtGetAndClearEvents.constprop.51+0x40>)
 800a1f6:	f7f6 fb13 	bl	8000820 <chSysHalt>
 800a1fa:	bf00      	nop
 800a1fc:	20001e68 	.word	0x20001e68
 800a200:	0800c538 	.word	0x0800c538
	...

0800a210 <chEvtWaitOne.constprop.47>:
eventmask_t chEvtWaitOne(eventmask_t events) {
 800a210:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 800a212:	4c13      	ldr	r4, [pc, #76]	; (800a260 <chEvtWaitOne.constprop.47+0x50>)
 800a214:	2320      	movs	r3, #32
 800a216:	69a6      	ldr	r6, [r4, #24]
 800a218:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a21c:	f7f7 f820 	bl	8001260 <_dbg_check_lock>
  m = ctp->epending & events;
 800a220:	6b73      	ldr	r3, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800a222:	b933      	cbnz	r3, 800a232 <chEvtWaitOne.constprop.47+0x22>
    ctp->u.ewmask = events;
 800a224:	f04f 33ff 	mov.w	r3, #4294967295
 800a228:	6273      	str	r3, [r6, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 800a22a:	200a      	movs	r0, #10
 800a22c:	f7f6 fb20 	bl	8000870 <chSchGoSleepS>
    m = ctp->epending & events;
 800a230:	6b73      	ldr	r3, [r6, #52]	; 0x34
  m ^= m & (m - (eventmask_t)1);
 800a232:	425d      	negs	r5, r3
 800a234:	401d      	ands	r5, r3
  ctp->epending &= ~m;
 800a236:	ea23 0305 	bic.w	r3, r3, r5
 800a23a:	6373      	str	r3, [r6, #52]	; 0x34
  _dbg_check_unlock();
 800a23c:	f7f6 ffe8 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a240:	6823      	ldr	r3, [r4, #0]
 800a242:	42a3      	cmp	r3, r4
 800a244:	d004      	beq.n	800a250 <chEvtWaitOne.constprop.47+0x40>
 800a246:	69a2      	ldr	r2, [r4, #24]
 800a248:	689b      	ldr	r3, [r3, #8]
 800a24a:	6892      	ldr	r2, [r2, #8]
 800a24c:	429a      	cmp	r2, r3
 800a24e:	d304      	bcc.n	800a25a <chEvtWaitOne.constprop.47+0x4a>
 800a250:	2300      	movs	r3, #0
 800a252:	f383 8811 	msr	BASEPRI, r3
}
 800a256:	4628      	mov	r0, r5
 800a258:	bd70      	pop	{r4, r5, r6, pc}
 800a25a:	4802      	ldr	r0, [pc, #8]	; (800a264 <chEvtWaitOne.constprop.47+0x54>)
 800a25c:	f7f6 fae0 	bl	8000820 <chSysHalt>
 800a260:	20001e68 	.word	0x20001e68
 800a264:	0800c538 	.word	0x0800c538
	...

0800a270 <chEvtWaitAny.constprop.46>:
eventmask_t chEvtWaitAny(eventmask_t events) {
 800a270:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 800a272:	4c12      	ldr	r4, [pc, #72]	; (800a2bc <chEvtWaitAny.constprop.46+0x4c>)
 800a274:	2320      	movs	r3, #32
 800a276:	69a5      	ldr	r5, [r4, #24]
 800a278:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a27c:	f7f6 fff0 	bl	8001260 <_dbg_check_lock>
  m = ctp->epending & events;
 800a280:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800a282:	b936      	cbnz	r6, 800a292 <chEvtWaitAny.constprop.46+0x22>
    ctp->u.ewmask = events;
 800a284:	f04f 33ff 	mov.w	r3, #4294967295
 800a288:	626b      	str	r3, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 800a28a:	200a      	movs	r0, #10
 800a28c:	f7f6 faf0 	bl	8000870 <chSchGoSleepS>
    m = ctp->epending & events;
 800a290:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  ctp->epending &= ~m;
 800a292:	2300      	movs	r3, #0
 800a294:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
 800a296:	f7f6 ffbb 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a29a:	6823      	ldr	r3, [r4, #0]
 800a29c:	42a3      	cmp	r3, r4
 800a29e:	d004      	beq.n	800a2aa <chEvtWaitAny.constprop.46+0x3a>
 800a2a0:	69a2      	ldr	r2, [r4, #24]
 800a2a2:	689b      	ldr	r3, [r3, #8]
 800a2a4:	6892      	ldr	r2, [r2, #8]
 800a2a6:	429a      	cmp	r2, r3
 800a2a8:	d304      	bcc.n	800a2b4 <chEvtWaitAny.constprop.46+0x44>
 800a2aa:	2300      	movs	r3, #0
 800a2ac:	f383 8811 	msr	BASEPRI, r3
}
 800a2b0:	4630      	mov	r0, r6
 800a2b2:	bd70      	pop	{r4, r5, r6, pc}
 800a2b4:	4802      	ldr	r0, [pc, #8]	; (800a2c0 <chEvtWaitAny.constprop.46+0x50>)
 800a2b6:	f7f6 fab3 	bl	8000820 <chSysHalt>
 800a2ba:	bf00      	nop
 800a2bc:	20001e68 	.word	0x20001e68
 800a2c0:	0800c538 	.word	0x0800c538
	...

0800a2d0 <chEvtWaitAll.constprop.45>:
eventmask_t chEvtWaitAll(eventmask_t events) {
 800a2d0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 800a2d2:	4c13      	ldr	r4, [pc, #76]	; (800a320 <chEvtWaitAll.constprop.45+0x50>)
 800a2d4:	2320      	movs	r3, #32
 800a2d6:	69a5      	ldr	r5, [r4, #24]
 800a2d8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a2dc:	f7f6 ffc0 	bl	8001260 <_dbg_check_lock>
  if ((ctp->epending & events) != events) {
 800a2e0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800a2e2:	f003 0205 	and.w	r2, r3, #5
 800a2e6:	2a05      	cmp	r2, #5
 800a2e8:	d005      	beq.n	800a2f6 <chEvtWaitAll.constprop.45+0x26>
    ctp->u.ewmask = events;
 800a2ea:	2305      	movs	r3, #5
 800a2ec:	626b      	str	r3, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 800a2ee:	200b      	movs	r0, #11
 800a2f0:	f7f6 fabe 	bl	8000870 <chSchGoSleepS>
 800a2f4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  ctp->epending &= ~events;
 800a2f6:	f023 0305 	bic.w	r3, r3, #5
 800a2fa:	636b      	str	r3, [r5, #52]	; 0x34
  _dbg_check_unlock();
 800a2fc:	f7f6 ff88 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a300:	6823      	ldr	r3, [r4, #0]
 800a302:	42a3      	cmp	r3, r4
 800a304:	d004      	beq.n	800a310 <chEvtWaitAll.constprop.45+0x40>
 800a306:	69a2      	ldr	r2, [r4, #24]
 800a308:	689b      	ldr	r3, [r3, #8]
 800a30a:	6892      	ldr	r2, [r2, #8]
 800a30c:	429a      	cmp	r2, r3
 800a30e:	d304      	bcc.n	800a31a <chEvtWaitAll.constprop.45+0x4a>
 800a310:	2300      	movs	r3, #0
 800a312:	f383 8811 	msr	BASEPRI, r3
}
 800a316:	2005      	movs	r0, #5
 800a318:	bd38      	pop	{r3, r4, r5, pc}
 800a31a:	4802      	ldr	r0, [pc, #8]	; (800a324 <chEvtWaitAll.constprop.45+0x54>)
 800a31c:	f7f6 fa80 	bl	8000820 <chSysHalt>
 800a320:	20001e68 	.word	0x20001e68
 800a324:	0800c538 	.word	0x0800c538
	...

0800a330 <chEvtWaitOneTimeout.constprop.44>:
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 800a330:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 800a332:	4c1d      	ldr	r4, [pc, #116]	; (800a3a8 <chEvtWaitOneTimeout.constprop.44+0x78>)
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 800a334:	4605      	mov	r5, r0
  thread_t *ctp = currp;
 800a336:	69a6      	ldr	r6, [r4, #24]
 800a338:	2320      	movs	r3, #32
 800a33a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a33e:	f7f6 ff8f 	bl	8001260 <_dbg_check_lock>
  m = ctp->epending & events;
 800a342:	6b73      	ldr	r3, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800a344:	b953      	cbnz	r3, 800a35c <chEvtWaitOneTimeout.constprop.44+0x2c>
    if (TIME_IMMEDIATE == time) {
 800a346:	b1ed      	cbz	r5, 800a384 <chEvtWaitOneTimeout.constprop.44+0x54>
    ctp->u.ewmask = events;
 800a348:	f04f 33ff 	mov.w	r3, #4294967295
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 800a34c:	4629      	mov	r1, r5
    ctp->u.ewmask = events;
 800a34e:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 800a350:	200a      	movs	r0, #10
 800a352:	f7f6 fded 	bl	8000f30 <chSchGoSleepTimeoutS>
 800a356:	2800      	cmp	r0, #0
 800a358:	db14      	blt.n	800a384 <chEvtWaitOneTimeout.constprop.44+0x54>
    m = ctp->epending & events;
 800a35a:	6b73      	ldr	r3, [r6, #52]	; 0x34
  m ^= m & (m - (eventmask_t)1);
 800a35c:	425d      	negs	r5, r3
 800a35e:	401d      	ands	r5, r3
  ctp->epending &= ~m;
 800a360:	ea23 0305 	bic.w	r3, r3, r5
 800a364:	6373      	str	r3, [r6, #52]	; 0x34
  _dbg_check_unlock();
 800a366:	f7f6 ff53 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a36a:	6823      	ldr	r3, [r4, #0]
 800a36c:	42a3      	cmp	r3, r4
 800a36e:	d004      	beq.n	800a37a <chEvtWaitOneTimeout.constprop.44+0x4a>
 800a370:	69a2      	ldr	r2, [r4, #24]
 800a372:	689b      	ldr	r3, [r3, #8]
 800a374:	6892      	ldr	r2, [r2, #8]
 800a376:	429a      	cmp	r2, r3
 800a378:	d313      	bcc.n	800a3a2 <chEvtWaitOneTimeout.constprop.44+0x72>
 800a37a:	2300      	movs	r3, #0
 800a37c:	f383 8811 	msr	BASEPRI, r3
}
 800a380:	4628      	mov	r0, r5
 800a382:	bd70      	pop	{r4, r5, r6, pc}
  _dbg_check_unlock();
 800a384:	f7f6 ff44 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a388:	6823      	ldr	r3, [r4, #0]
 800a38a:	42a3      	cmp	r3, r4
 800a38c:	d004      	beq.n	800a398 <chEvtWaitOneTimeout.constprop.44+0x68>
 800a38e:	69a2      	ldr	r2, [r4, #24]
 800a390:	689b      	ldr	r3, [r3, #8]
 800a392:	6892      	ldr	r2, [r2, #8]
 800a394:	429a      	cmp	r2, r3
 800a396:	d304      	bcc.n	800a3a2 <chEvtWaitOneTimeout.constprop.44+0x72>
 800a398:	2500      	movs	r5, #0
 800a39a:	f385 8811 	msr	BASEPRI, r5
 800a39e:	4628      	mov	r0, r5
 800a3a0:	bd70      	pop	{r4, r5, r6, pc}
 800a3a2:	4802      	ldr	r0, [pc, #8]	; (800a3ac <chEvtWaitOneTimeout.constprop.44+0x7c>)
 800a3a4:	f7f6 fa3c 	bl	8000820 <chSysHalt>
 800a3a8:	20001e68 	.word	0x20001e68
 800a3ac:	0800c538 	.word	0x0800c538

0800a3b0 <chThdCreateFromMemoryPool.constprop.40>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 800a3b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 800a3b2:	4d20      	ldr	r5, [pc, #128]	; (800a434 <chThdCreateFromMemoryPool.constprop.40+0x84>)
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 800a3b4:	b087      	sub	sp, #28
 800a3b6:	4607      	mov	r7, r0
  wsp = chPoolAlloc(mp);
 800a3b8:	4628      	mov	r0, r5
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 800a3ba:	460e      	mov	r6, r1
 800a3bc:	4614      	mov	r4, r2
  wsp = chPoolAlloc(mp);
 800a3be:	f7fa fc97 	bl	8004cf0 <chPoolAlloc>
  if (wsp == NULL) {
 800a3c2:	2800      	cmp	r0, #0
 800a3c4:	d034      	beq.n	800a430 <chThdCreateFromMemoryPool.constprop.40+0x80>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 800a3c6:	686b      	ldr	r3, [r5, #4]
  thread_descriptor_t td = {
 800a3c8:	4a1b      	ldr	r2, [pc, #108]	; (800a438 <chThdCreateFromMemoryPool.constprop.40+0x88>)
 800a3ca:	9204      	str	r2, [sp, #16]
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 800a3cc:	4403      	add	r3, r0
  while (startp < endp) {
 800a3ce:	4298      	cmp	r0, r3
  thread_descriptor_t td = {
 800a3d0:	9700      	str	r7, [sp, #0]
 800a3d2:	9001      	str	r0, [sp, #4]
 800a3d4:	9603      	str	r6, [sp, #12]
 800a3d6:	9405      	str	r4, [sp, #20]
 800a3d8:	9302      	str	r3, [sp, #8]
    *startp++ = v;
 800a3da:	bf38      	it	cc
 800a3dc:	2255      	movcc	r2, #85	; 0x55
  while (startp < endp) {
 800a3de:	d203      	bcs.n	800a3e8 <chThdCreateFromMemoryPool.constprop.40+0x38>
    *startp++ = v;
 800a3e0:	f800 2b01 	strb.w	r2, [r0], #1
  while (startp < endp) {
 800a3e4:	4283      	cmp	r3, r0
 800a3e6:	d1fb      	bne.n	800a3e0 <chThdCreateFromMemoryPool.constprop.40+0x30>
 800a3e8:	2320      	movs	r3, #32
 800a3ea:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800a3ee:	f7f6 ff37 	bl	8001260 <_dbg_check_lock>
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 800a3f2:	4668      	mov	r0, sp
 800a3f4:	f7f6 fa74 	bl	80008e0 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
 800a3f8:	2302      	movs	r3, #2
 800a3fa:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tp->mpool = mp;
 800a3fe:	6405      	str	r5, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 800a400:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(&td);
 800a402:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 800a404:	f7f6 fca4 	bl	8000d50 <chSchWakeupS>
  _dbg_check_unlock();
 800a408:	f7f6 ff02 	bl	8001210 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a40c:	4b0b      	ldr	r3, [pc, #44]	; (800a43c <chThdCreateFromMemoryPool.constprop.40+0x8c>)
 800a40e:	681a      	ldr	r2, [r3, #0]
 800a410:	429a      	cmp	r2, r3
 800a412:	d004      	beq.n	800a41e <chThdCreateFromMemoryPool.constprop.40+0x6e>
 800a414:	6999      	ldr	r1, [r3, #24]
 800a416:	6893      	ldr	r3, [r2, #8]
 800a418:	688a      	ldr	r2, [r1, #8]
 800a41a:	429a      	cmp	r2, r3
 800a41c:	d305      	bcc.n	800a42a <chThdCreateFromMemoryPool.constprop.40+0x7a>
 800a41e:	2300      	movs	r3, #0
 800a420:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 800a424:	4620      	mov	r0, r4
 800a426:	b007      	add	sp, #28
 800a428:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a42a:	4805      	ldr	r0, [pc, #20]	; (800a440 <chThdCreateFromMemoryPool.constprop.40+0x90>)
 800a42c:	f7f6 f9f8 	bl	8000820 <chSysHalt>
    return NULL;
 800a430:	4604      	mov	r4, r0
 800a432:	e7f7      	b.n	800a424 <chThdCreateFromMemoryPool.constprop.40+0x74>
 800a434:	20002720 	.word	0x20002720
 800a438:	08003931 	.word	0x08003931
 800a43c:	20001e68 	.word	0x20001e68
 800a440:	0800c544 	.word	0x0800c544

0800a444 <strchr>:
 800a444:	b2c9      	uxtb	r1, r1
 800a446:	2900      	cmp	r1, #0
 800a448:	d041      	beq.n	800a4ce <strchr+0x8a>
 800a44a:	0782      	lsls	r2, r0, #30
 800a44c:	b4f0      	push	{r4, r5, r6, r7}
 800a44e:	d067      	beq.n	800a520 <strchr+0xdc>
 800a450:	7803      	ldrb	r3, [r0, #0]
 800a452:	2b00      	cmp	r3, #0
 800a454:	d068      	beq.n	800a528 <strchr+0xe4>
 800a456:	4299      	cmp	r1, r3
 800a458:	d037      	beq.n	800a4ca <strchr+0x86>
 800a45a:	1c43      	adds	r3, r0, #1
 800a45c:	e004      	b.n	800a468 <strchr+0x24>
 800a45e:	f813 0b01 	ldrb.w	r0, [r3], #1
 800a462:	b390      	cbz	r0, 800a4ca <strchr+0x86>
 800a464:	4281      	cmp	r1, r0
 800a466:	d02f      	beq.n	800a4c8 <strchr+0x84>
 800a468:	079a      	lsls	r2, r3, #30
 800a46a:	461c      	mov	r4, r3
 800a46c:	d1f7      	bne.n	800a45e <strchr+0x1a>
 800a46e:	6825      	ldr	r5, [r4, #0]
 800a470:	ea41 2301 	orr.w	r3, r1, r1, lsl #8
 800a474:	ea43 4303 	orr.w	r3, r3, r3, lsl #16
 800a478:	ea83 0605 	eor.w	r6, r3, r5
 800a47c:	f1a6 3001 	sub.w	r0, r6, #16843009	; 0x1010101
 800a480:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
 800a484:	ea20 0006 	bic.w	r0, r0, r6
 800a488:	ea22 0205 	bic.w	r2, r2, r5
 800a48c:	4302      	orrs	r2, r0
 800a48e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800a492:	d111      	bne.n	800a4b8 <strchr+0x74>
 800a494:	4620      	mov	r0, r4
 800a496:	f850 6f04 	ldr.w	r6, [r0, #4]!
 800a49a:	ea83 0706 	eor.w	r7, r3, r6
 800a49e:	f1a7 3501 	sub.w	r5, r7, #16843009	; 0x1010101
 800a4a2:	f1a6 3201 	sub.w	r2, r6, #16843009	; 0x1010101
 800a4a6:	ea25 0507 	bic.w	r5, r5, r7
 800a4aa:	ea22 0206 	bic.w	r2, r2, r6
 800a4ae:	432a      	orrs	r2, r5
 800a4b0:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800a4b4:	d0ef      	beq.n	800a496 <strchr+0x52>
 800a4b6:	4604      	mov	r4, r0
 800a4b8:	7820      	ldrb	r0, [r4, #0]
 800a4ba:	b918      	cbnz	r0, 800a4c4 <strchr+0x80>
 800a4bc:	e005      	b.n	800a4ca <strchr+0x86>
 800a4be:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 800a4c2:	b110      	cbz	r0, 800a4ca <strchr+0x86>
 800a4c4:	4281      	cmp	r1, r0
 800a4c6:	d1fa      	bne.n	800a4be <strchr+0x7a>
 800a4c8:	4620      	mov	r0, r4
 800a4ca:	bcf0      	pop	{r4, r5, r6, r7}
 800a4cc:	4770      	bx	lr
 800a4ce:	0783      	lsls	r3, r0, #30
 800a4d0:	d024      	beq.n	800a51c <strchr+0xd8>
 800a4d2:	7803      	ldrb	r3, [r0, #0]
 800a4d4:	2b00      	cmp	r3, #0
 800a4d6:	d0f9      	beq.n	800a4cc <strchr+0x88>
 800a4d8:	1c43      	adds	r3, r0, #1
 800a4da:	e003      	b.n	800a4e4 <strchr+0xa0>
 800a4dc:	7802      	ldrb	r2, [r0, #0]
 800a4de:	3301      	adds	r3, #1
 800a4e0:	2a00      	cmp	r2, #0
 800a4e2:	d0f3      	beq.n	800a4cc <strchr+0x88>
 800a4e4:	0799      	lsls	r1, r3, #30
 800a4e6:	4618      	mov	r0, r3
 800a4e8:	d1f8      	bne.n	800a4dc <strchr+0x98>
 800a4ea:	6819      	ldr	r1, [r3, #0]
 800a4ec:	f1a1 3201 	sub.w	r2, r1, #16843009	; 0x1010101
 800a4f0:	ea22 0201 	bic.w	r2, r2, r1
 800a4f4:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800a4f8:	d108      	bne.n	800a50c <strchr+0xc8>
 800a4fa:	f853 1f04 	ldr.w	r1, [r3, #4]!
 800a4fe:	f1a1 3201 	sub.w	r2, r1, #16843009	; 0x1010101
 800a502:	ea22 0201 	bic.w	r2, r2, r1
 800a506:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 800a50a:	d0f6      	beq.n	800a4fa <strchr+0xb6>
 800a50c:	781a      	ldrb	r2, [r3, #0]
 800a50e:	4618      	mov	r0, r3
 800a510:	b142      	cbz	r2, 800a524 <strchr+0xe0>
 800a512:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800a516:	2b00      	cmp	r3, #0
 800a518:	d1fb      	bne.n	800a512 <strchr+0xce>
 800a51a:	4770      	bx	lr
 800a51c:	4603      	mov	r3, r0
 800a51e:	e7e4      	b.n	800a4ea <strchr+0xa6>
 800a520:	4604      	mov	r4, r0
 800a522:	e7a4      	b.n	800a46e <strchr+0x2a>
 800a524:	4618      	mov	r0, r3
 800a526:	4770      	bx	lr
 800a528:	4618      	mov	r0, r3
 800a52a:	e7ce      	b.n	800a4ca <strchr+0x86>

0800a52c <strpbrk>:
 800a52c:	b430      	push	{r4, r5}
 800a52e:	7804      	ldrb	r4, [r0, #0]
 800a530:	b1dc      	cbz	r4, 800a56a <strpbrk+0x3e>
 800a532:	780d      	ldrb	r5, [r1, #0]
 800a534:	b19d      	cbz	r5, 800a55e <strpbrk+0x32>
 800a536:	42a5      	cmp	r5, r4
 800a538:	d00f      	beq.n	800a55a <strpbrk+0x2e>
 800a53a:	460a      	mov	r2, r1
 800a53c:	e001      	b.n	800a542 <strpbrk+0x16>
 800a53e:	42a3      	cmp	r3, r4
 800a540:	d00b      	beq.n	800a55a <strpbrk+0x2e>
 800a542:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800a546:	2b00      	cmp	r3, #0
 800a548:	d1f9      	bne.n	800a53e <strpbrk+0x12>
 800a54a:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800a54e:	2c00      	cmp	r4, #0
 800a550:	d1f0      	bne.n	800a534 <strpbrk+0x8>
 800a552:	7813      	ldrb	r3, [r2, #0]
 800a554:	2b00      	cmp	r3, #0
 800a556:	bf08      	it	eq
 800a558:	2000      	moveq	r0, #0
 800a55a:	bc30      	pop	{r4, r5}
 800a55c:	4770      	bx	lr
 800a55e:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800a562:	460a      	mov	r2, r1
 800a564:	2c00      	cmp	r4, #0
 800a566:	d1e5      	bne.n	800a534 <strpbrk+0x8>
 800a568:	e7f3      	b.n	800a552 <strpbrk+0x26>
 800a56a:	4620      	mov	r0, r4
 800a56c:	bc30      	pop	{r4, r5}
 800a56e:	4770      	bx	lr

0800a570 <strspn>:
 800a570:	b470      	push	{r4, r5, r6}
 800a572:	7804      	ldrb	r4, [r0, #0]
 800a574:	b1a4      	cbz	r4, 800a5a0 <strspn+0x30>
 800a576:	780e      	ldrb	r6, [r1, #0]
 800a578:	4605      	mov	r5, r0
 800a57a:	b14e      	cbz	r6, 800a590 <strspn+0x20>
 800a57c:	42a6      	cmp	r6, r4
 800a57e:	d00a      	beq.n	800a596 <strspn+0x26>
 800a580:	460a      	mov	r2, r1
 800a582:	e001      	b.n	800a588 <strspn+0x18>
 800a584:	42a3      	cmp	r3, r4
 800a586:	d006      	beq.n	800a596 <strspn+0x26>
 800a588:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800a58c:	2b00      	cmp	r3, #0
 800a58e:	d1f9      	bne.n	800a584 <strspn+0x14>
 800a590:	1a28      	subs	r0, r5, r0
 800a592:	bc70      	pop	{r4, r5, r6}
 800a594:	4770      	bx	lr
 800a596:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 800a59a:	2c00      	cmp	r4, #0
 800a59c:	d1ed      	bne.n	800a57a <strspn+0xa>
 800a59e:	e7f7      	b.n	800a590 <strspn+0x20>
 800a5a0:	4620      	mov	r0, r4
 800a5a2:	e7f6      	b.n	800a592 <strspn+0x22>
